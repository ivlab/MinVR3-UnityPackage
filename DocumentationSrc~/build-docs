#!/usr/bin/env bash

# Key Files and Directories:
# Runtime/Scripts --> root for .cs files that are the source for the API
# Documentation~ --> DocFx destination dir; holds the complete built website.
# DocumentationSrc~ --> DocFx and Markdown source for building the website.
#   index.md --> Markdown content for the landing page (you edit)
#   manual/ --> Markdown content for the manual section (you add/edit)
#   resources/ --> Images / other content (you add/edit)
#   apidocs-overrides/ --> Content contributed with the "Improve this Doc" link
#   api/index.md --> API landing page (you edit)
#   api/* --> Everything other than index.md is generated by DocFx
#   projectMetadata.json --> project-specific settings (you edit)
#   filterConfig.json --> docfx config (you might need to edit)
#   build-docs --> this script (you should not need to edit)
#   docfx.json --> docfx config (you should not need to edit)
#   templates/ --> docfx templates with support for github.umn.edu (no edit)
#   toc.yml --> Defines the structure of the navbar for documentation website


help()
{
  echo "Usage: build-docs [--help|build|serve|clean]"
  echo "options:"
  echo "--serve [default] Builds the webpages and starts a web server on localhost:8080"
  echo "--publish         Git pushes the contents of Documentation~ to origin/gh-pages"
  echo "--build           Builds only, does not start the webserver"
  echo "--clean           Removes temporary files created by DocFx (**/obj/**, api/*.yml)"
  echo "--help            Displays this message"
}



### - configurable variables - ###

# DocFx executable
docfxExe="docfx"   # assumes docfx is installed in the PATH
if [[ $(uname -m) == 'arm64' ]]; then
  docfxExe="/usr/bin/arch -x86_64 docfx"   # special case for apple M1
fi
# TODO: Add additional special cases as needed


# Source will be parsed with these as #defines, can include multiple separated
# by semi-colons.  Useful because, if you want to build docs for code that
# is inside an #if ... #endif block, you need the #if to evalute to true when
# docfx processes it.  To accomplish this instead of writing "#if SOME_VAR"
# simply write "#if SOME_VAR || BUILDING_DOCS".
preprocessorDefines="DOCFX;BUILDING_DOCS"




### - main script - ###

if [ $# -eq 0 ]; then
  buildMode="--serve"
elif [ $# -eq 1 ]; then
  if [[ "$1" == "--serve" ]]; then
    buildMode="--serve"
  elif [[ "$1" == "--build" ]]; then
    buildMode="--build"
  elif [[ "$1" == "--clean" ]]; then
    buildMode="--clean"
  elif [[ "$1" == "--publish" ]]; then
    buildMode="--publish"
  elif [[ "$1" == "--help" ]]; then
    help
    exit 0
  else
    help
    exit 1
  fi
else
  help
  exit 1
fi


# Path to the location of this script, not the same as the cwd since the
# script could be called from anywhere.  DocFx will run from this directory.
# Thus, all other paths should be relative to this directory.
scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
cd $scriptDir

# Paths to important dirs, *relative to the scriptDir*
docSrcDir="."
apiSrcDir="../Runtime/Scripts"
# IMPORTANT: This relative path must exactly match the value for "dest" in the
# last line of the docfx config file, docfx.json.  Like this:
#     "dest": "../Documentation~"
destDir="../Documentation~"

tmpProjFile="api-documentation.csproj"

exe() { echo "  $@" ; "$@" ; }

# unfortunately, docfx does not support an out-of-source build mode, and it leaves
# temporary files littered throughout the project, mostly inside 'obj' dirs.
# Cleaning is not as simple as removing a single build dir.
if [[ "$buildMode" == "--clean" ]]; then
  echo "Cleaning temporary build files."
  exe pwd
  exe find $docSrcDir -type d -name "obj" -exec /bin/rm -rf "{}" +
  exe find $docSrcDir -type f -name "$tmpProjFile" -delete
  exe find $docSrcDir/api -type f -name "*.yml" -delete
  exe find $docSrcDir/api -type f -name ".manifest" -delete
  exe find $apiSrcDir -type d -name "obj" -exec /bin/rm -rf "{}" +
  exit
elif [[ "$buildMode" == "--publish" ]]; then
  cd $scriptDir/..
  exe git subtree push --prefix Documentation\~ origin gh-pages
  exit
fi


echo "Building documentation website..."
echo "- Working Dir: $scriptDir"
echo "- Path to API Source: $apiSrcDir"
echo "- Path to Doc Source: $docSrcDir"

# Create a "fake" msbuild project file that lists all of the api source files
# In theory, DocFx allows us to directly include a group of *.cs files as the
# API source without wrapping them in a project.  In practice, several DocFx
# features only work when a project file is present.
tmpProjFile="api-documentation.csproj"
echo "- MSBuild Project: $tmpProjFile"

# Recursively find all the .cs source files in a way that works with older
# bash versions, like on OSX.
# https://stackoverflow.com/questions/23356779/how-can-i-store-the-find-command-results-as-an-array-in-bash
srcFiles=()
while IFS=  read -r -d $'\0'; do
    srcFiles+=("$REPLY")
done < <(find $apiSrcDir -type f -name '*.cs' -print0)

# Write the msbuild project file
echo "<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">" > $tmpProjFile
echo "<PropertyGroup><DefineConstants>$preprocessorDefines</DefineConstants></PropertyGroup>" >> $tmpProjFile

echo "<ItemGroup>" >> $tmpProjFile
for i in "${srcFiles[@]}"; do
   echo "<Compile Include=\"$i\"/>" >> $tmpProjFile
done
echo "</ItemGroup>" >> $tmpProjFile

# Not sure if there is a way to do this that does not depend on this envvar
# being set.  A no target error is produced if the next line is absent.
echo "<Import Project=\"\$(MSBuildToolsPath)\Microsoft.CSharp.targets\" />" >> $tmpProjFile
echo "</Project>" >> $tmpProjFile


# Clean the output directory so there are no lingering files from a previous
# build
echo "- Output Website: $destDir"
/bin/rm -rf $destDir/*


# 4. Finally, run DocFx with the docfx.json config file
echo "- Running $docfxExe docfx.json $buildMode"
echo ""
$docfxExe docfx.json $buildMode
