using UnityEngine;
using System.Collections.Generic;
using UnityEngine.InputSystem;

//namespace MinVR
//{
    /**
	 * Genertates fake VREvents for non-Unity built-in inputs (like the events from Optitrak or the buttons on the stylus).
	 * This is only for use during debugging on your laptop. Make sure to not to use the script when you deploy your app!
	 * 
	 * To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers.
	 * "Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen
	 * to move the 3D position of that tracker within a plane parallel to the screen.  Hold down 'left shift' while
	 * moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally
	 * to rotate the tracker around the X, Y, or Z axis. 
	 */
    /*
    [AddComponentMenu("Input/Fake Tracking Input")]
    public class FakeTrackingInput : MonoBehaviour
    {


        [Tooltip("Fake head tracking with arrow keys. 'up' moves forward, 'down' moves backward, 'left' rotates left, 'right' rotates right.")]
        public string fakeHeadTrackerEvent = "Head_Move";

        public Vector3 initialHeadPos = new Vector3(0, 1, -2);
        private Vector3 headTrackerPos;

        public Vector3 initialHeadRot = new Vector3();
        private Quaternion headTrackerRot;

        [Tooltip("The name of the VREvent generated by the first fake tracker.")]
        public string fakeTracker1Event = "LHand_Move";

        public Vector3 initialTracker1Pos = new Vector3(0, 0, 0);
        private Vector3 tracker1Pos;
        public Vector3 initialTracker1Rot = new Vector3();
        private Quaternion tracker1Rot;

        [Tooltip("The name of the VREvent generated by the second fake tracker.")]
        public string fakeTracker2Event = "RHand_Move";

        public Vector3 initialTracker2Pos = new Vector3(0, 0, 0);
        private Vector3 tracker2Pos;
        public Vector3 initialTracker2Rot = new Vector3();
        private Quaternion tracker2Rot;

        private int curTracker = 0;
        private float lastx = float.NaN;
        private float lasty = float.NaN;


        private void OnEnable()
        {
            headTrackerPos = initialHeadPos;
            headTrackerRot = Quaternion.Euler(initialHeadRot);
            tracker1Pos = initialTracker1Pos;
            tracker1Rot = Quaternion.Euler(initialTracker1Rot);
            tracker2Pos = initialTracker2Pos;
            tracker2Rot = Quaternion.Euler(initialTracker1Rot);


            // Add mouse device.
            if (m_VirtualMouse == null)
                m_VirtualMouse = (Mouse)InputSystem.AddDevice("VirtualMouse");
            else if (!m_VirtualMouse.added)
                InputSystem.AddDevice(m_VirtualMouse);


            // Hook into input update.
            if (m_AfterInputUpdateDelegate == null)
                m_AfterInputUpdateDelegate = OnAfterInputUpdate;
            InputSystem.onAfterUpdate += m_AfterInputUpdateDelegate;



            // Hook into input update.
            if (m_AfterInputUpdateDelegate == null)
                m_AfterInputUpdateDelegate = OnAfterInputUpdate;
            InputSystem.onAfterUpdate += m_AfterInputUpdateDelegate;

            // Hook into actions.
            if (m_ButtonActionTriggeredDelegate == null)
                m_ButtonActionTriggeredDelegate = OnButtonActionTriggered;
            SetActionCallback(m_LeftButtonAction, m_ButtonActionTriggeredDelegate, true);
            SetActionCallback(m_RightButtonAction, m_ButtonActionTriggeredDelegate, true);
            SetActionCallback(m_MiddleButtonAction, m_ButtonActionTriggeredDelegate, true);
            SetActionCallback(m_ForwardButtonAction, m_ButtonActionTriggeredDelegate, true);
            SetActionCallback(m_BackButtonAction, m_ButtonActionTriggeredDelegate, true);

            // Enable actions.
            m_StickAction.action?.Enable();
            m_LeftButtonAction.action?.Enable();
            m_RightButtonAction.action?.Enable();
            m_MiddleButtonAction.action?.Enable();
            m_ForwardButtonAction.action?.Enable();
            m_BackButtonAction.action?.Enable();
            m_ScrollWheelAction.action?.Enable();
        }


        private void OnDisable()
        {
            // Remove mouse device.
            if (m_VirtualMouse != null && m_VirtualMouse.added)
                InputSystem.RemoveDevice(m_VirtualMouse);

            // Let go of system mouse.
            if (m_SystemMouse != null) {
                InputSystem.EnableDevice(m_SystemMouse);
                m_SystemMouse = null;
            }

            // Remove ourselves from input update.
            if (m_AfterInputUpdateDelegate != null)
                InputSystem.onAfterUpdate -= m_AfterInputUpdateDelegate;

            // Disable actions.
            m_StickAction.action?.Disable();
            m_LeftButtonAction.action?.Disable();
            m_RightButtonAction.action?.Disable();
            m_MiddleButtonAction.action?.Disable();
            m_ForwardButtonAction.action?.Disable();
            m_BackButtonAction.action?.Disable();
            m_ScrollWheelAction.action?.Disable();

            // Unhock from actions.
            if (m_ButtonActionTriggeredDelegate != null) {
                SetActionCallback(m_LeftButtonAction, m_ButtonActionTriggeredDelegate, false);
                SetActionCallback(m_RightButtonAction, m_ButtonActionTriggeredDelegate, false);
                SetActionCallback(m_MiddleButtonAction, m_ButtonActionTriggeredDelegate, false);
                SetActionCallback(m_ForwardButtonAction, m_ButtonActionTriggeredDelegate, false);
                SetActionCallback(m_BackButtonAction, m_ButtonActionTriggeredDelegate, false);
            }

            m_LastTime = default;
            m_LastStickValue = default;
        }


        private void OnAfterInputUpdate()
        {
            AddHeadTrackerEvent();
            AddTrackerEvents();
        }


        void Start()
        {

        }



        private void UpdateActions()
        {
            // Head Tracker
            if (Keyboard.current.upArrowKey.wasPressedThisFrame) {
                headTrackerPos += 0.1f * Camera.main.transform.forward;
            } else if (Keyboard.current.downArrowKey.wasPressedThisFrame) {
                headTrackerPos -= 0.1f * Camera.main.transform.forward;
            } else if (Keyboard.current.leftArrowKey.wasPressedThisFrame) {
                headTrackerRot *= Quaternion.AngleAxis(-1.0f, new Vector3(0f, 1f, 0f));
            } else if (Keyboard.current.rightArrowKey.wasPressedThisFrame) {
                headTrackerRot *= Quaternion.AngleAxis(1.0f, new Vector3(0f, 1f, 0f));
            }

            InputState.Change(m_VirtualMouse.position, newPosition);
            InputState.Change(m_VirtualMouse.delta, delta);

            Matrix4x4 m3 = Matrix4x4.TRS(headTrackerPos, headTrackerRot, Vector3.one);
            float[] d3 = VRConvert.ToFloatArray(m3);
            VREvent e = new VREvent(fakeHeadTrackerEvent);
            e.AddData("EventType", "TrackerMove");
            e.AddData("Transform", d3);
            eventList.Add(e);
        }


        private void AddTrackerEvents(ref List<VREvent> eventList)
        {
            float x = Input.mousePosition.x;
            float y = Input.mousePosition.y;
            // first time through
            if (float.IsNaN(lastx)) {
                lastx = x;
                lasty = y;
                return;
            }

            if (Input.GetKeyDown("1")) {
                curTracker = 0;
            } else if (Input.GetKeyDown("2")) {
                curTracker = 1;
            }

            if (Input.GetKey("x")) {
                float angle = 0.1f * (x - lastx);
                if (curTracker == 0) {
                    tracker1Rot = Quaternion.AngleAxis(angle, new Vector3(1f, 0f, 0f)) * tracker1Rot;
                } else if (curTracker == 1) {
                    tracker2Rot = Quaternion.AngleAxis(angle, new Vector3(1f, 0f, 0f)) * tracker2Rot;
                }
            } else if (Input.GetKey("y")) {
                float angle = 0.1f * (x - lastx);
                if (curTracker == 0) {
                    tracker1Rot = Quaternion.AngleAxis(angle, new Vector3(0f, 1f, 0f)) * tracker1Rot;
                } else if (curTracker == 1) {
                    tracker2Rot = Quaternion.AngleAxis(angle, new Vector3(0f, 1f, 0f)) * tracker2Rot;
                }
            } else if (Input.GetKey("z")) {
                float angle = 0.1f * (x - lastx);
                if (curTracker == 0) {
                    tracker1Rot = Quaternion.AngleAxis(angle, new Vector3(0f, 0f, 1f)) * tracker1Rot;
                } else if (curTracker == 1) {
                    tracker2Rot = Quaternion.AngleAxis(angle, new Vector3(0f, 0f, 1f)) * tracker2Rot;
                }
            } else if (Input.GetKey("left shift")) {
                float depth = 0.005f * (y - lasty);
                if (curTracker == 0) {
                    tracker1Pos += depth * Camera.main.transform.forward;
                } else if (curTracker == 1) {
                    tracker2Pos += depth * Camera.main.transform.forward;
                }
            } else {
                Ray ray = Camera.main.ScreenPointToRay(new Vector3(x, y, 0f));
                Plane p = new Plane();
                float dist = 0.0f;
                if (curTracker == 0) {
                    p.SetNormalAndPosition(-Camera.main.transform.forward, tracker1Pos);
                    if (p.Raycast(ray, out dist)) {
                        tracker1Pos = ray.GetPoint(dist);
                    }
                } else if (curTracker == 1) {
                    p.SetNormalAndPosition(-Camera.main.transform.forward, tracker2Pos);
                    if (p.Raycast(ray, out dist)) {
                        tracker2Pos = ray.GetPoint(dist);
                    }
                }

            }

            // for fake traker 1
            Matrix4x4 m1 = Matrix4x4.TRS(tracker1Pos, tracker1Rot, Vector3.one);
            float[] d1 = VRConvert.ToFloatArray(m1);
            VREvent e1 = new VREvent(fakeTracker1Event);
            e1.AddData("EventType", "TrackerMove");
            e1.AddData("Transform", d1);
            eventList.Add(e1);

            // for fake traker 2
            Matrix4x4 m2 = Matrix4x4.TRS(tracker2Pos, tracker2Rot, Vector3.one);
            float[] d2 = VRConvert.ToFloatArray(m2);
            VREvent e2 = new VREvent(fakeTracker2Event);
            e2.AddData("EventType", "TrackerMove");
            e2.AddData("Transform", d2);
            eventList.Add(e2);

            // 
            this.lastx = x;
            this.lasty = y;
        }






            // Read current stick value.
            var stickAction = m_StickAction.action;
            if (stickAction == null)
                return;
            var stickValue = stickAction.ReadValue<Vector2>();
            if (Mathf.Approximately(0, stickValue.x) && Mathf.Approximately(0, stickValue.y)) {
                // Motion has stopped.
                m_LastTime = default;
                m_LastStickValue = default;
            } else {
                var currentTime = InputState.currentTime;
                if (Mathf.Approximately(0, m_LastStickValue.x) && Mathf.Approximately(0, m_LastStickValue.y)) {
                    // Motion has started.
                    m_LastTime = currentTime;
                }

                // Compute delta.
                var deltaTime = (float)(currentTime - m_LastTime);
                var delta = new Vector2(m_CursorSpeed * stickValue.x * deltaTime, m_CursorSpeed * stickValue.y * deltaTime);

                // Update position.
                var currentPosition = m_VirtualMouse.position.ReadValue();
                var newPosition = currentPosition + delta;

                ////REVIEW: for the hardware cursor, clamp to something else?
                // Clamp to canvas.
                if (m_Canvas != null) {
                    // Clamp to canvas.
                    var pixelRect = m_Canvas.pixelRect;
                    newPosition.x = Mathf.Clamp(newPosition.x, pixelRect.xMin, pixelRect.xMax);
                    newPosition.y = Mathf.Clamp(newPosition.y, pixelRect.yMin, pixelRect.yMax);
                }

                ////REVIEW: the fact we have no events on these means that actions won't have an event ID to go by; problem?
                InputState.Change(m_VirtualMouse.position, newPosition);
                InputState.Change(m_VirtualMouse.delta, delta);

                // Update software cursor transform, if any.
                if (m_CursorTransform != null &&
                    (m_CursorMode == CursorMode.SoftwareCursor ||
                     (m_CursorMode == CursorMode.HardwareCursorIfAvailable && m_SystemMouse == null)))
                    m_CursorTransform.anchoredPosition = newPosition;

                m_LastStickValue = stickValue;
                m_LastTime = currentTime;

                // Update hardware cursor.
                m_SystemMouse?.WarpCursorPosition(newPosition);
            }

            // Update scroll wheel.
            var scrollAction = m_ScrollWheelAction.action;
            if (scrollAction != null) {
                var scrollValue = scrollAction.ReadValue<Vector2>();
                scrollValue.x *= m_ScrollSpeed;
                scrollValue.y *= m_ScrollSpeed;

                InputState.Change(m_VirtualMouse.scroll, scrollValue);
            }
        }



        private static void SetActionCallback(InputActionProperty field, Action<InputAction.CallbackContext> callback, bool install = true)
        {
            var action = field.action;
            if (action == null)
                return;

            // We don't need the performed callback as our mouse buttons are binary and thus
            // we only care about started (1) and canceled (0).

            if (install) {
                action.started += callback;
                action.canceled += callback;
            } else {
                action.started -= callback;
                action.canceled -= callback;
            }
        }

        private static void SetAction(ref InputActionProperty field, InputActionProperty value)
        {
            var oldValue = field;
            field = value;

            if (oldValue.reference == null) {
                var oldAction = oldValue.action;
                if (oldAction != null && oldAction.enabled) {
                    oldAction.Disable();
                    if (value.reference == null)
                        value.action?.Enable();
                }
            }
        }


        [Header("Fake Input Generated")]
        [Tooltip("Name of the ")]
        [SerializeField] private string m_HeadMoveActionName = "Head Move";
        [SerializeField] private string m_HeadRotateActionName = "Head Rotate";
        [SerializeField] private string m_Tracker1MoveActionName = "DH Move";
        [SerializeField] private string m_Tracker1RotateActionName = "DH Rotate";
        [SerializeField] private string m_Tracker2MoveActionName = "NDH Move";
        [SerializeField] private string m_Tracker2RotateActionName = "NDH Rotate";

        [Space(10)]
        [Header("Desktop Controls")]
        [Tooltip("Mouse Vector2 action used to drive the fake 3D movement.")]
        [SerializeField] private InputActionProperty m_MouseAction;
        [Tooltip("Button action used to enter/exit depth mode, where vertical mouse movement moves the tracker in the depth dimension.")]
        [SerializeField] private InputActionProperty m_DepthModeAction;
        [Tooltip("Button action used to enter/exit X-Rotation mode, where horizontal mouse movement rotates the tracker around the X axis.")]
        [SerializeField] private InputActionProperty m_XRotModeAction;
        [Tooltip("Button action used to enter/exit Y-Rotation mode, where horizontal mouse movement rotates the tracker around the Y axis.")]
        [SerializeField] private InputActionProperty m_YRotModeAction;
        [Tooltip("Button action used to enter/exit Z-Rotation mode, where horizontal mouse movement rotates the tracker around the Z axis.")]
        [SerializeField] private InputActionProperty m_ZRotModeAction;
        [Tooltip("Button action used to make toggle Tracker #1 on/off.")]
        [SerializeField] private InputActionProperty m_Tracker1ToggleAction;
        [Tooltip("Button action used to make toggle Tracker #2 on/off.")]
        [SerializeField] private InputActionProperty m_Tracker2ToggleAction;
        [Tooltip("Button action used to move the head tracker forward.")]
        [SerializeField] private InputActionProperty m_HeadForwardAction;
        [Tooltip("Button action used to move the head tracker backward.")]
        [SerializeField] private InputActionProperty m_HeadBackwardAction;
        [Tooltip("Button action used to rotate the head tracker to look left.")]
        [SerializeField] private InputActionProperty m_HeadLeftAction;
        [Tooltip("Button action used to rotate the head tracker to look right.")]
        [SerializeField] private InputActionProperty m_HeadRightAction;

    }
}
// namespace MinVR
    */