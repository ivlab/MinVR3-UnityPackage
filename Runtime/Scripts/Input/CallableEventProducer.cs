using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace IVLab.MinVR3
{

    /// <summary>
    /// Implements a virtual input device where the prototypes for the VREvents generated by the device
    /// can be specified in the Editor and the corresponding events can be produced at runtime by calling
    /// a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any).
    /// </summary>
    public class CallableEventProducer : MonoBehaviour, IVREventProducer
    {

        public List<VREventPrototypeAny> eventPrototypes {
            get { return m_EventPrototypes; }
            set {
                m_EventPrototypes = value;
                SetEditorModeForEventPrototypes();
            }
        }

        public void ProduceVREvent(string eventName)
        {
            Debug.Assert(GetPrototypeByNameAndType(eventName, "") != null,
                $"Prototype not found for a VREvent named '{eventName}' with no data argument.");
            VREngine.Instance.eventManager.QueueEvent(new VREvent(eventName));
        }


        public void ProduceVREvent(string eventName, Vector2 eventData)
        {
            VREventPrototypeAny ep = GetPrototypeByNameAndType(eventName, typeof(Vector2).Name);
            Debug.Assert(ep != null, $"Prototype not found for a VREvent named '{eventName}' with data argument '{typeof(Vector2).Name}'.");
            VREngine.Instance.eventManager.QueueEvent(new VREventVector2(eventName, eventData));
        }

        public void ProduceVREvent(string eventName, Vector3 eventData)
        {
            VREventPrototypeAny ep = GetPrototypeByNameAndType(eventName, typeof(Vector3).Name);
            Debug.Assert(ep != null, $"Prototype not found for a VREvent named '{eventName}' with data argument '{typeof(Vector3).Name}'.");
            VREngine.Instance.eventManager.QueueEvent(new VREventVector3(eventName, eventData));
        }

        public void ProduceVREvent(string eventName, Vector4 eventData)
        {
            VREventPrototypeAny ep = GetPrototypeByNameAndType(eventName, typeof(Vector4).Name);
            Debug.Assert(ep != null, $"Prototype not found for a VREvent named '{eventName}' with data argument '{typeof(Vector4).Name}'.");
            VREngine.Instance.eventManager.QueueEvent(new VREventVector4(eventName, eventData));
        }

        public void ProduceVREvent(string eventName, Quaternion eventData)
        {
            VREventPrototypeAny ep = GetPrototypeByNameAndType(eventName, typeof(Quaternion).Name);
            Debug.Assert(ep != null, $"Prototype not found for a VREvent named '{eventName}' with data argument '{typeof(Quaternion).Name}'.");
            VREngine.Instance.eventManager.QueueEvent(new VREventQuaternion(eventName, eventData));
        }

        public void ProduceVREvent(string eventName, GameObject eventData)
        {
            VREventPrototypeAny ep = GetPrototypeByNameAndType(eventName, typeof(GameObject).Name);
            Debug.Assert(ep != null, $"Prototype not found for a VREvent named '{eventName}' with data argument '{typeof(GameObject).Name}'.");
            VREngine.Instance.eventManager.QueueEvent(new VREventGameObject(eventName, eventData));
        }

        public void ProduceVREvent(string eventName, float eventData)
        {
            VREventPrototypeAny ep = GetPrototypeByNameAndType(eventName, typeof(float).Name);
            Debug.Assert(ep != null, $"Prototype not found for a VREvent named '{eventName}' with data argument '{typeof(float).Name}'.");
            VREngine.Instance.eventManager.QueueEvent(new VREventFloat(eventName, eventData));
        }

        public void ProduceVREvent(string eventName, int eventData)
        {
            VREventPrototypeAny ep = GetPrototypeByNameAndType(eventName, typeof(int).Name);
            Debug.Assert(ep != null, $"Prototype not found for a VREvent named '{eventName}' with data argument '{typeof(int).Name}'.");
            VREngine.Instance.eventManager.QueueEvent(new VREventInt(eventName, eventData));
        }

        public void ProduceVREvent(string eventName, string eventData)
        {
            VREventPrototypeAny ep = GetPrototypeByNameAndType(eventName, typeof(string).Name);
            Debug.Assert(ep != null, $"Prototype not found for a VREvent named '{eventName}' with data argument '{typeof(string).Name}'.");
            VREngine.Instance.eventManager.QueueEvent(new VREventString(eventName, eventData));
        }


        public VREventPrototypeAny GetPrototypeByNameAndType(string eventName, string eventDataTypeName)
        {
            foreach (var ep in m_EventPrototypes) {
                if ((ep.GetEventName() == eventName) && (ep.GetEventDataTypeName() == eventDataTypeName)) {
                    return ep;
                }
            }
            return null;
        }

        public List<IVREventPrototype> GetEventPrototypes()
        {
            List<IVREventPrototype> eventsProduced = new List<IVREventPrototype>();
            if (m_EventPrototypes != null) {
                foreach (var ep in m_EventPrototypes) {
                    eventsProduced.Add(ep);
                }
            }
            return eventsProduced;
        }

        void SetEditorModeForEventPrototypes()
        {
            if (m_EventPrototypes != null) {
                foreach (var ep in m_EventPrototypes) {
                    // VREventPrototypeAny supports two different editor modes.  Usually, we want to provide
                    // a dropdown list in the editor so programmers can select an event prototype from a
                    // list of known prototypes provided by the event manager.  This is the other case.  In
                    // a virtual input device like this, we want the editor interface to make it possible
                    // for us to define a new name and type for an event.
                    ep.SetDefineNewPrototypeInEditor(true);
                }
            }
        }

        void OnValidate()
        {
            SetEditorModeForEventPrototypes();
        }

        [Tooltip("This list must contain a prototype for every event the virtual Input Device can produce.")]
        [SerializeField] private List<VREventPrototypeAny> m_EventPrototypes;
    }

} // end namespace
