using UnityEngine;
using System.Collections.Generic;

namespace IVLab.MinVR3 {


    /// <summary>
    /// Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands).  This is similar to the 
	/// XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better
    /// mouse and keyboard controls (IMHO).
    ///
    /// This is only intended to be used while debugging and testing; not for an actual deployed VR app!
    ///
    /// To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers.
	/// "Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen
	/// to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while
	/// moving the mouse vertically to change the 3D depth.  Hold 'x', 'y', or 'z' while moving the mouse horizontally
	/// to rotate the tracker around the X, Y, or Z axis.
    ///
    /// Move the head around with the arrow keys.
    /// </summary>
    [AddComponentMenu("MinVR/Input/Fake Trackers (Desktop VR Debugging)")]
    public class FakeTrackers : MonoBehaviour, IPolledInputDevice {

        [Tooltip("Prepended to the name of each VREvent produced")]
        [SerializeField] private string m_DeviceIdString = "FakeTrackers/";

        [Header("Head Tracker")]
        [SerializeField] private KeyCode moveHeadForwardKey;
        [SerializeField] private KeyCode moveHeadBackKey;
        [SerializeField] private KeyCode turnHeadLeftKey;
        [SerializeField] private KeyCode turnHeadRightKey;
        
        [Header("Head Tracker - Alternative Movements")]
        [SerializeField] private KeyCode moveHeadForwardKey2;
        [SerializeField] private KeyCode moveHeadBackKey2;
        [SerializeField] private KeyCode moveHeadLeftKey;
        [SerializeField] private KeyCode moveHeadRightKey;
        [SerializeField] private KeyCode moveHeadUpKey;
        [SerializeField] private KeyCode moveHeadDownKey;

        [Range(0.0f, 10.0f)]
        [SerializeField] private float forwardBackSensitivity = 1.0f;
        [Range(0.0f, 10.0f)]
        [SerializeField] private float turningSensitivity = 0.5f;

        [Tooltip("Fake head tracking with arrow keys. 'up' moves forward, 'down' moves backward, 'left' rotates left, 'right' rotates right.")]
        [SerializeField] private string headTrackerBaseName;
        [SerializeField] private Vector3 initialHeadPos;
        [SerializeField] private Vector3 initialHeadRot;
        [SerializeField] private string leftEyeTrackerBaseName;
        [SerializeField] private string rightEyeTrackerBaseName;

        [Header("Trackers")]
        [SerializeField] private bool trackersFollowCamera = true;
        [SerializeField] private KeyCode toggleTracker1Key;
        [SerializeField] private KeyCode toggleTracker2Key;
        [SerializeField] private KeyCode rotateXKey;
        [SerializeField] private KeyCode rotateYKey;
        [SerializeField] private KeyCode rotateZKey;
        [SerializeField] private KeyCode dollyKey;

        [Tooltip("Base name of the VREvent generated by the first fake tracker.")]
        [SerializeField] private string tracker1BaseName;
        [SerializeField] private Vector3 initialTracker1Pos;
        [SerializeField] private Vector3 initialTracker1Rot;

        [Tooltip("Base name of the VREvent generated by the second fake tracker.")]
        [SerializeField] private string tracker2BaseName;

        [Tooltip("Camera for raycasts into the scene to do mouse-based control of the trackers -- defaults to Camera.main.")]
        [SerializeField] private Camera sceneCam;

        [SerializeField] private Vector3 initialTracker2Pos;
        [SerializeField] private Vector3 initialTracker2Rot;

        private Vector3 headTrackerPos;
        private Quaternion headTrackerRot;
        private Vector3 tracker2Pos;
        private Quaternion tracker2Rot;
        private Vector3 tracker1Pos;
        private Quaternion tracker1Rot;
        private int curTracker;
        private float lastx;
        private float lasty;
        private bool initialPoll;

        // Rotate camera with right mouse click
        private float headRotationX = 0.0f;
        private Vector2 prevMousePos;

        // Trackers follow camera
        private Vector3 sceneCamToTracker1;
        private Vector3 sceneCamToTracker2;
        private Vector3 prevSceneCamForward;
        private float angleTracker2AndCamForwards;
        private float angleTracker2AndCamUps;


        private void OnEnable()
        {
            VREngine.Instance.eventManager.AddPolledInputDevice(this);
        }

        private void OnDisable()
        {
            VREngine.Instance?.eventManager?.RemovePolledInputDevice(this);
        }

        void Reset()
        {
            m_DeviceIdString = "FakeTrackers/";
            headTrackerBaseName = "Head";
            initialHeadPos = new Vector3(0, 0.5f, -1.5f);
            initialHeadRot = new Vector3();

            leftEyeTrackerBaseName = "LeftEye";
            rightEyeTrackerBaseName = "RightEye";

            trackersFollowCamera = true;

            tracker1BaseName = "Tracker 1";
            initialTracker1Pos = new Vector3(0.5f, 0, 0);
            initialTracker1Rot = new Vector3();

            tracker2BaseName = "Tracker 2";
            initialTracker2Pos = new Vector3(-0.5f, 0, 0);
            initialTracker2Rot = new Vector3();

            moveHeadForwardKey = KeyCode.UpArrow;
            moveHeadBackKey = KeyCode.DownArrow;
            turnHeadLeftKey = KeyCode.LeftArrow;
            turnHeadRightKey = KeyCode.RightArrow;
            moveHeadUpKey = KeyCode.E;
            moveHeadDownKey = KeyCode.Q;
            moveHeadForwardKey2 = KeyCode.W;
            moveHeadBackKey2 = KeyCode.S;
            moveHeadLeftKey = KeyCode.A;
            moveHeadRightKey = KeyCode.D;
            toggleTracker1Key = KeyCode.Alpha1;
            toggleTracker2Key = KeyCode.Alpha2;
            rotateXKey = KeyCode.X;
            rotateYKey = KeyCode.Y;
            rotateZKey = KeyCode.Z;
            dollyKey = KeyCode.LeftShift;

            forwardBackSensitivity = 1.0f;
            turningSensitivity = 0.5f;

            sceneCam = null;
        }

        void Start() {
            initialPoll = true;
            curTracker = 0;
            lastx = float.NaN;
            lasty = float.NaN;
            headTrackerPos = initialHeadPos;
            headTrackerRot = Quaternion.Euler(initialHeadRot);
            tracker1Pos = initialTracker1Pos;
            tracker1Rot = Quaternion.Euler(initialTracker1Rot);
            tracker2Pos = initialTracker2Pos;
            tracker2Rot = Quaternion.Euler(initialTracker2Rot);

            if (sceneCam == null) {
                sceneCam = Camera.main;
                sceneCamToTracker2 = tracker2Pos - sceneCam.transform.position;
            }
        }

        public void PollForEvents(ref List<VREvent> eventQueue)
        {
            QueueHeadTrackerEvents(ref eventQueue);
            QueueRegularTrackerEvents(ref eventQueue);
            initialPoll = false;
        }

        private void QueueHeadTrackerEvents(ref List<VREvent> eventQueue) {
            bool sendEvent = false;

            if (KeyboardState.KeyIsPressed(moveHeadForwardKey) || KeyboardState.KeyIsPressed(moveHeadForwardKey2)) {
                sendEvent = true;
                headTrackerPos += forwardBackSensitivity * 0.005f * sceneCam.transform.forward;
            }
            else if (KeyboardState.KeyIsPressed(moveHeadBackKey) || KeyboardState.KeyIsPressed(moveHeadBackKey2)) {
                sendEvent = true;
                headTrackerPos -= forwardBackSensitivity * 0.005f * sceneCam.transform.forward;
            }
            else if (KeyboardState.KeyIsPressed(moveHeadUpKey)) {
                sendEvent = true;
                headTrackerPos += forwardBackSensitivity * 0.005f * sceneCam.transform.up;
            }
            else if (KeyboardState.KeyIsPressed(moveHeadDownKey)) {
                sendEvent = true;
                headTrackerPos -= forwardBackSensitivity * 0.005f * sceneCam.transform.up;
            }
            else if (KeyboardState.KeyIsPressed(moveHeadRightKey)) {
                sendEvent = true;
                headTrackerPos += forwardBackSensitivity * 0.005f * sceneCam.transform.right;
            }
            else if (KeyboardState.KeyIsPressed(moveHeadLeftKey)) {
                sendEvent = true;
                headTrackerPos -= forwardBackSensitivity * 0.005f * sceneCam.transform.right;
            }
            else if (KeyboardState.KeyIsPressed(turnHeadLeftKey)) {
                sendEvent = true;
                headTrackerRot *= Quaternion.AngleAxis(turningSensitivity * -0.3f, new Vector3(0f, 1f, 0f));
            }
            else if (KeyboardState.KeyIsPressed(turnHeadRightKey)) {
                sendEvent = true;
                headTrackerRot *= Quaternion.AngleAxis(turningSensitivity * 0.3f, new Vector3(0f, 1f, 0f));
            }

            // Hold right-mouse button to rotate
            if (prevMousePos == Vector2.zero)
            {
                prevMousePos = MouseState.Position();
            }
            if (MouseState.RightButtonIsPressed()) {
                sendEvent = true;
                Vector2 deltaMousePos = MouseState.Position() - prevMousePos; 
                float headRotationY = headTrackerRot.eulerAngles.y + deltaMousePos.x * turningSensitivity;        
                headRotationX += deltaMousePos.y * turningSensitivity;
                headRotationX = Mathf.Clamp(headRotationX, -90f, 90f);
                headTrackerRot.eulerAngles = new Vector3(-headRotationX, headRotationY, 0.0f);
            }
            prevMousePos = MouseState.Position();

            if ((sendEvent) || (initialPoll)) {
                CheckTrackersFollowCamera(ref eventQueue);
                eventQueue.Add(new VREventVector3(m_DeviceIdString + headTrackerBaseName + "/Position", headTrackerPos));
                eventQueue.Add(new VREventQuaternion(m_DeviceIdString + headTrackerBaseName + "/Rotation", headTrackerRot));
                eventQueue.Add(new VREventVector3(m_DeviceIdString + leftEyeTrackerBaseName + "/Position", headTrackerPos));
                eventQueue.Add(new VREventVector3(m_DeviceIdString + rightEyeTrackerBaseName + "/Position", headTrackerPos));
            }
        }

        private void CheckTrackersFollowCamera(ref List<VREvent> eventQueue) {
            if (trackersFollowCamera) {
                if (prevSceneCamForward == Vector3.zero) {
                    prevSceneCamForward = sceneCam.transform.forward;
                }
                
                Quaternion camRotation = Quaternion.FromToRotation(prevSceneCamForward, sceneCam.transform.forward);

                if (curTracker == 0) {
                    sceneCamToTracker2 = camRotation * sceneCamToTracker2;
                    tracker2Rot = camRotation * tracker2Rot;  // TODO: This is not the correct rotation for tracker
                    tracker2Pos = sceneCam.transform.position + sceneCamToTracker2;
                    eventQueue.Add(new VREventQuaternion(m_DeviceIdString + tracker2BaseName + "/Rotation", tracker2Rot));
                    eventQueue.Add(new VREventVector3(m_DeviceIdString + tracker2BaseName + "/Position", tracker2Pos));
                }
                else if (curTracker == 1) {
                    sceneCamToTracker1 = camRotation * sceneCamToTracker1;
                    tracker1Rot = camRotation * tracker1Rot;  // TODO: This is not the correct rotation for tracker
                    tracker1Pos = sceneCam.transform.position + sceneCamToTracker1;
                    eventQueue.Add(new VREventQuaternion(m_DeviceIdString + tracker1BaseName + "/Rotation", tracker1Rot));
                    eventQueue.Add(new VREventVector3(m_DeviceIdString + tracker1BaseName + "/Position", tracker1Pos));
                }
            }
            prevSceneCamForward = sceneCam.transform.forward;
        }


        private void QueueRegularTrackerEvents(ref List<VREvent> eventQueue) {
            Debug.Assert(sceneCam != null, "A scene camera must be set or one of the cameras in the scene must be tagged with MainCamera.");

            float x = MouseState.Position().x;
            float y = MouseState.Position().y;


            // first time through
            if (float.IsNaN(lastx)) {
                lastx = x;
                lasty = y;
                return;
            }

            bool sendEvent = false;

            if (KeyboardState.KeyWasPressedThisFrame(toggleTracker1Key)) {
                curTracker = 0;
            } else if (KeyboardState.KeyWasPressedThisFrame(toggleTracker2Key)) {
                curTracker = 1;
            }

            if (KeyboardState.KeyIsPressed(rotateXKey)) {
                float angle = 0.1f * (x - lastx);
                sendEvent = (angle != 0.0);
                if (curTracker == 0) {
                    tracker1Rot = Quaternion.AngleAxis(angle, new Vector3(1f, 0f, 0f)) * tracker1Rot;
                } else if (curTracker == 1) {
                    tracker2Rot = Quaternion.AngleAxis(angle, new Vector3(1f, 0f, 0f)) * tracker2Rot;
                }
            } else if (KeyboardState.KeyIsPressed(rotateYKey)) {
                float angle = 0.1f * (x - lastx);
                sendEvent = (angle != 0.0);
                if (curTracker == 0) {
                    tracker1Rot = Quaternion.AngleAxis(angle, new Vector3(0f, 1f, 0f)) * tracker1Rot;
                } else if (curTracker == 1) {
                    tracker2Rot = Quaternion.AngleAxis(angle, new Vector3(0f, 1f, 0f)) * tracker2Rot;
                }
            } else if (KeyboardState.KeyIsPressed(rotateZKey)) {
                float angle = 0.1f * (x - lastx);
                sendEvent = (angle != 0.0);
                if (curTracker == 0) {
                    tracker1Rot = Quaternion.AngleAxis(angle, new Vector3(0f, 0f, 1f)) * tracker1Rot;
                } else if (curTracker == 1) {
                    tracker2Rot = Quaternion.AngleAxis(angle, new Vector3(0f, 0f, 1f)) * tracker2Rot;
                }
            } else if (KeyboardState.KeyIsPressed(dollyKey)) {
                float depth = 0.005f * (y - lasty);
                sendEvent = (depth != 0.0);
                if (curTracker == 0) {
                    tracker1Pos += depth * sceneCam.transform.forward;
                } else if (curTracker == 1) {
                    tracker2Pos += depth * sceneCam.transform.forward;
                }
            } else {
                sendEvent = (x != lastx) || (y != lasty);
                Ray ray = sceneCam.ScreenPointToRay(new Vector3(x, y, 0f));
                Plane p = new Plane();
                float dist = 0.0f;
                if (curTracker == 0) {
                    Vector3 trackerWorld = transform.TransformPoint(tracker1Pos);
                    p.SetNormalAndPosition(-sceneCam.transform.forward, trackerWorld);
                    if (p.Raycast(ray, out dist)) {
                        trackerWorld = ray.GetPoint(dist);
                        tracker1Pos = transform.InverseTransformPoint(trackerWorld);
                    }
                } else if (curTracker == 1) {
                    Vector3 trackerWorld = transform.TransformPoint(tracker2Pos);
                    p.SetNormalAndPosition(-sceneCam.transform.forward, trackerWorld);
                    if (p.Raycast(ray, out dist)) {
                        trackerWorld = ray.GetPoint(dist);
                        tracker2Pos = transform.InverseTransformPoint(trackerWorld);
                    }
                }
            }

            if ((sendEvent) || (initialPoll)) {
                sceneCamToTracker1 = tracker1Pos - sceneCam.transform.position;
                sceneCamToTracker2 = tracker2Pos - sceneCam.transform.position;

                Vector3 tracker2Forward = tracker2Rot * Vector3.forward;
                Vector3 tracker2Up = tracker2Rot * Vector3.up;
                angleTracker2AndCamForwards = Vector3.SignedAngle(tracker2Forward, sceneCam.transform.forward, tracker2Up);
                angleTracker2AndCamUps = Vector3.SignedAngle(tracker2Up, sceneCam.transform.up, tracker2Forward);

                if ((curTracker == 0) || (initialPoll)) {
                    eventQueue.Add(new VREventVector3(m_DeviceIdString + tracker1BaseName + "/Position", tracker1Pos));
                    eventQueue.Add(new VREventQuaternion(m_DeviceIdString + tracker1BaseName + "/Rotation", tracker1Rot));
                }
                if ((curTracker == 1) || (initialPoll)) {
                    eventQueue.Add(new VREventVector3(m_DeviceIdString + tracker2BaseName + "/Position", tracker2Pos));
                    eventQueue.Add(new VREventQuaternion(m_DeviceIdString + tracker2BaseName + "/Rotation", tracker2Rot));
                }
            }

            this.lastx = x;
            this.lasty = y;
        }

        public List<IVREventPrototype> GetEventPrototypes()
        {
            List<IVREventPrototype> allEvents = new List<IVREventPrototype>();
            allEvents.Add(VREventPrototypeVector3.Create(m_DeviceIdString + headTrackerBaseName + "/Position"));
            allEvents.Add(VREventPrototypeQuaternion.Create(m_DeviceIdString + headTrackerBaseName + "/Rotation"));

            allEvents.Add(VREventPrototypeVector3.Create(m_DeviceIdString + leftEyeTrackerBaseName + "/Position"));
            allEvents.Add(VREventPrototypeVector3.Create(m_DeviceIdString + rightEyeTrackerBaseName + "/Position"));

            allEvents.Add(VREventPrototypeVector3.Create(m_DeviceIdString + tracker1BaseName + "/Position"));
            allEvents.Add(VREventPrototypeQuaternion.Create(m_DeviceIdString + tracker1BaseName + "/Rotation"));

            allEvents.Add(VREventPrototypeVector3.Create(m_DeviceIdString + tracker2BaseName + "/Position"));
            allEvents.Add(VREventPrototypeQuaternion.Create(m_DeviceIdString + tracker2BaseName + "/Rotation"));

            return allEvents;
        }


    }

} // namespace
