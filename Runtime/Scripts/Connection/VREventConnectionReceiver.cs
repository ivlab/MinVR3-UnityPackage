using System.Reflection;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

namespace IVLab.MinVR3
{
    /// <summary>
    /// MonoBehaviour that receives events sent over a VREventConnection and places them in the VR Event Manager's
    /// Queue.  There are two common uses for this class:
    ///
    /// 1. To implement a virtual input device with data sent over a network connection.  This class can receive
    /// events generated by some other app, even a webpage, and insert the events received into the VREventManager's
    /// queue, just as if the events were generated from a local input device.  In this case, this component will
    /// probably be the only place in your scene where such events would be "produced", so it is important for the
    /// class to specify a VREventPrototype for each event it expects to receive.
    ///
    /// 2. For sharing event data between multiple MinVR applications and when the strict, frame-level synchronization
    /// of events and rendering provided by MinVR's cluster mode is not required.  While cluster-mode works well for
    /// tiled dispalys powered by a cluster of identical machines, this class is useful for synchronizing event data
    /// across heterogeneous devices used together by a single user (e.g., an AR headset used together with a multi-
    /// touch tablet) or in multi-user situations (e.g., multiple users each wearning their own HMD).  In these
    /// sitautions, the connection may just be responsible for sending/receiving events that are already defined
    /// with VREventPrototypes elsewhere in the scene.  If that is the case, it it not necessary (but also does not
    /// hurt) to redefine the prototypes within this cass.  See also <seealso cref="VREventConnectionSender"/>.
    /// (formerly ConnectionVREventProducer)
    /// </summary>
    [RequireComponent(typeof(IVREventConnection))]
    [ExecuteInEditMode]
    public class VREventConnectionReceiver : MonoBehaviour, IVREventProducer
    {
        [SerializeField, Tooltip("Events will be received over this connection.")]
        private IVREventConnection connection;

        
        public List<VREventPrototypeAny> eventPrototypes {
            get { return m_EventPrototypes; }
            set { m_EventPrototypes = value; }
        }

        [Tooltip("In general, you should add a prototype to this list for each event you expect to receive over " +
            "the connection.  However, you can safely skip this step IF an identical prototype is already defined " +
            "by some other event producer in the scene.")]
        [SerializeField] private List<VREventPrototypeAny> m_EventPrototypes;


        void Reset()
        {
            m_EventPrototypes = null;
        }

        void Start()
        {
            connection = this.GetComponent<IVREventConnection>();
            connection.OnVREventReceived += VREventHandler;
        }

        public List<IVREventPrototype> GetEventPrototypes()
        {
            List<IVREventPrototype> eventsProduced = new List<IVREventPrototype>();
            foreach (var p in m_EventPrototypes) {
                eventsProduced.Add(p);
            }
            return eventsProduced;
        }

        private void VREventHandler(VREvent evt)
        {
            VREngine.Instance.eventManager.QueueEvent(evt);
        }


        void SetEditorModeForEventPrototypes()
        {
            if (m_EventPrototypes != null) {
                foreach (var ep in m_EventPrototypes) {
                    // VREventPrototypeAny supports two different editor modes.  Usually, we want to provide
                    // a dropdown list in the editor so programmers can select an event prototype from a
                    // list of known prototypes provided by the event manager.  This is the other case.  In
                    // a virtual input device like this, we want the editor interface to make it possible
                    // for us to define a new name and type for an event.
                    ep.SetDefineNewPrototypeInEditor(true);
                }
            }
        }

        void OnValidate()
        {
            SetEditorModeForEventPrototypes();
        }

    }
}
