{
  "api/IVLab.MinVR3.BasicHighlighter.html": {
    "href": "api/IVLab.MinVR3.BasicHighlighter.html",
    "title": "Class BasicHighlighter | MinVR3",
    "keywords": "Class BasicHighlighter Inheritance object Object Component Behaviour MonoBehaviour BasicHighlighter Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Selection/Basic Highlighter\")] public class BasicHighlighter : MonoBehaviour, IVREventListener Fields | Improve this Doc View Source m_HighlightMaterial Declaration public Material m_HighlightMaterial Field Value Type Description Material | Improve this Doc View Source m_SelectEvent Declaration public VREventPrototypeGameObject m_SelectEvent Field Value Type Description VREventPrototypeGameObject | Improve this Doc View Source m_UnselectEvent Declaration public VREventPrototypeGameObject m_UnselectEvent Field Value Type Description VREventPrototypeGameObject Methods | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.BasicObjectSelector.SelectionMode.html": {
    "href": "api/IVLab.MinVR3.BasicObjectSelector.SelectionMode.html",
    "title": "Enum BasicObjectSelector.SelectionMode | MinVR3",
    "keywords": "Enum BasicObjectSelector.SelectionMode Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum BasicObjectSelector.SelectionMode Fields Name Description PointAt Touch"
  },
  "api/IVLab.MinVR3.BasicObjectSelector.html": {
    "href": "api/IVLab.MinVR3.BasicObjectSelector.html",
    "title": "Class BasicObjectSelector | MinVR3",
    "keywords": "Class BasicObjectSelector Inheritance object Object Component Behaviour MonoBehaviour BasicObjectSelector BimanualObjectSelector Implements IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Selection/Basic Object Selector\")] public class BasicObjectSelector : MonoBehaviour, IVREventProducer Fields | Improve this Doc View Source m_CursorTransform Declaration [Header(\"Cursor\")] [Tooltip(\"The transform for the cursor used to make selections. Position is used for touch mode. Position and rotation are used for point mode.\")] [SerializeField] protected Transform m_CursorTransform Field Value Type Description Transform | Improve this Doc View Source m_IgnoreMask Declaration [Tooltip(\"Objects in these layers will NOT be selected.\")] [SerializeField] protected LayerMask m_IgnoreMask Field Value Type Description LayerMask | Improve this Doc View Source m_PointerDistance Declaration [Tooltip(\"Distance for the raycast used in the pointat mode.\")] [SerializeField] protected float m_PointerDistance Field Value Type Description float | Improve this Doc View Source m_Selected Declaration protected Collider m_Selected Field Value Type Description Collider | Improve this Doc View Source m_SelectionMode Declaration [Tooltip(\"Point mode uses the transform's position and forward direction to create a laser pointer. Touch mode uses the transform's position and a small radius to create an sphere collider.\")] [SerializeField] protected BasicObjectSelector.SelectionMode m_SelectionMode Field Value Type Description BasicObjectSelector.SelectionMode | Improve this Doc View Source m_TouchRadius Declaration [Tooltip(\"Radius for the sphere collider used in touch mode, can be zero in which case the cursor origin must lie totally inside the collider.\")] [SerializeField] protected float m_TouchRadius Field Value Type Description float Properties | Improve this Doc View Source CursorTransform Declaration public Transform CursorTransform { get; set; } Property Value Type Description Transform Methods | Improve this Doc View Source CheckSelection(Transform, SelectionMode, LayerMask, float, float) Declaration protected Collider CheckSelection(Transform cursorTransform, BasicObjectSelector.SelectionMode selectionMode, LayerMask ignoreMask, float touchRadius, float pointerDistance) Parameters Type Name Description Transform cursorTransform BasicObjectSelector.SelectionMode selectionMode LayerMask ignoreMask float touchRadius float pointerDistance Returns Type Description Collider | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source Reset() Declaration public virtual void Reset() | Improve this Doc View Source TryChangeSelection(Collider) Declaration protected bool TryChangeSelection(Collider nowSelected) Parameters Type Name Description Collider nowSelected Returns Type Description bool | Improve this Doc View Source Update() Declaration public virtual void Update() Implements IVREventProducer"
  },
  "api/IVLab.MinVR3.BimanualObjectManipulator.html": {
    "href": "api/IVLab.MinVR3.BimanualObjectManipulator.html",
    "title": "Class BimanualObjectManipulator | MinVR3",
    "keywords": "Class BimanualObjectManipulator This class implements yet another technique for bimanual object manipulation. This implementation is based off the 6DOF technique described in the paper Mid-Air Interactions Above Stereoscopic Interactive Tables (Mendes / Fonesca / Araujo 2014), but similar techniques exist prior to that paper as well. Inheritance object Object Component Behaviour MonoBehaviour BimanualObjectManipulator Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Navigation & Manipulation/Bimanual Object Manipulator\")] public class BimanualObjectManipulator : MonoBehaviour"
  },
  "api/IVLab.MinVR3.BimanualObjectSelector.html": {
    "href": "api/IVLab.MinVR3.BimanualObjectSelector.html",
    "title": "Class BimanualObjectSelector | MinVR3",
    "keywords": "Class BimanualObjectSelector Inheritance object Object Component Behaviour MonoBehaviour BasicObjectSelector BimanualObjectSelector Implements IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Selection/Bimanual Object Selector\")] public class BimanualObjectSelector : BasicObjectSelector, IVREventProducer Properties | Improve this Doc View Source CursorTransform2 Declaration public Transform CursorTransform2 { get; set; } Property Value Type Description Transform Methods | Improve this Doc View Source Reset() Declaration public override void Reset() Overrides BasicObjectSelector.Reset() | Improve this Doc View Source Update() Declaration public override void Update() Overrides BasicObjectSelector.Update() Implements IVREventProducer"
  },
  "api/IVLab.MinVR3.BoundsHighlighter.html": {
    "href": "api/IVLab.MinVR3.BoundsHighlighter.html",
    "title": "Class BoundsHighlighter | MinVR3",
    "keywords": "Class BoundsHighlighter Inheritance object Object Component Behaviour MonoBehaviour BoundsHighlighter Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Selection/Bounds Highlighter\")] public class BoundsHighlighter : MonoBehaviour, IVREventListener Fields | Improve this Doc View Source boundsLineWidth Declaration public float boundsLineWidth Field Value Type Description float | Improve this Doc View Source highlightColor Declaration public Color highlightColor Field Value Type Description Color | Improve this Doc View Source m_SelectEvent Declaration public VREventPrototypeGameObject m_SelectEvent Field Value Type Description VREventPrototypeGameObject | Improve this Doc View Source m_UnselectEvent Declaration public VREventPrototypeGameObject m_UnselectEvent Field Value Type Description VREventPrototypeGameObject Methods | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.CallableEventProducer.html": {
    "href": "api/IVLab.MinVR3.CallableEventProducer.html",
    "title": "Class CallableEventProducer | MinVR3",
    "keywords": "Class CallableEventProducer Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Inheritance object Object Component Behaviour MonoBehaviour CallableEventProducer Implements IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class CallableEventProducer : MonoBehaviour, IVREventProducer Properties | Improve this Doc View Source eventPrototypes Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public List<VREventPrototypeAny> eventPrototypes { get; set; } Property Value Type Description List<VREventPrototypeAny> Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source GetPrototypeByNameAndType(string, string) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public VREventPrototypeAny GetPrototypeByNameAndType(string eventName, string eventDataTypeName) Parameters Type Name Description string eventName string eventDataTypeName Returns Type Description VREventPrototypeAny | Improve this Doc View Source ProduceVREvent(string) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName) Parameters Type Name Description string eventName | Improve this Doc View Source ProduceVREvent(string, int) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName, int eventData) Parameters Type Name Description string eventName int eventData | Improve this Doc View Source ProduceVREvent(string, float) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName, float eventData) Parameters Type Name Description string eventName float eventData | Improve this Doc View Source ProduceVREvent(string, string) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName, string eventData) Parameters Type Name Description string eventName string eventData | Improve this Doc View Source ProduceVREvent(string, GameObject) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName, GameObject eventData) Parameters Type Name Description string eventName GameObject eventData | Improve this Doc View Source ProduceVREvent(string, Quaternion) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName, Quaternion eventData) Parameters Type Name Description string eventName Quaternion eventData | Improve this Doc View Source ProduceVREvent(string, Vector2) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName, Vector2 eventData) Parameters Type Name Description string eventName Vector2 eventData | Improve this Doc View Source ProduceVREvent(string, Vector3) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName, Vector3 eventData) Parameters Type Name Description string eventName Vector3 eventData | Improve this Doc View Source ProduceVREvent(string, Vector4) Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). Declaration public void ProduceVREvent(string eventName, Vector4 eventData) Parameters Type Name Description string eventName Vector4 eventData Implements IVREventProducer"
  },
  "api/IVLab.MinVR3.CavePaintingBrushCursor.html": {
    "href": "api/IVLab.MinVR3.CavePaintingBrushCursor.html",
    "title": "Class CavePaintingBrushCursor | MinVR3",
    "keywords": "Class CavePaintingBrushCursor Creates a mesh for the 3D Brush cursor used in the original CavePainting, 2001 paper. Inheritance object Object Component Behaviour MonoBehaviour CavePaintingBrushCursor Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [ExecuteAlways] [RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))] [AddComponentMenu(\"MinVR Interaction/Cursors/CavePainting Brush\")] public class CavePaintingBrushCursor : MonoBehaviour Fields | Improve this Doc View Source indices Creates a mesh for the 3D Brush cursor used in the original CavePainting, 2001 paper. Declaration public int[] indices Field Value Type Description int[] | Improve this Doc View Source origIndices Creates a mesh for the 3D Brush cursor used in the original CavePainting, 2001 paper. Declaration public static int[] origIndices Field Value Type Description int[] | Improve this Doc View Source origVertices Creates a mesh for the 3D Brush cursor used in the original CavePainting, 2001 paper. Declaration public static Vector3[] origVertices Field Value Type Description Vector3[] | Improve this Doc View Source vertices Creates a mesh for the 3D Brush cursor used in the original CavePainting, 2001 paper. Declaration public Vector3[] vertices Field Value Type Description Vector3[]"
  },
  "api/IVLab.MinVR3.ClusterClient.html": {
    "href": "api/IVLab.MinVR3.ClusterClient.html",
    "title": "Class ClusterClient | MinVR3",
    "keywords": "Class ClusterClient Inheritance object Object Component Behaviour MonoBehaviour ClusterClient Implements IClusterNode Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Cluster/ClusterClient\")] [DisallowMultipleComponent] public class ClusterClient : MonoBehaviour, IClusterNode Fields | Improve this Doc View Source serverIPAddress Declaration [Tooltip(\"The ip address of the server to connect to.\")] public string serverIPAddress Field Value Type Description string | Improve this Doc View Source serverPort Declaration [Tooltip(\"The port the server is running on.\")] public int serverPort Field Value Type Description int Methods | Improve this Doc View Source Initialize() Declaration public void Initialize() | Improve this Doc View Source Shutdown() Declaration public void Shutdown() | Improve this Doc View Source SynchronizeInputEventsAcrossAllNodes(ref List<VREvent>) Declaration public void SynchronizeInputEventsAcrossAllNodes(ref List<VREvent> inputEvents) Parameters Type Name Description List<VREvent> inputEvents | Improve this Doc View Source SynchronizeSwapBuffersAcrossAllNodes() Declaration public void SynchronizeSwapBuffersAcrossAllNodes() Implements IClusterNode"
  },
  "api/IVLab.MinVR3.ClusterServer.html": {
    "href": "api/IVLab.MinVR3.ClusterServer.html",
    "title": "Class ClusterServer | MinVR3",
    "keywords": "Class ClusterServer Inheritance object Object Component Behaviour MonoBehaviour ClusterServer Implements IClusterNode Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Cluster/ClusterServer\")] [DisallowMultipleComponent] public class ClusterServer : MonoBehaviour, IClusterNode Fields | Improve this Doc View Source numClients Declaration [Tooltip(\"The number of clients that should connect to the server.\")] public int numClients Field Value Type Description int | Improve this Doc View Source serverPort Declaration [Tooltip(\"The port the server should run on.\")] public int serverPort Field Value Type Description int Methods | Improve this Doc View Source Initialize() Declaration public void Initialize() | Improve this Doc View Source Shutdown() Declaration public void Shutdown() | Improve this Doc View Source SynchronizeInputEventsAcrossAllNodes(ref List<VREvent>) Declaration public void SynchronizeInputEventsAcrossAllNodes(ref List<VREvent> inputEvents) Parameters Type Name Description List<VREvent> inputEvents | Improve this Doc View Source SynchronizeSwapBuffersAcrossAllNodes() Declaration public void SynchronizeSwapBuffersAcrossAllNodes() Implements IClusterNode"
  },
  "api/IVLab.MinVR3.ColorPicker.html": {
    "href": "api/IVLab.MinVR3.ColorPicker.html",
    "title": "Class ColorPicker | MinVR3",
    "keywords": "Class ColorPicker Inheritance object Object Component Behaviour MonoBehaviour ColorPicker Implements IVREventListener IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Widgets/Color Picker (CavePainting Style)\")] public class ColorPicker : MonoBehaviour, IVREventListener, IVREventProducer Properties | Improve this Doc View Source initialColor Declaration public Color initialColor { get; set; } Property Value Type Description Color Methods | Improve this Doc View Source ColorToPoint(Color) Declaration public Vector3 ColorToPoint(Color c) Parameters Type Name Description Color c Returns Type Description Vector3 | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source PointToColor(Vector3) Declaration public Color PointToColor(Vector3 p) Parameters Type Name Description Vector3 p Returns Type Description Color | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener IVREventProducer"
  },
  "api/IVLab.MinVR3.Condition.html": {
    "href": "api/IVLab.MinVR3.Condition.html",
    "title": "Class Condition | MinVR3",
    "keywords": "Class Condition Conditions can be used to programmatically restrict the FSM's ability to transition along an arc unless some condition is met. Subclass from this class and implement the condition inside this abstract function. Then, attach your new class to the desired arc(s). Then, the arc will only be traversed when it is triggered AND the condition is true. Note that if you want a simple arc guard that does not depend on any custom code this might be better implmented using the SharedToken scriptable object, which is useful, for example, to coordinate between FSMs to determine which should have focus. Inheritance object Object Component Behaviour MonoBehaviour Condition Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Building Blocks/Condition\")] public class Condition : MonoBehaviour Properties | Improve this Doc View Source isTrue Conditions can be used to programmatically restrict the FSM's ability to transition along an arc unless some condition is met. Subclass from this class and implement the condition inside this abstract function. Then, attach your new class to the desired arc(s). Then, the arc will only be traversed when it is triggered AND the condition is true. Note that if you want a simple arc guard that does not depend on any custom code this might be better implmented using the SharedToken scriptable object, which is useful, for example, to coordinate between FSMs to determine which should have focus. Declaration public bool isTrue { get; set; } Property Value Type Description bool"
  },
  "api/IVLab.MinVR3.ConfigVal.html": {
    "href": "api/IVLab.MinVR3.ConfigVal.html",
    "title": "Class ConfigVal | MinVR3",
    "keywords": "Class ConfigVal A static class that provides easy, read-only assess to configuration settings loaded from config files. File Naming and Attaching to Unity Game Objects Config Files should be included in your Unity project as text file assets. This requires them to have a .txt extension. Our naming convention is configname.minvr.txt. Where \"configname\" is replaced with \"common\" for files that are attached to VREngine, since these are common to all VRConfigs, and the name of the VRConfig for files that are attached to a specific VRConfig. Config File Format The basic form of a MinVR3 config file is a list of Key = Value pairs, with one entry per line. Beyond this, there are a few extra features: Lines that begin with the # symbol are ignored as comments. A \\ symbol at the end of the line, means the value is continued on the next line. If the value should actually include a , use \\ instead. Values for Vector, Matrix, and other array types should be separated by commas. An example config file looks like this: # MinVR3 Example Config File (common.minvr.txt) MY_INT = 2 MY_FLOAT = 13.0 # Booleans can use true/false or True/False MY_BOOLEAN = False # Strings that are not quoted will have any leading or trailing whitespace removed MY_STRING = Hello my MinVR friends # Strings that are quoted can include whitespace and escaped quotes MY_QUOTED_STRING = \" Hello my \\\"MinVR friends\\\" \" # Values for Vector, Quaternion, and Matrix types must be separated by commas. Optionally, # the values can be enclosed in (), <>, or [] brackets. MY_VECTOR2 = (4.0, 4.0) MY_VECTOR3 = (5.0, 5.0, 5.0) MY_VECTOR4 = (6.0, 6.0, 6.0, 6.0) MY_QUATERNION = (0.0, 0.0, 0.0, 1.0) # Matrix types should list elements in ROW MAJOR order so that the matrix \"looks\" correct when # typed into the config file on four lines as shown below. For a 4x4 homogeneous transformation # matrix, the last row should always be 0.0, 0.0, 0.0, 1.0, the right column contains the # translation, and the upper-left 3x3 contains the rotation and scale. Note the use of \\ at the # end of each line. This is needed to tell the parser that the value continues on the next line. MY_MATRIX4X4 = \\ (1.0, 0.0, 0.0, 2.0, \\ 0.0, 1.0, 0.0, 3.0, \\ 0.0, 0.0, 1.0, 4.0, \\ 0.0, 0.0, 0.0, 1.0) # A generic int array of any length MY_INT_ARRAY = 5, 4, 3, 2, 1 # A generic float array of any length MY_FLOAT_ARRAY = 0.0, 1.0, 2.0, 3.0, 4.0, 5.0 # An array of strings MY_STRING_ARRAY = \"One\", \"Two Three\", \"Four Five Six\", \"a b c d \\\"e\\\" f\", \"done\" After the config file is parsed, the values specified in the example config file above can be accessed from within a script like this: bool b = ConfigVal.Get(\"MY_BOOLEAN\", true); Debug.Log(b); int i = ConfigVal.Get(\"MY_INT\", 2); Debug.Log(i); float f = ConfigVal.Get(\"MY_FLOAT\", 1.0f); Debug.Log(f); string s1 = ConfigVal.Get(\"MY_STRING\", \"\"); Debug.Log(s1); string s2 = ConfigVal.Get(\"MY_QUOTED_STRING\", \"\"); Debug.Log(s2); Vector2 v2 = ConfigVal.Get(\"MY_VECTOR2\", Vector2.zero); Debug.Log(v2); Vector3 v3 = ConfigVal.Get(\"MY_VECTOR3\", Vector3.zero); Debug.Log(v3); Vector4 v4 = ConfigVal.Get(\"MY_VECTOR4\", Vector4.zero); Debug.Log(v4); Quaternion q = ConfigVal.Get(\"MY_QUATERNION\", Quaternion.identity); Debug.Log(q); Matrix4x4 m4 = ConfigVal.Get(\"MY_MATRIX4X4\", Matrix4x4.identity); Debug.Log(m4); int[] intArray = new int[0]; intArray = ConfigVal.Get(\"MY_INT_ARRAY\", intArray); string iStr = \"\"; foreach (int i in intArray) { iStr += i.ToString() + \", \"; } Debug.Log(iStr); float[] floatArray = new float[0]; floatArray = ConfigVal.Get(\"MY_FLOAT_ARRAY\", floatArray); string fStr = \"\"; foreach (float f in floatArray) { fStr += f.ToString() + \", \"; } Debug.Log(fStr); string[] strArray = new string[0]; strArray = ConfigVal.Get(\"MY_STRING_ARRAY\", strArray); foreach (string s in strArray) { Debug.Log(s); } Note that the values are stored internally as strings. They are not interpreted as a specific type until they are accessed with a call to ConfigVal.Get() and the Get() method tries to convert the string to the requested type. To avoid re-converting each frame, consider accessing ConfigVals from within Start() or Awake() and then saving the result in a member variable within your class. Inheritance object ConfigVal Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class ConfigVal Methods | Improve this Doc View Source Get(string, int[], bool) int[] intArray = new int[0]; intArray = ConfigVal.Get(\"MY_INT_ARRAY\", intArray); string iStr = \"\"; foreach (int i in intArray) { iStr += i.ToString() + \", \"; } Debug.Log(iStr); Declaration public static int[] Get(string key, int[] defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key int[] defaultValue bool warnOnMissing Returns Type Description int[] | Improve this Doc View Source Get(string, float[], bool) float[] floatArray = new float[0]; floatArray = ConfigVal.Get(\"MY_FLOAT_ARRAY\", floatArray); string fStr = \"\"; foreach (float f in floatArray) { fStr += f.ToString() + \", \"; } Debug.Log(fStr); Declaration public static float[] Get(string key, float[] defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key float[] defaultValue bool warnOnMissing Returns Type Description float[] | Improve this Doc View Source Get(string, string, bool) String values can be contained in double quotes or not. If quotes are used, the value returned from Get will be the characters inside the quotes. If you want this value to include an actual quote character, then escape it with a backslach (e.g., \"). If quotes are not used, then the value of the string will start with the first non-whitespace character after the equals sign and end with the last non-whitespace character on the line. Declaration public static string Get(string key, string defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key string defaultValue bool warnOnMissing Returns Type Description string | Improve this Doc View Source Get(string, string[], bool) When defining a string array in a config file, the individual entries within the array must be contained in double quotes and be separated by commas. For example: MY_STRING_ARRAY = \"One\", \"Two Three\", \"Four Five Six\", \"a b c d \\\"e\\\" f\", \"done\" This array could be read inside a script with code like this: string[] strArray = new string[0]; strArray = ConfigVal.Get(\"MY_STRING_ARRAY\", strArray); foreach (string s in strArray) { Debug.Log(s); } Declaration public static string[] Get(string key, string[] defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key string[] defaultValue bool warnOnMissing Returns Type Description string[] | Improve this Doc View Source Get(string, Matrix4x4, bool) Matrix4x4 m4 = ConfigVal.Get(\"MY_MATRIX4X4\", Matrix4x4.identity); Debug.Log(m4); Declaration public static Matrix4x4 Get(string key, Matrix4x4 defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key Matrix4x4 defaultValue bool warnOnMissing Returns Type Description Matrix4x4 | Improve this Doc View Source Get(string, Quaternion, bool) Quaternion q = ConfigVal.Get(\"MY_QUATERNION\", Quaternion.identity); Debug.Log(q); Declaration public static Quaternion Get(string key, Quaternion defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key Quaternion defaultValue bool warnOnMissing Returns Type Description Quaternion | Improve this Doc View Source Get(string, Vector2, bool) Vector2 v2 = ConfigVal.Get(\"MY_VECTOR2\", Vector2.zero); Debug.Log(v2); Declaration public static Vector2 Get(string key, Vector2 defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key Vector2 defaultValue bool warnOnMissing Returns Type Description Vector2 | Improve this Doc View Source Get(string, Vector3, bool) /// ``` Vector3 v3 = ConfigVal.Get(\"MY_VECTOR3\", Vector3.zero); Debug.Log(v3); Declaration public static Vector3 Get(string key, Vector3 defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key Vector3 defaultValue bool warnOnMissing Returns Type Description Vector3 | Improve this Doc View Source Get(string, Vector4, bool) Vector4 v4 = ConfigVal.Get(\"MY_VECTOR4\", Vector4.zero); Debug.Log(v4); Declaration public static Vector4 Get(string key, Vector4 defaultValue, bool warnOnMissing = true) Parameters Type Name Description string key Vector4 defaultValue bool warnOnMissing Returns Type Description Vector4 | Improve this Doc View Source Get<T>(string, T, bool) This template method works for accessing ConfigVals as any type that implements IConvertible. This includes bool, int, float, etc. The type can typically be inferred from the type of the default value, so even though this is a template method, you can call it without using angle brackets, like so: bool b = ConfigVal.Get(\"MY_BOOLEAN\", true); Debug.Log(b); int i = ConfigVal.Get(\"MY_INT\", 2); Debug.Log(i); float f = ConfigVal.Get(\"MY_FLOAT\", 1.0f); Debug.Log(f); Declaration public static T Get<T>(string key, T defaultValue, bool warnOnMissing = true) where T : IConvertible Parameters Type Name Description string key The ConfigVal's key (lookup) name. T defaultValue Value to return if the key is not found in the map or there is a problem converting the value found in the map to the type of defaultValue. bool warnOnMissing Logs a warning if the key is not found in the map. Returns Type Description T The value found in the map under 'key' converted to be the same type as defaultValue. Type Parameters Name Description T | Improve this Doc View Source ParseConfigFile(TextAsset) A static class that provides easy, read-only assess to configuration settings loaded from config files. File Naming and Attaching to Unity Game Objects Config Files should be included in your Unity project as text file assets. This requires them to have a .txt extension. Our naming convention is configname.minvr.txt. Where \"configname\" is replaced with \"common\" for files that are attached to VREngine, since these are common to all VRConfigs, and the name of the VRConfig for files that are attached to a specific VRConfig. Config File Format The basic form of a MinVR3 config file is a list of Key = Value pairs, with one entry per line. Beyond this, there are a few extra features: Lines that begin with the # symbol are ignored as comments. A \\ symbol at the end of the line, means the value is continued on the next line. If the value should actually include a , use \\ instead. Values for Vector, Matrix, and other array types should be separated by commas. An example config file looks like this: # MinVR3 Example Config File (common.minvr.txt) MY_INT = 2 MY_FLOAT = 13.0 # Booleans can use true/false or True/False MY_BOOLEAN = False # Strings that are not quoted will have any leading or trailing whitespace removed MY_STRING = Hello my MinVR friends # Strings that are quoted can include whitespace and escaped quotes MY_QUOTED_STRING = \" Hello my \\\"MinVR friends\\\" \" # Values for Vector, Quaternion, and Matrix types must be separated by commas. Optionally, # the values can be enclosed in (), <>, or [] brackets. MY_VECTOR2 = (4.0, 4.0) MY_VECTOR3 = (5.0, 5.0, 5.0) MY_VECTOR4 = (6.0, 6.0, 6.0, 6.0) MY_QUATERNION = (0.0, 0.0, 0.0, 1.0) # Matrix types should list elements in ROW MAJOR order so that the matrix \"looks\" correct when # typed into the config file on four lines as shown below. For a 4x4 homogeneous transformation # matrix, the last row should always be 0.0, 0.0, 0.0, 1.0, the right column contains the # translation, and the upper-left 3x3 contains the rotation and scale. Note the use of \\ at the # end of each line. This is needed to tell the parser that the value continues on the next line. MY_MATRIX4X4 = \\ (1.0, 0.0, 0.0, 2.0, \\ 0.0, 1.0, 0.0, 3.0, \\ 0.0, 0.0, 1.0, 4.0, \\ 0.0, 0.0, 0.0, 1.0) # A generic int array of any length MY_INT_ARRAY = 5, 4, 3, 2, 1 # A generic float array of any length MY_FLOAT_ARRAY = 0.0, 1.0, 2.0, 3.0, 4.0, 5.0 # An array of strings MY_STRING_ARRAY = \"One\", \"Two Three\", \"Four Five Six\", \"a b c d \\\"e\\\" f\", \"done\" After the config file is parsed, the values specified in the example config file above can be accessed from within a script like this: bool b = ConfigVal.Get(\"MY_BOOLEAN\", true); Debug.Log(b); int i = ConfigVal.Get(\"MY_INT\", 2); Debug.Log(i); float f = ConfigVal.Get(\"MY_FLOAT\", 1.0f); Debug.Log(f); string s1 = ConfigVal.Get(\"MY_STRING\", \"\"); Debug.Log(s1); string s2 = ConfigVal.Get(\"MY_QUOTED_STRING\", \"\"); Debug.Log(s2); Vector2 v2 = ConfigVal.Get(\"MY_VECTOR2\", Vector2.zero); Debug.Log(v2); Vector3 v3 = ConfigVal.Get(\"MY_VECTOR3\", Vector3.zero); Debug.Log(v3); Vector4 v4 = ConfigVal.Get(\"MY_VECTOR4\", Vector4.zero); Debug.Log(v4); Quaternion q = ConfigVal.Get(\"MY_QUATERNION\", Quaternion.identity); Debug.Log(q); Matrix4x4 m4 = ConfigVal.Get(\"MY_MATRIX4X4\", Matrix4x4.identity); Debug.Log(m4); int[] intArray = new int[0]; intArray = ConfigVal.Get(\"MY_INT_ARRAY\", intArray); string iStr = \"\"; foreach (int i in intArray) { iStr += i.ToString() + \", \"; } Debug.Log(iStr); float[] floatArray = new float[0]; floatArray = ConfigVal.Get(\"MY_FLOAT_ARRAY\", floatArray); string fStr = \"\"; foreach (float f in floatArray) { fStr += f.ToString() + \", \"; } Debug.Log(fStr); string[] strArray = new string[0]; strArray = ConfigVal.Get(\"MY_STRING_ARRAY\", strArray); foreach (string s in strArray) { Debug.Log(s); } Note that the values are stored internally as strings. They are not interpreted as a specific type until they are accessed with a call to ConfigVal.Get() and the Get() method tries to convert the string to the requested type. To avoid re-converting each frame, consider accessing ConfigVals from within Start() or Awake() and then saving the result in a member variable within your class. Declaration public static void ParseConfigFile(TextAsset textAsset) Parameters Type Name Description TextAsset textAsset"
  },
  "api/IVLab.MinVR3.CoordConversion.CoordSystem.Axis.html": {
    "href": "api/IVLab.MinVR3.CoordConversion.CoordSystem.Axis.html",
    "title": "Enum CoordConversion.CoordSystem.Axis | MinVR3",
    "keywords": "Enum CoordConversion.CoordSystem.Axis Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum CoordConversion.CoordSystem.Axis Fields Name Description NegX NegY NegZ PosX PosY PosZ"
  },
  "api/IVLab.MinVR3.CoordConversion.CoordSystem.Handedness.html": {
    "href": "api/IVLab.MinVR3.CoordConversion.CoordSystem.Handedness.html",
    "title": "Enum CoordConversion.CoordSystem.Handedness | MinVR3",
    "keywords": "Enum CoordConversion.CoordSystem.Handedness Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum CoordConversion.CoordSystem.Handedness Fields Name Description LeftHanded RightHanded"
  },
  "api/IVLab.MinVR3.CoordConversion.CoordSystem.html": {
    "href": "api/IVLab.MinVR3.CoordConversion.CoordSystem.html",
    "title": "Class CoordConversion.CoordSystem | MinVR3",
    "keywords": "Class CoordConversion.CoordSystem This small internal class defines a coordinate system convention based on knowing 3 things: Whether right-handed or left-handed coordinates are used. Which direction is considered \"Up\" Which direction is considered \"Forward\" Inheritance object CoordConversion.CoordSystem Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class CoordConversion.CoordSystem Constructors | Improve this Doc View Source CoordSystem(Handedness, Axis, Axis) This small internal class defines a coordinate system convention based on knowing 3 things: Whether right-handed or left-handed coordinates are used. Which direction is considered \"Up\" Which direction is considered \"Forward\" Declaration public CoordSystem(CoordConversion.CoordSystem.Handedness h, CoordConversion.CoordSystem.Axis up, CoordConversion.CoordSystem.Axis forward) Parameters Type Name Description CoordConversion.CoordSystem.Handedness h CoordConversion.CoordSystem.Axis up CoordConversion.CoordSystem.Axis forward Fields | Improve this Doc View Source forwardAxis This small internal class defines a coordinate system convention based on knowing 3 things: Whether right-handed or left-handed coordinates are used. Which direction is considered \"Up\" Which direction is considered \"Forward\" Declaration public CoordConversion.CoordSystem.Axis forwardAxis Field Value Type Description CoordConversion.CoordSystem.Axis | Improve this Doc View Source handedness This small internal class defines a coordinate system convention based on knowing 3 things: Whether right-handed or left-handed coordinates are used. Which direction is considered \"Up\" Which direction is considered \"Forward\" Declaration public CoordConversion.CoordSystem.Handedness handedness Field Value Type Description CoordConversion.CoordSystem.Handedness | Improve this Doc View Source upAxis This small internal class defines a coordinate system convention based on knowing 3 things: Whether right-handed or left-handed coordinates are used. Which direction is considered \"Up\" Which direction is considered \"Forward\" Declaration public CoordConversion.CoordSystem.Axis upAxis Field Value Type Description CoordConversion.CoordSystem.Axis Properties | Improve this Doc View Source forwardVector This small internal class defines a coordinate system convention based on knowing 3 things: Whether right-handed or left-handed coordinates are used. Which direction is considered \"Up\" Which direction is considered \"Forward\" Declaration public Vector3 forwardVector { get; } Property Value Type Description Vector3 | Improve this Doc View Source upVector This small internal class defines a coordinate system convention based on knowing 3 things: Whether right-handed or left-handed coordinates are used. Which direction is considered \"Up\" Which direction is considered \"Forward\" Declaration public Vector3 upVector { get; } Property Value Type Description Vector3"
  },
  "api/IVLab.MinVR3.CoordConversion.html": {
    "href": "api/IVLab.MinVR3.CoordConversion.html",
    "title": "Class CoordConversion | MinVR3",
    "keywords": "Class CoordConversion This class includes useful routines for converting between 3D coordinate systems that follow different conventions for handedness and up/forward directions. Brief background on Left-Handed vs. Right Handed Coordinates Many (most?) scientific datasets and modeling programs these days use right-handed coordinates but that is just a convention. Mathematically speaking, it is just as reasonable to use left- handed coordinates, as Unity has done and several other major graphics packages have done in the past. Luckily, you can convert between LH and RH coordinates. The conversion itself is not too hard. The hard part is that there are several valid ways to do the conversion so you need to know which conventions are used and stay consistent. This class is intended to help with this by organizing all of the conversion routines here in one place. Converting LH to RH: The big question is, which axis to negate? Converting between LH and RH coordinate systems requires negating one axis. However, the choice of which axis to negate is arbitrary. When Unity does these conversions automatically, like when you drag and drop a model file into your Unity project, it seems to have adopted the convention of negating the X axis (i.e., vertices with positive x values will have negative x values after importing). So, in this class, we intentionally follow the same convention of negating X. If you look for more info online, you will find examples that do the conversion by negating Y or Z. All of these are completely valid, it's just a convention, and we'll try to be as consistent with Unity as possible by doing the same thing and negating x. Converting between +Y=Up, +Z=Up, and other variations In addition to deciding to use a left or right-handed system, datasets and graphics toolkits often also adopt a second convention about which axis points \"Up\", which points \"Forward\", etc. This really has nothing to do with RH vs. LH decision. You could decide to use left-handed with +Y=Up or right-handed with +Y=Up or right-handed with +Z=Up or something else. However, once you pick two directions (say, Up and Forward), the third axis must follow either the right -hand rule or left-hand rule based on whether you are using right or left handed coordinates. Use the left or right hand as appropriate, start with your fingers all pointing toward +X, sweep your palm and curl your fingers toward +Y, and then your thumb should point in +Z. (Or, just Google for a picture if needed.) Once you have converted from RH to LH or vice versa you can easily change the up, forward, and right directions by applying a regular old rotational transformation. So, it can be helpful to think of the entire conversion in two steps. If you have RH data with +Z up, then step 1 is convert the data to LH (this will at least make them viewable in Unity), then step 2 is to apply a rotation as you would for any other object in Unity so that the data's +Z will be up. Since Unity has the convention that +Y is up, this rotation can just be a simple 90 degree rotation around the X axis. Since +Z=Up is pretty common in a lot of our data, we include some routines for doing this kind of conversion with one function call, but if you look at the implementation, you'll see that it is accomplishing this by first converting RH to LH, then applying a rotation. Commonly Encountered Coordinate Systems and Conventions Left-Handed, Y=Up, Z=Forward (Unity) +X = Right +Y = Up +Z = Forward (Into the screen) Right-Handed, Y=Up, Z=Backward (MinGfx, ParaView, many others ...) +X = Right +Y = Up +Z = Backward (Out of Screen) Right-Handed, Z=Up, Y=Forward (Blender, XROMM, Joint-Track, ...) +X = Right +Y = Forward (Into Screen) +Z = Up Inheritance object CoordConversion Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class CoordConversion Methods | Improve this Doc View Source FromUnity(Matrix4x4, CoordSystem) Converts a rigid body transformation matrix defined in Unity's coordinate system convention (left-handed, +Y = Up, +Z = Forward) into some new coordinate system convention. Declaration public static Matrix4x4 FromUnity(Matrix4x4 unityMat, CoordConversion.CoordSystem newCS) Parameters Type Name Description Matrix4x4 unityMat CoordConversion.CoordSystem newCS Returns Type Description Matrix4x4 | Improve this Doc View Source FromUnity(Quaternion, CoordSystem) Converts a quaternion defined in Unity's coordinate system convention (left-handed, +Y = Up, +Z = Forward) into some new coordinate system convention. Declaration public static Quaternion FromUnity(Quaternion unityQuat, CoordConversion.CoordSystem newCS) Parameters Type Name Description Quaternion unityQuat CoordConversion.CoordSystem newCS Returns Type Description Quaternion | Improve this Doc View Source FromUnity(Vector3, CoordSystem) Converts a point or vector defined in Unity's coordinate system convention (left-handed, +Y = Up, +Z = Forward) into some new coordinate system convention. Declaration public static Vector3 FromUnity(Vector3 unityVector, CoordConversion.CoordSystem newCS) Parameters Type Name Description Vector3 unityVector CoordConversion.CoordSystem newCS Returns Type Description Vector3 | Improve this Doc View Source GetRotation(Matrix4x4) Utility to convert the rotational component (upper 3x3) of a transformation matrix to a quaternion. Declaration public static Quaternion GetRotation(Matrix4x4 m) Parameters Type Name Description Matrix4x4 m Returns Type Description Quaternion | Improve this Doc View Source GetTranslation(Matrix4x4) Utility to convert the translational component (right column) of a transformation matrix to a vector. Declaration public static Vector3 GetTranslation(Matrix4x4 m) Parameters Type Name Description Matrix4x4 m Returns Type Description Vector3 | Improve this Doc View Source ToUnity(Matrix4x4, CoordSystem) Converts a rigid body transformation matrix (no scaling) defined according to the provided origCS coordinate system convention into a transformation matrix in Unity's coordinate system convention (left-handed, +Y = Up, +Z = Forward). Declaration public static Matrix4x4 ToUnity(Matrix4x4 origMat, CoordConversion.CoordSystem origCS) Parameters Type Name Description Matrix4x4 origMat CoordConversion.CoordSystem origCS Returns Type Description Matrix4x4 | Improve this Doc View Source ToUnity(Quaternion, CoordSystem) Converts a quaternion defined according to the provided origCS coordinate system convention into a vector in Unity's coordinate system convention (left-handed, +Y = Up, +Z = Forward). Declaration public static Quaternion ToUnity(Quaternion origQuat, CoordConversion.CoordSystem origCS) Parameters Type Name Description Quaternion origQuat CoordConversion.CoordSystem origCS Returns Type Description Quaternion | Improve this Doc View Source ToUnity(Vector3, CoordSystem) Converts a point or vector defined according to the provided origCS coordinate system convention into a vector in Unity's coordinate system convention (left-handed, +Y = Up, +Z = Forward). Declaration public static Vector3 ToUnity(Vector3 origVector, CoordConversion.CoordSystem origCS) Parameters Type Name Description Vector3 origVector CoordConversion.CoordSystem origCS Returns Type Description Vector3"
  },
  "api/IVLab.MinVR3.DebugDraw.html": {
    "href": "api/IVLab.MinVR3.DebugDraw.html",
    "title": "Class DebugDraw | MinVR3",
    "keywords": "Class DebugDraw Additions to Unity's useful debugging utililies like Debug.DrawRay and Debug.DrawLine. These are particularly useful for AR/VR applications where the debug output needs to be seen in the Game View (not just scene view.) All parameters duration will default to a single frame when left at 0, otherwise duration is in seconds. Inheritance object DebugDraw Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class DebugDraw Methods | Improve this Doc View Source Axes(Matrix4x4, float, float, float) Draw a set of axes corresponding to a Matrix4x4 basis. Uses standard RGB->XYZ coloring. Declaration public static void Axes(Matrix4x4 basis, float size = 0.1, float duration = 0, float thickness = 0.001) Parameters Type Name Description Matrix4x4 basis float size float duration float thickness | Improve this Doc View Source Bounds(Bounds, Color, float, float) Draw a bounds outline mesh Declaration public static void Bounds(Bounds bounds, Color color, float duration = 0, float thickness = 0.001) Parameters Type Name Description Bounds bounds Color color float duration float thickness | Improve this Doc View Source Bounds(Bounds, Color, Matrix4x4, float, float) Additions to Unity's useful debugging utililies like Debug.DrawRay and Debug.DrawLine. These are particularly useful for AR/VR applications where the debug output needs to be seen in the Game View (not just scene view.) All parameters duration will default to a single frame when left at 0, otherwise duration is in seconds. Declaration public static void Bounds(Bounds bounds, Color color, Matrix4x4 boundsTransform, float duration = 0, float thickness = 0.001) Parameters Type Name Description Bounds bounds Color color Matrix4x4 boundsTransform float duration float thickness | Improve this Doc View Source Circle(Vector3, float, Vector3, Color, float) Draw a circular mesh Declaration public static void Circle(Vector3 center, float radius, Vector3 normal, Color color, float duration = 0) Parameters Type Name Description Vector3 center float radius Vector3 normal Color color float duration | Improve this Doc View Source Line(Vector3, Vector3, Color, float, float) Draw a line as an in-game-rendered cylinder Declaration public static void Line(Vector3 start, Vector3 end, Color color, float duration = 0, float thickness = 0.001) Parameters Type Name Description Vector3 start Vector3 end Color color float duration float thickness | Improve this Doc View Source Point(Vector3, float, Color, float) Additions to Unity's useful debugging utililies like Debug.DrawRay and Debug.DrawLine. These are particularly useful for AR/VR applications where the debug output needs to be seen in the Game View (not just scene view.) All parameters duration will default to a single frame when left at 0, otherwise duration is in seconds. Declaration public static void Point(Vector3 center, float radius, Color color, float duration = 0) Parameters Type Name Description Vector3 center float radius Color color float duration | Improve this Doc View Source Ray(Vector3, Vector3, Color, float, float) Draw a ray as an in-game-rendered cylinder Declaration public static void Ray(Vector3 start, Vector3 direction, Color color, float duration = 0, float thickness = 0.001) Parameters Type Name Description Vector3 start Vector3 direction Color color float duration float thickness | Improve this Doc View Source Sphere(Vector3, float, Color, float) Draw a sphere/point mesh Declaration public static void Sphere(Vector3 center, float radius, Color color, float duration = 0) Parameters Type Name Description Vector3 center float radius Color color float duration | Improve this Doc View Source Text(Vector3, string, Color, float) Draw some text to the screen at a specified position Declaration public static void Text(Vector3 position, string text, Color color, float duration = 0) Parameters Type Name Description Vector3 position string text Color color float duration Remarks Note The Text(Vector3, string, Color, float) method only works in the Unity Editor and only displays in scene view."
  },
  "api/IVLab.MinVR3.DrawEyes.html": {
    "href": "api/IVLab.MinVR3.DrawEyes.html",
    "title": "Class DrawEyes | MinVR3",
    "keywords": "Class DrawEyes This is useful for debugging displays that use off-axis projection, like the walls of a Cave of a fishtank VR or Powerwall display. The position of each eye (as reported via head tracking) is projected onto the plane of the display and a sphere is drawn for each eye at its projected position. You can then move the glasses around and make sure that these spheres move correctly with them to confirm that you have set offsets from the tracker appropriately (e.g., the offset from the tracking device mounted on the glasses to each eye, making sure the left eye is indeed on the left side, etc.) Inheritance object Object Component Behaviour MonoBehaviour DrawEyes Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Debug/Draw Eyes\")] public class DrawEyes : MonoBehaviour Fields | Improve this Doc View Source screen This is useful for debugging displays that use off-axis projection, like the walls of a Cave of a fishtank VR or Powerwall display. The position of each eye (as reported via head tracking) is projected onto the plane of the display and a sphere is drawn for each eye at its projected position. You can then move the glasses around and make sure that these spheres move correctly with them to confirm that you have set offsets from the tracker appropriately (e.g., the offset from the tracking device mounted on the glasses to each eye, making sure the left eye is indeed on the left side, etc.) Declaration public TrackedProjectionScreen screen Field Value Type Description TrackedProjectionScreen | Improve this Doc View Source sphereScale This is useful for debugging displays that use off-axis projection, like the walls of a Cave of a fishtank VR or Powerwall display. The position of each eye (as reported via head tracking) is projected onto the plane of the display and a sphere is drawn for each eye at its projected position. You can then move the glasses around and make sure that these spheres move correctly with them to confirm that you have set offsets from the tracker appropriately (e.g., the offset from the tracking device mounted on the glasses to each eye, making sure the left eye is indeed on the left side, etc.) Declaration public float sphereScale Field Value Type Description float"
  },
  "api/IVLab.MinVR3.DrawFPS.html": {
    "href": "api/IVLab.MinVR3.DrawFPS.html",
    "title": "Class DrawFPS | MinVR3",
    "keywords": "Class DrawFPS Displays a frames-per-second counter in the top-left of the screen; useful when working with a VR display that doesn't allow you to easily see Unity's performance data while you are wearing it. Inheritance object Object Component Behaviour MonoBehaviour DrawFPS Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Debug/Draw FPS\")] public class DrawFPS : MonoBehaviour Fields | Improve this Doc View Source m_FontSize Displays a frames-per-second counter in the top-left of the screen; useful when working with a VR display that doesn't allow you to easily see Unity's performance data while you are wearing it. Declaration public int m_FontSize Field Value Type Description int | Improve this Doc View Source m_Position Displays a frames-per-second counter in the top-left of the screen; useful when working with a VR display that doesn't allow you to easily see Unity's performance data while you are wearing it. Declaration public Rect m_Position Field Value Type Description Rect | Improve this Doc View Source m_TextColor Displays a frames-per-second counter in the top-left of the screen; useful when working with a VR display that doesn't allow you to easily see Unity's performance data while you are wearing it. Declaration public Color m_TextColor Field Value Type Description Color"
  },
  "api/IVLab.MinVR3.DrawTrackers.TrackerDescription.html": {
    "href": "api/IVLab.MinVR3.DrawTrackers.TrackerDescription.html",
    "title": "Class DrawTrackers.TrackerDescription | MinVR3",
    "keywords": "Class DrawTrackers.TrackerDescription Inheritance object DrawTrackers.TrackerDescription Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class DrawTrackers.TrackerDescription Constructors | Improve this Doc View Source TrackerDescription() Declaration public TrackerDescription() Fields | Improve this Doc View Source displayName Declaration public string displayName Field Value Type Description string | Improve this Doc View Source positionEvent Declaration public VREventPrototypeVector3 positionEvent Field Value Type Description VREventPrototypeVector3 | Improve this Doc View Source rotationEvent Declaration public VREventPrototypeQuaternion rotationEvent Field Value Type Description VREventPrototypeQuaternion"
  },
  "api/IVLab.MinVR3.DrawTrackers.html": {
    "href": "api/IVLab.MinVR3.DrawTrackers.html",
    "title": "Class DrawTrackers | MinVR3",
    "keywords": "Class DrawTrackers Inheritance object Object Component Behaviour MonoBehaviour DrawTrackers Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Debug/Draw Trackers\")] public class DrawTrackers : MonoBehaviour, IVREventListener Fields | Improve this Doc View Source cursorPrefab Declaration [Tooltip(\"Prefab of axes geometry to use as a cursor. If the GameObject has a TextMesh component, the text will be set to the tracker name.\")] public GameObject cursorPrefab Field Value Type Description GameObject | Improve this Doc View Source cursorSize Declaration public float cursorSize Field Value Type Description float | Improve this Doc View Source showTrackingInfo Declaration [Tooltip(\"Display the tracking info (position and rotation) on the text box\")] public bool showTrackingInfo Field Value Type Description bool | Improve this Doc View Source trackers Declaration [Tooltip(\"Add an entry for each tracker you wish to display.\")] public List<DrawTrackers.TrackerDescription> trackers Field Value Type Description List<DrawTrackers.TrackerDescription> Methods | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.FSM.html": {
    "href": "api/IVLab.MinVR3.FSM.html",
    "title": "Class FSM | MinVR3",
    "keywords": "Class FSM Inheritance object Object Component Behaviour MonoBehaviour FSM Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Building Blocks/FSM (State Machine)\")] public class FSM : MonoBehaviour, IVREventListener Properties | Improve this Doc View Source DebugMode Declaration public bool DebugMode { get; set; } Property Value Type Description bool | Improve this Doc View Source currentStateID Declaration public int currentStateID { get; } Property Value Type Description int | Improve this Doc View Source startStateID Declaration public int startStateID { get; set; } Property Value Type Description int | Improve this Doc View Source stateNames Declaration public List<string> stateNames { get; } Property Value Type Description List<string> Methods | Improve this Doc View Source AddArc() Declaration public int AddArc() Returns Type Description int | Improve this Doc View Source AddArc(int, int, VREventCallbackAny, SharedToken, SharedToken, Condition) Declaration public int AddArc(int fromStateID, int toStateID, VREventCallbackAny callback, SharedToken requireToTransition = null, SharedToken releaseOnTransition = null, Condition guard = null) Parameters Type Name Description int fromStateID int toStateID VREventCallbackAny callback SharedToken requireToTransition SharedToken releaseOnTransition Condition guard Returns Type Description int | Improve this Doc View Source AddArc(string, string, VREventCallbackAny, SharedToken, SharedToken, Condition) Declaration public int AddArc(string fromState, string toState, VREventCallbackAny callback, SharedToken requireToTransition = null, SharedToken releaseOnTransition = null, Condition guard = null) Parameters Type Name Description string fromState string toState VREventCallbackAny callback SharedToken requireToTransition SharedToken releaseOnTransition Condition guard Returns Type Description int | Improve this Doc View Source AddState(string, VRCallback, VRCallback, VRCallback) Declaration public int AddState(string name, VRCallback onEnterCallback = null, VRCallback onUpdateCallback = null, VRCallback onExitCallback = null) Parameters Type Name Description string name VRCallback onEnterCallback VRCallback onUpdateCallback VRCallback onExitCallback Returns Type Description int | Improve this Doc View Source ArcToString(int) Declaration public string ArcToString(int id) Parameters Type Name Description int id Returns Type Description string | Improve this Doc View Source GetStateID(string) Declaration public int GetStateID(string name) Parameters Type Name Description string name Returns Type Description int | Improve this Doc View Source NumArcs() Declaration public int NumArcs() Returns Type Description int | Improve this Doc View Source NumStates() Declaration public int NumStates() Returns Type Description int | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source RemoveArc(int) Declaration public void RemoveArc(int id) Parameters Type Name Description int id | Improve this Doc View Source RemoveState(int) Declaration public void RemoveState(int id) Parameters Type Name Description int id | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StateExists(string) Declaration public bool StateExists(string name) Parameters Type Name Description string name Returns Type Description bool | Improve this Doc View Source StateToString(int) Declaration public string StateToString(int id) Parameters Type Name Description int id Returns Type Description string | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.FSMEditor.html": {
    "href": "api/IVLab.MinVR3.FSMEditor.html",
    "title": "Class FSMEditor | MinVR3",
    "keywords": "Class FSMEditor Inheritance object Object ScriptableObject Editor FSMEditor Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomEditor(typeof(FSM))] public class FSMEditor : Editor Methods | Improve this Doc View Source OnEnable() Declaration public void OnEnable() | Improve this Doc View Source OnInspectorGUI() Implement this function to make a custom inspector. Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/IVLab.MinVR3.FaceCamera.html": {
    "href": "api/IVLab.MinVR3.FaceCamera.html",
    "title": "Class FaceCamera | MinVR3",
    "keywords": "Class FaceCamera Rotates an object to always face the camera (billboard-style) Inheritance object Object Component Behaviour MonoBehaviour FaceCamera Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Building Blocks/Object Face Camera\")] public class FaceCamera : MonoBehaviour Fields | Improve this Doc View Source cameraToFace Rotates an object to always face the camera (billboard-style) Declaration [SerializeField] [Tooltip(\"Camera to mirror the rotation of (will default to MainCamera tag if empty)\")] public Camera cameraToFace Field Value Type Description Camera"
  },
  "api/IVLab.MinVR3.FakeTrackers.html": {
    "href": "api/IVLab.MinVR3.FakeTrackers.html",
    "title": "Class FakeTrackers | MinVR3",
    "keywords": "Class FakeTrackers Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Inheritance object Object Component Behaviour MonoBehaviour FakeTrackers Implements IPolledInputDevice IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Input/Fake Trackers (Desktop VR Debugging)\")] public class FakeTrackers : MonoBehaviour, IPolledInputDevice, IVREventProducer Fields | Improve this Doc View Source headTrackerBaseName Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration [Tooltip(\"Fake head tracking with arrow keys. 'up' moves forward, 'down' moves backward, 'left' rotates left, 'right' rotates right.\")] public string headTrackerBaseName Field Value Type Description string | Improve this Doc View Source initialHeadPos Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration public Vector3 initialHeadPos Field Value Type Description Vector3 | Improve this Doc View Source initialHeadRot Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration public Vector3 initialHeadRot Field Value Type Description Vector3 | Improve this Doc View Source initialTracker1Pos Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration public Vector3 initialTracker1Pos Field Value Type Description Vector3 | Improve this Doc View Source initialTracker1Rot Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration public Vector3 initialTracker1Rot Field Value Type Description Vector3 | Improve this Doc View Source initialTracker2Pos Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration public Vector3 initialTracker2Pos Field Value Type Description Vector3 | Improve this Doc View Source initialTracker2Rot Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration public Vector3 initialTracker2Rot Field Value Type Description Vector3 | Improve this Doc View Source sceneCam Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration [Tooltip(\"Camera for raycasts into the scene to do mouse-based control of the trackers -- defaults to Camera.main.\")] public Camera sceneCam Field Value Type Description Camera | Improve this Doc View Source tracker1BaseName Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration [Tooltip(\"Base name of the VREvent generated by the first fake tracker.\")] public string tracker1BaseName Field Value Type Description string | Improve this Doc View Source tracker2BaseName Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. Declaration [Tooltip(\"Base name of the VREvent generated by the second fake tracker.\")] public string tracker2BaseName Field Value Type Description string Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source PollForEvents(ref List<VREvent>) Calling Poll adds to the queue any input events generated since the last call to poll. Declaration public void PollForEvents(ref List<VREvent> eventQueue) Parameters Type Name Description List<VREvent> eventQueue Implements IPolledInputDevice IVREventProducer"
  },
  "api/IVLab.MinVR3.FloatingMenu.html": {
    "href": "api/IVLab.MinVR3.FloatingMenu.html",
    "title": "Class FloatingMenu | MinVR3",
    "keywords": "Class FloatingMenu Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Inheritance object Object Component Behaviour MonoBehaviour FloatingMenu Implements IVREventListener IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [ExecuteAlways] [AddComponentMenu(\"MinVR Interaction/Widgets/Menus/Floating Menu\")] public class FloatingMenu : MonoBehaviour, IVREventListener, IVREventProducer Properties | Improve this Doc View Source menuItems Ordered list of strings for the choices that can be selected from the menu, displayed top to bottom. Declaration public List<string> menuItems { get; set; } Property Value Type Description List<string> | Improve this Doc View Source title Title displayed in all caps on the left side of the menu Declaration public string title { get; set; } Property Value Type Description string Methods | Improve this Doc View Source GetEventNameForMenuItem(int) Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public string GetEventNameForMenuItem(int itemId) Parameters Type Name Description int itemId Returns Type Description string | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source OnButtonDown() Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public void OnButtonDown() | Improve this Doc View Source OnButtonUp() Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public void OnButtonUp() | Improve this Doc View Source OnTrackerMove(Vector3) Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public void OnTrackerMove(Vector3 pos) Parameters Type Name Description Vector3 pos | Improve this Doc View Source OnTrackerRotate(Quaternion) Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public void OnTrackerRotate(Quaternion rot) Parameters Type Name Description Quaternion rot | Improve this Doc View Source OnVREvent(VREvent) Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source Reset() Restores default values, called whenever the component is added to a GameObject in the editor Declaration public void Reset() | Improve this Doc View Source StartListening() Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public void StartListening() | Improve this Doc View Source StopListening() Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public void StopListening() | Improve this Doc View Source Update() Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. Declaration public void Update() Implements IVREventListener IVREventProducer"
  },
  "api/IVLab.MinVR3.GameObjectExtensions.html": {
    "href": "api/IVLab.MinVR3.GameObjectExtensions.html",
    "title": "Class GameObjectExtensions | MinVR3",
    "keywords": "Class GameObjectExtensions Inheritance object GameObjectExtensions Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class GameObjectExtensions Methods | Improve this Doc View Source GetScenePath(GameObject) Gets the path of this GameObject in the scene hierarchy Declaration public static string GetScenePath(this GameObject obj) Parameters Type Name Description GameObject obj Returns Type Description string"
  },
  "api/IVLab.MinVR3.GridOfObjects.GridType.html": {
    "href": "api/IVLab.MinVR3.GridOfObjects.GridType.html",
    "title": "Enum GridOfObjects.GridType | MinVR3",
    "keywords": "Enum GridOfObjects.GridType Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum GridOfObjects.GridType Fields Name Description Planar Spherical"
  },
  "api/IVLab.MinVR3.GridOfObjects.html": {
    "href": "api/IVLab.MinVR3.GridOfObjects.html",
    "title": "Class GridOfObjects | MinVR3",
    "keywords": "Class GridOfObjects A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Inheritance object Object Component Behaviour MonoBehaviour GridOfObjects Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Building Blocks/Grid of Objects\")] public class GridOfObjects : MonoBehaviour Fields | Improve this Doc View Source m_CreateTestObjects A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Declaration public bool m_CreateTestObjects Field Value Type Description bool | Improve this Doc View Source m_GridCenterPoint A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Declaration public Vector3 m_GridCenterPoint Field Value Type Description Vector3 | Improve this Doc View Source m_GridColumnDir A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Declaration public Vector3 m_GridColumnDir Field Value Type Description Vector3 | Improve this Doc View Source m_GridRowDir A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Declaration public Vector3 m_GridRowDir Field Value Type Description Vector3 | Improve this Doc View Source m_GridType A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Declaration public GridOfObjects.GridType m_GridType Field Value Type Description GridOfObjects.GridType | Improve this Doc View Source m_NumColumns A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Declaration public int m_NumColumns Field Value Type Description int | Improve this Doc View Source m_NumRows A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Declaration public int m_NumRows Field Value Type Description int | Improve this Doc View Source m_Objects A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) Declaration public List<GameObject> m_Objects Field Value Type Description List<GameObject>"
  },
  "api/IVLab.MinVR3.IClusterNode.html": {
    "href": "api/IVLab.MinVR3.IClusterNode.html",
    "title": "Interface IClusterNode | MinVR3",
    "keywords": "Interface IClusterNode Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public interface IClusterNode Methods | Improve this Doc View Source Initialize() Declaration void Initialize() | Improve this Doc View Source Shutdown() Declaration void Shutdown() | Improve this Doc View Source SynchronizeInputEventsAcrossAllNodes(ref List<VREvent>) Declaration void SynchronizeInputEventsAcrossAllNodes(ref List<VREvent> inputEvents) Parameters Type Name Description List<VREvent> inputEvents | Improve this Doc View Source SynchronizeSwapBuffersAcrossAllNodes() Declaration void SynchronizeSwapBuffersAcrossAllNodes()"
  },
  "api/IVLab.MinVR3.IPolledInputDevice.html": {
    "href": "api/IVLab.MinVR3.IPolledInputDevice.html",
    "title": "Interface IPolledInputDevice | MinVR3",
    "keywords": "Interface IPolledInputDevice Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public interface IPolledInputDevice : IVREventProducer Methods | Improve this Doc View Source PollForEvents(ref List<VREvent>) Calling Poll adds to the queue any input events generated since the last call to poll. Declaration void PollForEvents(ref List<VREvent> eventQueue) Parameters Type Name Description List<VREvent> eventQueue"
  },
  "api/IVLab.MinVR3.IVRCallback.html": {
    "href": "api/IVLab.MinVR3.IVRCallback.html",
    "title": "Interface IVRCallback | MinVR3",
    "keywords": "Interface IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public interface IVRCallback Methods | Improve this Doc View Source InvokeWithVREvent(VREvent) Declaration void InvokeWithVREvent(VREvent e) Parameters Type Name Description VREvent e"
  },
  "api/IVLab.MinVR3.IVREventConnection.html": {
    "href": "api/IVLab.MinVR3.IVREventConnection.html",
    "title": "Interface IVREventConnection | MinVR3",
    "keywords": "Interface IVREventConnection Defines an interface for classes that can send and/or receive VREvents over some sort of remote network connection. Unlike the network transport provided by MinVR3's Cluster Mode, which supports frame-level synchronization of the entire event queue, this network connection is intended for sending/receiving a subset of VREvents and for situations where the clients at either end of the connection are running asynchronously. This can be used to connect a MinVR Unity app to a web browser or to connect multiple MinVR apps running on various brands of headsets -- basically all situations other than a cluster powering a tiled display. Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public interface IVREventConnection Properties | Improve this Doc View Source OnVREventReceived Subscribe to OnVREventReceived to recieve a callback whenever a VREvent is received over the network \"connection\", Declaration OnVREventReceived.OnVREventReceivedDelegate OnVREventReceived { get; set; } Property Value Type Description OnVREventReceived.OnVREventReceivedDelegate Methods | Improve this Doc View Source CanReceive() Returns true if the VREventConnection supports receiving VREvents. Declaration bool CanReceive() Returns Type Description bool | Improve this Doc View Source CanSend() Returns true if the VREventConnection supports sending VREvents. Declaration bool CanSend() Returns Type Description bool | Improve this Doc View Source Send(in VREvent) Send a VR event to the other end of this \"connection\" Declaration void Send(in VREvent evt) Parameters Type Name Description VREvent evt"
  },
  "api/IVLab.MinVR3.IVREventFilter.html": {
    "href": "api/IVLab.MinVR3.IVREventFilter.html",
    "title": "Interface IVREventFilter | MinVR3",
    "keywords": "Interface IVREventFilter Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public interface IVREventFilter Methods | Improve this Doc View Source FilterEvent(VREvent, ref List<VREvent>) Each frame, IVREventFilters can process events and optionally modify them before the events are sent to IVREventListeners. The VREventManager passes each event through the active filters just before that event is to be sent out to listeners. A filter can then decide what to do with the event. For example, an EventAlias filter could change the name of the event. A ProximityEvent filter could listen for the position of two trackers and when they are within some threshold, generate a new event in response. A filter could also completely discard the event. the event from view of the IVREventListeners. Declaration bool FilterEvent(VREvent e, ref List<VREvent> filterResult) Parameters Type Name Description VREvent e One event at a time is passed into the filter List<VREvent> filterResult If the filter modifies the event in some way, this list returns the result of those modifications. This parameter is a list rather than a single event since some filters may create a new event in response to the event and return both the original and the new events. This will essentially \"insert\" a new event in the event queue as it is processed. Returns Type Description bool true if the filter has modified the event in some way and returned the result in filterResult. falseif the event passes through the filter without change."
  },
  "api/IVLab.MinVR3.IVREventListener.html": {
    "href": "api/IVLab.MinVR3.IVREventListener.html",
    "title": "Interface IVREventListener | MinVR3",
    "keywords": "Interface IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public interface IVREventListener Methods | Improve this Doc View Source OnVREvent(VREvent) Declaration void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source StartListening() Declaration void StartListening() | Improve this Doc View Source StopListening() Declaration void StopListening()"
  },
  "api/IVLab.MinVR3.IVREventProducer.html": {
    "href": "api/IVLab.MinVR3.IVREventProducer.html",
    "title": "Interface IVREventProducer | MinVR3",
    "keywords": "Interface IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public interface IVREventProducer Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime."
  },
  "api/IVLab.MinVR3.IVREventPrototype.html": {
    "href": "api/IVLab.MinVR3.IVREventPrototype.html",
    "title": "Interface IVREventPrototype | MinVR3",
    "keywords": "Interface IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public interface IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration IVREventPrototype Clone() Returns Type Description IVREventPrototype | Improve this Doc View Source GetEventDataTypeName() Declaration string GetEventDataTypeName() Returns Type Description string | Improve this Doc View Source GetEventDisplayName() Declaration string GetEventDisplayName() Returns Type Description string | Improve this Doc View Source GetEventName() Declaration string GetEventName() Returns Type Description string | Improve this Doc View Source SetEventName(string) Declaration void SetEventName(string eventName) Parameters Type Name Description string eventName"
  },
  "api/IVLab.MinVR3.InfoBoxAttribute.html": {
    "href": "api/IVLab.MinVR3.InfoBoxAttribute.html",
    "title": "Class InfoBoxAttribute | MinVR3",
    "keywords": "Class InfoBoxAttribute Inheritance object Attribute PropertyAttribute InfoBoxAttribute Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = true)] public class InfoBoxAttribute : PropertyAttribute Constructors | Improve this Doc View Source InfoBoxAttribute(string) Declaration public InfoBoxAttribute(string message) Parameters Type Name Description string message Fields | Improve this Doc View Source message Declaration public string message Field Value Type Description string"
  },
  "api/IVLab.MinVR3.InfoBoxAttributeDrawer.html": {
    "href": "api/IVLab.MinVR3.InfoBoxAttributeDrawer.html",
    "title": "Class InfoBoxAttributeDrawer | MinVR3",
    "keywords": "Class InfoBoxAttributeDrawer Inheritance object GUIDrawer DecoratorDrawer InfoBoxAttributeDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(InfoBoxAttribute))] public class InfoBoxAttributeDrawer : DecoratorDrawer Methods | Improve this Doc View Source GetHeight() Override this method to specify how tall the GUI for this decorator is in pixels. Declaration public override float GetHeight() Returns Type Description float Overrides DecoratorDrawer.GetHeight() | Improve this Doc View Source OnGUI(Rect) Override this method to make your own GUI for the decorator. See DecoratorDrawer for an example of how to use this. Declaration public override void OnGUI(Rect position) Parameters Type Name Description Rect position Rectangle on the screen to use for the decorator GUI. Overrides UnityEditor.DecoratorDrawer.OnGUI(UnityEngine.Rect)"
  },
  "api/IVLab.MinVR3.KeyboardState.html": {
    "href": "api/IVLab.MinVR3.KeyboardState.html",
    "title": "Class KeyboardState | MinVR3",
    "keywords": "Class KeyboardState Facade to hide the different strategies for accessing keyboard input depending on whether using the Legacy InputModule or the New Input System. Inheritance object KeyboardState Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class KeyboardState Methods | Improve this Doc View Source KeyIsPressed(KeyCode) Facade to hide the different strategies for accessing keyboard input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool KeyIsPressed(KeyCode key) Parameters Type Name Description KeyCode key Returns Type Description bool | Improve this Doc View Source KeyWasPressedThisFrame(KeyCode) Facade to hide the different strategies for accessing keyboard input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool KeyWasPressedThisFrame(KeyCode key) Parameters Type Name Description KeyCode key Returns Type Description bool | Improve this Doc View Source KeyWasReleasedThisFrame(KeyCode) Facade to hide the different strategies for accessing keyboard input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool KeyWasReleasedThisFrame(KeyCode key) Parameters Type Name Description KeyCode key Returns Type Description bool"
  },
  "api/IVLab.MinVR3.Matrix4x4Extensions.html": {
    "href": "api/IVLab.MinVR3.Matrix4x4Extensions.html",
    "title": "Class Matrix4x4Extensions | MinVR3",
    "keywords": "Class Matrix4x4Extensions Inheritance object Matrix4x4Extensions Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class Matrix4x4Extensions Methods | Improve this Doc View Source GetRotationFast(Matrix4x4) Does not do a full matrix decomposition. Assumes m is a simple transformation matrix that was created by composing a scale then a rotation then a translation, like the way Unity builds its transformations from these three components. This means there is no shearing in the matrix. Also assumes the matrix contains only positive scale factors in x, y, z. Declaration public static Quaternion GetRotationFast(this Matrix4x4 m) Parameters Type Name Description Matrix4x4 m Returns Type Description Quaternion | Improve this Doc View Source GetScaleFast(Matrix4x4) Does not do a full matrix decomposition. Assumes m is a simple transformation matrix that was created by composing a scale then a rotation then a translation, like the way Unity builds its transformations from these three components. This means there is no shearing in the matrix. Also assumes the matrix contains only positive scale factors in x, y, z. Declaration public static Vector3 GetScaleFast(this Matrix4x4 matrix) Parameters Type Name Description Matrix4x4 matrix Returns Type Description Vector3 | Improve this Doc View Source GetTranslationFast(Matrix4x4) Does not do a full matrix decomposition. Assumes m is a simple transformation matrix that was created by composing a scale then a rotation then a translation, like the way Unity builds its transformations from these three components. This means there is no shearing in the matrix. Also assumes the matrix contains only positive scale factors in x, y, z. Declaration public static Vector3 GetTranslationFast(this Matrix4x4 m) Parameters Type Name Description Matrix4x4 m Returns Type Description Vector3 | Improve this Doc View Source SetRotation(ref Matrix4x4, Quaternion) Declaration public static void SetRotation(this ref Matrix4x4 matrix, Quaternion rotation) Parameters Type Name Description Matrix4x4 matrix Quaternion rotation | Improve this Doc View Source SetScale(ref Matrix4x4, Vector3) Declaration public static void SetScale(this ref Matrix4x4 matrix, Vector3 scale) Parameters Type Name Description Matrix4x4 matrix Vector3 scale | Improve this Doc View Source SetTranslation(ref Matrix4x4, Vector3) Declaration public static void SetTranslation(this ref Matrix4x4 matrix, Vector3 position) Parameters Type Name Description Matrix4x4 matrix Vector3 position"
  },
  "api/IVLab.MinVR3.MenuHelpers.html": {
    "href": "api/IVLab.MinVR3.MenuHelpers.html",
    "title": "Class MenuHelpers | MinVR3",
    "keywords": "Class MenuHelpers These constants and functions help to add MinVR items to Unity's internal GameObject, Component, and Asset menus in a consistent way. Use these both within the main MinVR package and plugins. Inheritance object Object Component Behaviour MonoBehaviour MenuHelpers Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax public class MenuHelpers : MonoBehaviour Fields | Improve this Doc View Source gameObjectMenuPriority These constants and functions help to add MinVR items to Unity's internal GameObject, Component, and Asset menus in a consistent way. Use these both within the main MinVR package and plugins. Declaration public const int gameObjectMenuPriority = 11 Field Value Type Description int | Improve this Doc View Source minVRSec2Priority These constants and functions help to add MinVR items to Unity's internal GameObject, Component, and Asset menus in a consistent way. Use these both within the main MinVR package and plugins. Declaration public const int minVRSec2Priority = 23 Field Value Type Description int | Improve this Doc View Source mvriItemPriority These constants and functions help to add MinVR items to Unity's internal GameObject, Component, and Asset menus in a consistent way. Use these both within the main MinVR package and plugins. Declaration public const int mvriItemPriority = 12 Field Value Type Description int | Improve this Doc View Source vrConfigSec1Priority These constants and functions help to add MinVR items to Unity's internal GameObject, Component, and Asset menus in a consistent way. Use these both within the main MinVR package and plugins. Declaration public const int vrConfigSec1Priority = 22 Field Value Type Description int | Improve this Doc View Source vrConfigSec2Priority These constants and functions help to add MinVR items to Unity's internal GameObject, Component, and Asset menus in a consistent way. Use these both within the main MinVR package and plugins. Declaration public const int vrConfigSec2Priority = 33 Field Value Type Description int | Improve this Doc View Source vrConfigSec3Priority These constants and functions help to add MinVR items to Unity's internal GameObject, Component, and Asset menus in a consistent way. Use these both within the main MinVR package and plugins. Declaration public const int vrConfigSec3Priority = 44 Field Value Type Description int Methods | Improve this Doc View Source AddButtonAliases(GameObject, string, string) Adds two EventAlias components to the game object, one for a Down event, one for an Up event. Declaration public static void AddButtonAliases(GameObject go, string aliasBaseName, string origEventBaseName) Parameters Type Name Description GameObject go Game Object to add the components to. string aliasBaseName Name for the alias event without /Down or /Up string origEventBaseName Name for the existing event that should be renamed with the alias, without the trailing /Down or /Up. | Improve this Doc View Source AddTrackingAliases(GameObject, string, string) Adds two EventAlias components to the game object, one for a Position event, one for a Rotation event. Declaration public static void AddTrackingAliases(GameObject go, string aliasBaseName, string origEventBaseName) Parameters Type Name Description GameObject go Game Object to add the components to. string aliasBaseName Name for the alias event without /Position or /Rotation string origEventBaseName Name for the existing event that should be renamed with the alias, without the trailing /Position or /Rotation. | Improve this Doc View Source CreateAndPlaceGameObject(string, GameObject, params Type[]) Creates a new GameObject and adds it to the hierarchy. Declaration public static GameObject CreateAndPlaceGameObject(string name, GameObject parent, params Type[] componentTypes) Parameters Type Name Description string name Name for the new object GameObject parent New object's parent or 'null' to place in the root of the hierarchy. Type[] componentTypes Array of zero or more components to attach to the object. To attach zero components use an empty array, like 'new Type[] {}'. Returns Type Description GameObject The newly created GameObject. | Improve this Doc View Source CreateAndPlacePrimitive(string, GameObject, PrimitiveType) Creates one of Unity's built-in Primitive GameObjects and adds it to the hierarchy. Declaration public static GameObject CreateAndPlacePrimitive(string name, GameObject parent, PrimitiveType primitiveType) Parameters Type Name Description string name Name for the new object GameObject parent New object's parent or 'null' to place in the root of the hierarchy. PrimitiveType primitiveType Cube, sphere, capsule, plane, etc. Returns Type Description GameObject The newly created Primitive GameObject. | Improve this Doc View Source CreateRoomSpaceOriginIfNeeded() MinVR requires one object in the scene to be identified as the Room Space Origin. This routine creates that object at the root of the hierarchy if it is not already found in the hierarchy. Declaration public static GameObject CreateRoomSpaceOriginIfNeeded() Returns Type Description GameObject The found or newly created GameObject with RoomSpaceOrigin attached. | Improve this Doc View Source CreateVRConfigTemplate(MenuCommand, string, ref GameObject, ref GameObject, ref GameObject) Creates a standard layout for MinVR VRConfig nodes. Includes a root GameObject named VRConfig_Name and three child objects (Event Aliases, Input Devices, Display Devices). Following MinVR's convention, it also creates a minvr-configvals-name.txt config file in the Assets folder. The child objects will not (yet) have any specific input, display, or alias components attached. Declaration public static GameObject CreateVRConfigTemplate(MenuCommand command, string name, ref GameObject inputDevChild, ref GameObject displayDevChild, ref GameObject eventAliasesChild) Parameters Type Name Description MenuCommand command string name GameObject inputDevChild GameObject displayDevChild GameObject eventAliasesChild Returns Type Description GameObject The created VRConfig_Name GameObject. | Improve this Doc View Source CreateVREngineIfNeeded() MinVR requires the singleton VREngine class to exist in the hierarchy. This routine creates it at the root of the hierarchy if needed. Following MinVR's convention, it also creates a minvr-configvals-default.txt config file in the Assets folder. Declaration public static GameObject CreateVREngineIfNeeded() Returns Type Description GameObject The found or newly created GameObject with VREngine attached. | Improve this Doc View Source InstatiatePrefabFromAsset(GameObject, string) Finds a prefab in the AssetDatabase and adds an instance of it to the hierarchy. Declaration public static GameObject InstatiatePrefabFromAsset(GameObject parent, string searchStr) Parameters Type Name Description GameObject parent Parent for the new prefab or null to place at the root of the hierarchy. string searchStr Identifies the prefab by path or type. Several options are possible. See Unity's AssetDatabase.FindAssets() for details. Returns Type Description GameObject | Improve this Doc View Source ResetTransform(Transform) Resets the transform to the identity Declaration public static void ResetTransform(Transform transform) Parameters Type Name Description Transform transform"
  },
  "api/IVLab.MinVR3.Menu_GameObject_MinVR.html": {
    "href": "api/IVLab.MinVR3.Menu_GameObject_MinVR.html",
    "title": "Class Menu_GameObject_MinVR | MinVR3",
    "keywords": "Class Menu_GameObject_MinVR Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Inheritance object Object Component Behaviour MonoBehaviour Menu_GameObject_MinVR Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax public class Menu_GameObject_MinVR : MonoBehaviour Methods | Improve this Doc View Source CreateDebugDrawEyes(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Debug/Draw Eyes\", false, 23)] public static void CreateDebugDrawEyes(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateDebugDrawFPS(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Debug/Draw Frames Per Second\", false, 23)] public static void CreateDebugDrawFPS(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateDebugDrawTrackers(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Debug/Draw Trackers\", false, 23)] public static void CreateDebugDrawTrackers(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateDisplayTrackedDesktopCamera(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Display Devices/Tracked Desktop Camera\", false, 23)] public static void CreateDisplayTrackedDesktopCamera(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateDisplayTrackedProjectionScreen(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Display Devices/Tracked Projection Screen\", false, 23)] public static void CreateDisplayTrackedProjectionScreen(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateDisplayWindowSettings(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Display Devices/Window Settings\", false, 23)] public static void CreateDisplayWindowSettings(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInputCallableEvent(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Input Devices/Virtual/Callable Event Producer\", false, 23)] public static void CreateInputCallableEvent(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInputFakeTrackers(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Input Devices/Virtual/Fake Tracking Device\", false, 23)] public static void CreateInputFakeTrackers(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInputMobileSensors(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Input Devices/Unity Builtin/Mobile Sensors\", false, 23)] public static void CreateInputMobileSensors(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInputModifiedEvent(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Input Devices/Virtual/Modified Event Producer\", false, 23)] public static void CreateInputModifiedEvent(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInputMouseAndKeyboard(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Input Devices/Unity Builtin/Mouse and Keyboard\", false, 23)] public static void CreateInputMouseAndKeyboard(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInputProximityEvent(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Input Devices/Virtual/Proximity Event Producer\", false, 23)] public static void CreateInputProximityEvent(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInputTouch(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Input Devices/Unity Builtin/Touch Builtin\", false, 23)] public static void CreateInputTouch(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionSimpleEventListener(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/VREvent/Simple Event Listener\", false, 23)] public static void CreateInteractionSimpleEventListener(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVREngine(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/Get Started/Create \\\"VREngine\\\" and \\\"Room Space Origin\\\"\", false, 11)] public static void CreateVREngine(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVREventVREventAlias(MenuCommand) Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Declaration [MenuItem(\"GameObject/MinVR/VREvent/VREvent Alias\", false, 23)] public static void CreateVREventVREventAlias(MenuCommand command) Parameters Type Name Description MenuCommand command"
  },
  "api/IVLab.MinVR3.Menu_GameObject_MinVRInteraction.html": {
    "href": "api/IVLab.MinVR3.Menu_GameObject_MinVRInteraction.html",
    "title": "Class Menu_GameObject_MinVRInteraction | MinVR3",
    "keywords": "Class Menu_GameObject_MinVRInteraction Inheritance object Object Component Behaviour MonoBehaviour Menu_GameObject_MinVRInteraction Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax public class Menu_GameObject_MinVRInteraction : MonoBehaviour Methods | Improve this Doc View Source CreateInteractionBasicHighlighter(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Selection/Basic Highlighter\", false, 12)] public static void CreateInteractionBasicHighlighter(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionBasicObjectSelector(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Selection/Basic Object Selector\", false, 12)] public static void CreateInteractionBasicObjectSelector(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionBimanualObjectManipulator(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Navigation & Manipulation/Bimanual Object Manipulation\", false, 12)] public static void CreateInteractionBimanualObjectManipulator(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionBimanualObjectSelector(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Selection/Bimanual Object Selector\", false, 12)] public static void CreateInteractionBimanualObjectSelector(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionCavePaintingBrush(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Cursors/CavePainting Brush (Dominant Hand)\", false, 12)] public static void CreateInteractionCavePaintingBrush(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionColorPicker(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Widgets/Color Picker (CavePainting Syle)\", false, 12)] public static void CreateInteractionColorPicker(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionCone(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Cursors/Small Cone (Dominant Hand)\", false, 12)] public static void CreateInteractionCone(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionFSM(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Building Blocks/FSM\", false, 12)] public static void CreateInteractionFSM(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionFloatingMenu(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Widgets/Menus/Basic Floating Menu\", false, 12)] public static void CreateInteractionFloatingMenu(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionMouseObjectManipulator(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Desktop/Mouse-Object Manipulator\", false, 12)] public static void CreateInteractionMouseObjectManipulator(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionSharedToken(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Building Blocks/Shared Token (e.g., Input Focus Token)\", false, 12)] public static void CreateInteractionSharedToken(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionSimpleEventListener(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Building Blocks/Simple Event Listener\", false, 12)] public static void CreateInteractionSimpleEventListener(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionSmallCubeCursor(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Cursors/Small Cube (Non-Dominant Hand)\", false, 12)] public static void CreateInteractionSmallCubeCursor(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionSmartScene(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Navigation & Manipulation/Smart Scene\", false, 12)] public static void CreateInteractionSmartScene(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionTrackballCamera(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Desktop/Trackball Camera\", false, 12)] public static void CreateInteractionTrackballCamera(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionTrackedPoseDriver(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Cursors/Tracked Pose Driver\", false, 11)] public static void CreateInteractionTrackedPoseDriver(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateInteractionUniCam(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR Interaction/Desktop/UniCam\", false, 12)] public static void CreateInteractionUniCam(MenuCommand command) Parameters Type Name Description MenuCommand command"
  },
  "api/IVLab.MinVR3.Menu_GameObject_MinVR_VRConfigs.html": {
    "href": "api/IVLab.MinVR3.Menu_GameObject_MinVR_VRConfigs.html",
    "title": "Class Menu_GameObject_MinVR_VRConfigs | MinVR3",
    "keywords": "Class Menu_GameObject_MinVR_VRConfigs Inheritance object Object Component Behaviour MonoBehaviour Menu_GameObject_MinVR_VRConfigs Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax public class Menu_GameObject_MinVR_VRConfigs : MonoBehaviour Fields | Improve this Doc View Source defaultCameraPosition Declaration public static Vector3 defaultCameraPosition Field Value Type Description Vector3 Methods | Improve this Doc View Source CreateVRConfigBasicVRSimulator(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_BasicVRSimulator (Desktop with Fake Trackers)\", false, 33)] public static void CreateVRConfigBasicVRSimulator(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigCardboardVR(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_CardboardVR (Phone or Tablet)\", false, 33)] public static void CreateVRConfigCardboardVR(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigClipboardVR(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_ClipboardVR (Tablet)\", false, 33)] public static void CreateVRConfigClipboardVR(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigClusterClient(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_ClusterClient (Tiled Display Client)\", false, 33)] public static void CreateVRConfigClusterClient(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigClusterServer(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_ClusterServer (Tiled Display Server)\", false, 33)] public static void CreateVRConfigClusterServer(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigDesktop(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_Desktop (No VR)\", false, 33)] public static void CreateVRConfigDesktop(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigEmpty(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_MyConfigName (Template to Create Your Own)\", false, 22)] public static void CreateVRConfigEmpty(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigFishtankVR(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_Fishtank (3DTV or Projected)\", false, 33)] public static void CreateVRConfigFishtankVR(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigVRConfigMask(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig Mask\", false, 44)] public static void CreateVRConfigVRConfigMask(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfigWorkbench(MenuCommand) Declaration [MenuItem(\"GameObject/MinVR/VRConfig/VRConfig_Workbench (Fishtank + Touch Table)\", false, 33)] public static void CreateVRConfigWorkbench(MenuCommand command) Parameters Type Name Description MenuCommand command"
  },
  "api/IVLab.MinVR3.Menu_GameObject_UmnCave_VRConfigs.html": {
    "href": "api/IVLab.MinVR3.Menu_GameObject_UmnCave_VRConfigs.html",
    "title": "Class Menu_GameObject_UmnCave_VRConfigs | MinVR3",
    "keywords": "Class Menu_GameObject_UmnCave_VRConfigs Inheritance object Object Component Behaviour MonoBehaviour Menu_GameObject_UmnCave_VRConfigs Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax public class Menu_GameObject_UmnCave_VRConfigs : MonoBehaviour Methods | Improve this Doc View Source CreateVRConfig3WallCaveSingleWindow(MenuCommand) Declaration public static void CreateVRConfig3WallCaveSingleWindow(MenuCommand command) Parameters Type Name Description MenuCommand command | Improve this Doc View Source CreateVRConfig4WallCaveSingleWindow(MenuCommand) Declaration public static void CreateVRConfig4WallCaveSingleWindow(MenuCommand command) Parameters Type Name Description MenuCommand command"
  },
  "api/IVLab.MinVR3.MobileSensors.html": {
    "href": "api/IVLab.MinVR3.MobileSensors.html",
    "title": "Class MobileSensors | MinVR3",
    "keywords": "Class MobileSensors This script uses the legacy Unity Input Module rather than the \"New Input System\" because the Unity Remote App (used for iOS and Android development) does not yet support the New Input System. It seems that the New Input System works fine if you actually fully deploy the app, but not with Unity Remote, which is super useful for developing mobile apps. So, for now, this uses the Legacy InputModule. When Unity Remote is updated, we should update this script as well so we are consistent with all of MinVR using the New Input System. Note: You can switch which input system you want to use for your app in Player Settings, and it is possible to select \"Both\". That works well if you want to use the New Input System's better support for XR and the Remote's better support for touch, for example. Inheritance object Object Component Behaviour MonoBehaviour MobileSensors Implements IPolledInputDevice IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Input/Mobile Sensors (Legacy Unity Input Module)\")] public class MobileSensors : MonoBehaviour, IPolledInputDevice, IVREventProducer Fields | Improve this Doc View Source m_AccelerationEventName This script uses the legacy Unity Input Module rather than the \"New Input System\" because the Unity Remote App (used for iOS and Android development) does not yet support the New Input System. It seems that the New Input System works fine if you actually fully deploy the app, but not with Unity Remote, which is super useful for developing mobile apps. So, for now, this uses the Legacy InputModule. When Unity Remote is updated, we should update this script as well so we are consistent with all of MinVR using the New Input System. Note: You can switch which input system you want to use for your app in Player Settings, and it is possible to select \"Both\". That works well if you want to use the New Input System's better support for XR and the Remote's better support for touch, for example. Declaration [Tooltip(\"The name of the VREvent to generate for acceleration events (averaged over the past frame).\")] public string m_AccelerationEventName Field Value Type Description string | Improve this Doc View Source m_CompassHeadingEventName This script uses the legacy Unity Input Module rather than the \"New Input System\" because the Unity Remote App (used for iOS and Android development) does not yet support the New Input System. It seems that the New Input System works fine if you actually fully deploy the app, but not with Unity Remote, which is super useful for developing mobile apps. So, for now, this uses the Legacy InputModule. When Unity Remote is updated, we should update this script as well so we are consistent with all of MinVR using the New Input System. Note: You can switch which input system you want to use for your app in Player Settings, and it is possible to select \"Both\". That works well if you want to use the New Input System's better support for XR and the Remote's better support for touch, for example. Declaration [Tooltip(\"The name of the VREvent to generate when the compass heading changes.\")] public string m_CompassHeadingEventName Field Value Type Description string | Improve this Doc View Source m_GyroscopeAttitudeEventName This script uses the legacy Unity Input Module rather than the \"New Input System\" because the Unity Remote App (used for iOS and Android development) does not yet support the New Input System. It seems that the New Input System works fine if you actually fully deploy the app, but not with Unity Remote, which is super useful for developing mobile apps. So, for now, this uses the Legacy InputModule. When Unity Remote is updated, we should update this script as well so we are consistent with all of MinVR using the New Input System. Note: You can switch which input system you want to use for your app in Player Settings, and it is possible to select \"Both\". That works well if you want to use the New Input System's better support for XR and the Remote's better support for touch, for example. Declaration [Tooltip(\"The name of the VREvent to generate when the gyro attitude changes.\")] public string m_GyroscopeAttitudeEventName Field Value Type Description string Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source PollForEvents(ref List<VREvent>) Calling Poll adds to the queue any input events generated since the last call to poll. Declaration public void PollForEvents(ref List<VREvent> eventQueue) Parameters Type Name Description List<VREvent> eventQueue Implements IPolledInputDevice IVREventProducer"
  },
  "api/IVLab.MinVR3.ModifiedEventProducer.html": {
    "href": "api/IVLab.MinVR3.ModifiedEventProducer.html",
    "title": "Class ModifiedEventProducer | MinVR3",
    "keywords": "Class ModifiedEventProducer Listens for two events: a base event and a modifier event. The modifier event must support some kind of ON/OFF logic (e.g. a keyboard key UP / DOWN). When the modifier is ON, this script will send \"modified\" events as specified by the modified event naming strategy Inheritance object Object Component Behaviour MonoBehaviour ModifiedEventProducer Implements IVREventFilter IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Input/Modified Event Producer\")] public class ModifiedEventProducer : MonoBehaviour, IVREventFilter, IVREventProducer Methods | Improve this Doc View Source FilterEvent(VREvent, ref List<VREvent>) Each frame, IVREventFilters can process events and optionally modify them before the events are sent to IVREventListeners. The VREventManager passes each event through the active filters just before that event is to be sent out to listeners. A filter can then decide what to do with the event. For example, an EventAlias filter could change the name of the event. A ProximityEvent filter could listen for the position of two trackers and when they are within some threshold, generate a new event in response. A filter could also completely discard the event. the event from view of the IVREventListeners. Declaration public bool FilterEvent(VREvent e, ref List<VREvent> filterResult) Parameters Type Name Description VREvent e One event at a time is passed into the filter List<VREvent> filterResult If the filter modifies the event in some way, this list returns the result of those modifications. This parameter is a list rather than a single event since some filters may create a new event in response to the event and return both the original and the new events. This will essentially \"insert\" a new event in the event queue as it is processed. Returns Type Description bool true if the filter has modified the event in some way and returned the result in filterResult. falseif the event passes through the filter without change. | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. Implements IVREventFilter IVREventProducer"
  },
  "api/IVLab.MinVR3.MouseAndKeyboard.KeyToVREventName.html": {
    "href": "api/IVLab.MinVR3.MouseAndKeyboard.KeyToVREventName.html",
    "title": "Class MouseAndKeyboard.KeyToVREventName | MinVR3",
    "keywords": "Class MouseAndKeyboard.KeyToVREventName Inheritance object MouseAndKeyboard.KeyToVREventName Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class MouseAndKeyboard.KeyToVREventName Constructors | Improve this Doc View Source KeyToVREventName(KeyCode, string) Declaration public KeyToVREventName(KeyCode keyCode, string baseEventName) Parameters Type Name Description KeyCode keyCode string baseEventName Fields | Improve this Doc View Source key Declaration [Tooltip(\"Code for the keyboard key to listen for.\")] public KeyCode key Field Value Type Description KeyCode | Improve this Doc View Source name Declaration [Tooltip(\"Base name for the VREvents generated when the key is pressed and released. The actual event names will also include an ' UP' or ' DOWN' suffix as appropriate.\")] public string name Field Value Type Description string"
  },
  "api/IVLab.MinVR3.MouseAndKeyboard.html": {
    "href": "api/IVLab.MinVR3.MouseAndKeyboard.html",
    "title": "Class MouseAndKeyboard | MinVR3",
    "keywords": "Class MouseAndKeyboard This class translates mouse and keyboard inputs from Unity to VREvents. It will work with either the new input system or the legacy input system. You can name the VREvents whatever you wish, and this can be a useful way to bind desktop-style input to the same events you expect to recieve when running in VR mode. Inheritance object Object Component Behaviour MonoBehaviour MouseAndKeyboard Implements IPolledInputDevice IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Input/Mouse & Keyboard\")] public class MouseAndKeyboard : MonoBehaviour, IPolledInputDevice, IVREventProducer Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source PollForEvents(ref List<VREvent>) Calling Poll adds to the queue any input events generated since the last call to poll. Declaration public void PollForEvents(ref List<VREvent> eventQueue) Parameters Type Name Description List<VREvent> eventQueue Implements IPolledInputDevice IVREventProducer"
  },
  "api/IVLab.MinVR3.MouseObjectManipulator.html": {
    "href": "api/IVLab.MinVR3.MouseObjectManipulator.html",
    "title": "Class MouseObjectManipulator | MinVR3",
    "keywords": "Class MouseObjectManipulator Implements a trackball rotate interaction for use with any GameObjects in the scene that have a Collider attached. When the mouse is clicked, a raycast is used to see if any object was picked. By default, this raycast will look at all objects in the scene that have colliders attached, but you can restrict it to a subset by assigning different layers to your gameobjects and including the layers to ignore in the ignoreLayers LayerMask. If the collider on the object selected by the mouse is not a sphere collider, then it is disabled immediately after the initial selection and a temporary sphere collider is added to object since the trackball effect requires intersecting with a bounding sphere. When the mouse button is released, the temporary collider is removed and the original is reenabled. Created by Dan, Morgan, & Sean 2/10/21 Inheritance object Object Component Behaviour MonoBehaviour MouseObjectManipulator Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Desktop/Mouse-Object Manipulator\")] public class MouseObjectManipulator : MonoBehaviour Fields | Improve this Doc View Source dollyButton Implements a trackball rotate interaction for use with any GameObjects in the scene that have a Collider attached. When the mouse is clicked, a raycast is used to see if any object was picked. By default, this raycast will look at all objects in the scene that have colliders attached, but you can restrict it to a subset by assigning different layers to your gameobjects and including the layers to ignore in the ignoreLayers LayerMask. If the collider on the object selected by the mouse is not a sphere collider, then it is disabled immediately after the initial selection and a temporary sphere collider is added to object since the trackball effect requires intersecting with a bounding sphere. When the mouse button is released, the temporary collider is removed and the original is reenabled. Created by Dan, Morgan, & Sean 2/10/21 Declaration [Tooltip(\"Click and drag with this button to translate the object in depth (in and out of the screen). [Default: Mouse Middle]\")] public KeyCode dollyButton Field Value Type Description KeyCode | Improve this Doc View Source layers Implements a trackball rotate interaction for use with any GameObjects in the scene that have a Collider attached. When the mouse is clicked, a raycast is used to see if any object was picked. By default, this raycast will look at all objects in the scene that have colliders attached, but you can restrict it to a subset by assigning different layers to your gameobjects and including the layers to ignore in the ignoreLayers LayerMask. If the collider on the object selected by the mouse is not a sphere collider, then it is disabled immediately after the initial selection and a temporary sphere collider is added to object since the trackball effect requires intersecting with a bounding sphere. When the mouse button is released, the temporary collider is removed and the original is reenabled. Created by Dan, Morgan, & Sean 2/10/21 Declaration [Tooltip(\"Layers to include when doing a Physics.Raycast to determine which collider(s) the mouse has clicked on.\")] public LayerMask layers Field Value Type Description LayerMask | Improve this Doc View Source rotateButton Implements a trackball rotate interaction for use with any GameObjects in the scene that have a Collider attached. When the mouse is clicked, a raycast is used to see if any object was picked. By default, this raycast will look at all objects in the scene that have colliders attached, but you can restrict it to a subset by assigning different layers to your gameobjects and including the layers to ignore in the ignoreLayers LayerMask. If the collider on the object selected by the mouse is not a sphere collider, then it is disabled immediately after the initial selection and a temporary sphere collider is added to object since the trackball effect requires intersecting with a bounding sphere. When the mouse button is released, the temporary collider is removed and the original is reenabled. Created by Dan, Morgan, & Sean 2/10/21 Declaration [Tooltip(\"Click and drag with this button to rotate an object. [Default: Mouse Right]\")] public KeyCode rotateButton Field Value Type Description KeyCode | Improve this Doc View Source translateButton Implements a trackball rotate interaction for use with any GameObjects in the scene that have a Collider attached. When the mouse is clicked, a raycast is used to see if any object was picked. By default, this raycast will look at all objects in the scene that have colliders attached, but you can restrict it to a subset by assigning different layers to your gameobjects and including the layers to ignore in the ignoreLayers LayerMask. If the collider on the object selected by the mouse is not a sphere collider, then it is disabled immediately after the initial selection and a temporary sphere collider is added to object since the trackball effect requires intersecting with a bounding sphere. When the mouse button is released, the temporary collider is removed and the original is reenabled. Created by Dan, Morgan, & Sean 2/10/21 Declaration [Tooltip(\"Click and drag with this button to translate the object at its current depth in a plane parallel to the filmplane. [Default: Mouse Left]\")] public KeyCode translateButton Field Value Type Description KeyCode"
  },
  "api/IVLab.MinVR3.MouseState.html": {
    "href": "api/IVLab.MinVR3.MouseState.html",
    "title": "Class MouseState | MinVR3",
    "keywords": "Class MouseState Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Inheritance object MouseState Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class MouseState Methods | Improve this Doc View Source LeftButtonIsPressed() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool LeftButtonIsPressed() Returns Type Description bool | Improve this Doc View Source LeftButtonWasPressedThisFrame() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool LeftButtonWasPressedThisFrame() Returns Type Description bool | Improve this Doc View Source LeftButtonWasReleasedThisFrame() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool LeftButtonWasReleasedThisFrame() Returns Type Description bool | Improve this Doc View Source MiddleButtonIsPressed() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool MiddleButtonIsPressed() Returns Type Description bool | Improve this Doc View Source MiddleButtonWasPressedThisFrame() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool MiddleButtonWasPressedThisFrame() Returns Type Description bool | Improve this Doc View Source MiddleButtonWasReleasedThisFrame() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool MiddleButtonWasReleasedThisFrame() Returns Type Description bool | Improve this Doc View Source Position() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static Vector2 Position() Returns Type Description Vector2 | Improve this Doc View Source RightButtonIsPressed() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool RightButtonIsPressed() Returns Type Description bool | Improve this Doc View Source RightButtonWasPressedThisFrame() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool RightButtonWasPressedThisFrame() Returns Type Description bool | Improve this Doc View Source RightButtonWasReleasedThisFrame() Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. Declaration public static bool RightButtonWasReleasedThisFrame() Returns Type Description bool"
  },
  "api/IVLab.MinVR3.NetUtils.html": {
    "href": "api/IVLab.MinVR3.NetUtils.html",
    "title": "Class NetUtils | MinVR3",
    "keywords": "Class NetUtils Inheritance object NetUtils Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class NetUtils Fields | Improve this Doc View Source INPUT_EVENTS_MSG Declaration public static readonly byte[] INPUT_EVENTS_MSG Field Value Type Description byte[] | Improve this Doc View Source SWAP_BUFFERS_NOW_MSG Declaration public static readonly byte[] SWAP_BUFFERS_NOW_MSG Field Value Type Description byte[] | Improve this Doc View Source SWAP_BUFFERS_REQUEST_MSG Declaration public static readonly byte[] SWAP_BUFFERS_REQUEST_MSG Field Value Type Description byte[] Methods | Improve this Doc View Source BrokenConnectionError(bool, string) Declaration public static void BrokenConnectionError(bool quit, string info = \"\") Parameters Type Name Description bool quit string info | Improve this Doc View Source CloseTcpClient(TcpClient, bool) Declaration public static void CloseTcpClient(TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError | Improve this Doc View Source ConnectToTcpServer(string, int) Block and keep trying to connect until the connection succeeds; quit after 1 minute of unsuccessful attempts. Declaration public static TcpClient ConnectToTcpServer(string serverIP, int serverPort) Parameters Type Name Description string serverIP int serverPort Returns Type Description TcpClient | Improve this Doc View Source ReadInt32(ref TcpClient, bool) Declaration public static int ReadInt32(ref TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError Returns Type Description int | Improve this Doc View Source ReadString(ref TcpClient, bool) Declaration public static string ReadString(ref TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError Returns Type Description string | Improve this Doc View Source ReadUInt32(ref TcpClient, bool) Declaration public static uint ReadUInt32(ref TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError Returns Type Description uint | Improve this Doc View Source ReceiveAll(ref TcpClient, ref byte[], int, bool) Declaration public static int ReceiveAll(ref TcpClient client, ref byte[] buf, int len, bool quitOnError) Parameters Type Name Description TcpClient client byte[] buf int len bool quitOnError Returns Type Description int | Improve this Doc View Source ReceiveEventAsJson(ref TcpClient, bool) Declaration public static VREvent ReceiveEventAsJson(ref TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError Returns Type Description VREvent | Improve this Doc View Source ReceiveEventData(ref TcpClient, ref List<VREvent>, bool) Declaration public static void ReceiveEventData(ref TcpClient client, ref List<VREvent> inputEvents, bool quitOnError) Parameters Type Name Description TcpClient client List<VREvent> inputEvents bool quitOnError | Improve this Doc View Source ReceiveOneByteMessage(ref TcpClient, byte[], bool) Declaration public static void ReceiveOneByteMessage(ref TcpClient client, byte[] message, bool quitOnError) Parameters Type Name Description TcpClient client byte[] message bool quitOnError | Improve this Doc View Source ReceiveSwapBuffersNow(ref TcpClient, bool) Declaration public static void ReceiveSwapBuffersNow(ref TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError | Improve this Doc View Source ReceiveSwapBuffersRequest(ref TcpClient, bool) Declaration public static void ReceiveSwapBuffersRequest(ref TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError | Improve this Doc View Source SendEventAsJson(ref TcpClient, in VREvent, bool) Declaration public static void SendEventAsJson(ref TcpClient client, in VREvent evt, bool quitOnError) Parameters Type Name Description TcpClient client VREvent evt bool quitOnError | Improve this Doc View Source SendEventData(ref TcpClient, in List<VREvent>, bool) Declaration public static void SendEventData(ref TcpClient client, in List<VREvent> inputEvents, bool quitOnError) Parameters Type Name Description TcpClient client List<VREvent> inputEvents bool quitOnError | Improve this Doc View Source SendOneByteMessage(ref TcpClient, byte[], bool) Declaration public static void SendOneByteMessage(ref TcpClient client, byte[] message, bool quitOnError) Parameters Type Name Description TcpClient client byte[] message bool quitOnError | Improve this Doc View Source SendSwapBuffersNow(ref TcpClient, bool) Declaration public static void SendSwapBuffersNow(ref TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError | Improve this Doc View Source SendSwapBuffersRequest(ref TcpClient, bool) Declaration public static void SendSwapBuffersRequest(ref TcpClient client, bool quitOnError) Parameters Type Name Description TcpClient client bool quitOnError | Improve this Doc View Source SwapEndianness(int) Declaration public static int SwapEndianness(int value) Parameters Type Name Description int value Returns Type Description int | Improve this Doc View Source SwapEndianness(uint) Declaration public static uint SwapEndianness(uint value) Parameters Type Name Description uint value Returns Type Description uint | Improve this Doc View Source TryConnectToTcpServer(string, int, out TcpClient) Try once to connect, catch and print any errors, and return true/false for success. Declaration public static bool TryConnectToTcpServer(string serverIP, int serverPort, out TcpClient client) Parameters Type Name Description string serverIP int serverPort TcpClient client Returns Type Description bool | Improve this Doc View Source WriteInt32(ref TcpClient, int, bool) Declaration public static void WriteInt32(ref TcpClient client, int i, bool quitOnError) Parameters Type Name Description TcpClient client int i bool quitOnError | Improve this Doc View Source WriteString(ref TcpClient, string, bool) Declaration public static void WriteString(ref TcpClient client, string s, bool quitOnError) Parameters Type Name Description TcpClient client string s bool quitOnError | Improve this Doc View Source WriteUInt32(ref TcpClient, uint, bool) Declaration public static void WriteUInt32(ref TcpClient client, uint i, bool quitOnError) Parameters Type Name Description TcpClient client uint i bool quitOnError"
  },
  "api/IVLab.MinVR3.OnVREventReceived.OnVREventReceivedDelegate.html": {
    "href": "api/IVLab.MinVR3.OnVREventReceived.OnVREventReceivedDelegate.html",
    "title": "Delegate OnVREventReceived.OnVREventReceivedDelegate | MinVR3",
    "keywords": "Delegate OnVREventReceived.OnVREventReceivedDelegate Delagate to define the structure for OnVREventReceived callbacks. Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public delegate void OnVREventReceived.OnVREventReceivedDelegate(VREvent evt) Parameters Type Name Description VREvent evt"
  },
  "api/IVLab.MinVR3.OnVREventReceived.html": {
    "href": "api/IVLab.MinVR3.OnVREventReceived.html",
    "title": "Class OnVREventReceived | MinVR3",
    "keywords": "Class OnVREventReceived Inheritance object OnVREventReceived Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class OnVREventReceived"
  },
  "api/IVLab.MinVR3.PrintFPS.html": {
    "href": "api/IVLab.MinVR3.PrintFPS.html",
    "title": "Class PrintFPS | MinVR3",
    "keywords": "Class PrintFPS Log the frames per second to the terminal Inheritance object Object Component Behaviour MonoBehaviour PrintFPS Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Debug/Print FPS\")] public class PrintFPS : MonoBehaviour Fields | Improve this Doc View Source logFrequency Log the frames per second to the terminal Declaration public float logFrequency Field Value Type Description float"
  },
  "api/IVLab.MinVR3.ProximityEventProducer.html": {
    "href": "api/IVLab.MinVR3.ProximityEventProducer.html",
    "title": "Class ProximityEventProducer | MinVR3",
    "keywords": "Class ProximityEventProducer Listens for two 3D position events (typically from VR trackers) and generates VREvents for when the two trackers are moved close together (i.e., in proximity to each other) and when they move apart. Inheritance object Object Component Behaviour MonoBehaviour ProximityEventProducer Implements IVREventListener IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Input/Proximity Event Producer\")] public class ProximityEventProducer : MonoBehaviour, IVREventListener, IVREventProducer Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source OnVREvent(VREvent) Listens for two 3D position events (typically from VR trackers) and generates VREvents for when the two trackers are moved close together (i.e., in proximity to each other) and when they move apart. Declaration public void OnVREvent(VREvent e) Parameters Type Name Description VREvent e | Improve this Doc View Source StartListening() Listens for two 3D position events (typically from VR trackers) and generates VREvents for when the two trackers are moved close together (i.e., in proximity to each other) and when they move apart. Declaration public void StartListening() | Improve this Doc View Source StopListening() Listens for two 3D position events (typically from VR trackers) and generates VREvents for when the two trackers are moved close together (i.e., in proximity to each other) and when they move apart. Declaration public void StopListening() Implements IVREventListener IVREventProducer"
  },
  "api/IVLab.MinVR3.QuitOnEscapeKey.html": {
    "href": "api/IVLab.MinVR3.QuitOnEscapeKey.html",
    "title": "Class QuitOnEscapeKey | MinVR3",
    "keywords": "Class QuitOnEscapeKey Inheritance object Object Component Behaviour MonoBehaviour QuitOnEscapeKey Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class QuitOnEscapeKey : MonoBehaviour"
  },
  "api/IVLab.MinVR3.RoomSpaceOrigin.html": {
    "href": "api/IVLab.MinVR3.RoomSpaceOrigin.html",
    "title": "Class RoomSpaceOrigin | MinVR3",
    "keywords": "Class RoomSpaceOrigin Inheritance object Object Component Behaviour MonoBehaviour RoomSpaceOrigin Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class RoomSpaceOrigin : MonoBehaviour Methods | Improve this Doc View Source RoomDirectionToWorldSpace(Vector3) Declaration public Vector3 RoomDirectionToWorldSpace(Vector3 roomDirection) Parameters Type Name Description Vector3 roomDirection Returns Type Description Vector3 | Improve this Doc View Source RoomPointToWorldSpace(Vector3) Declaration public Vector3 RoomPointToWorldSpace(Vector3 roomPoint) Parameters Type Name Description Vector3 roomPoint Returns Type Description Vector3 | Improve this Doc View Source RoomVectorToWorldSpace(Vector3) Declaration public Vector3 RoomVectorToWorldSpace(Vector3 roomVector) Parameters Type Name Description Vector3 roomVector Returns Type Description Vector3 | Improve this Doc View Source WorldDirectionToRoomSpace(Vector3) Declaration public Vector3 WorldDirectionToRoomSpace(Vector3 worldDirection) Parameters Type Name Description Vector3 worldDirection Returns Type Description Vector3 | Improve this Doc View Source WorldPointToRoomSpace(Vector3) Declaration public Vector3 WorldPointToRoomSpace(Vector3 worldPoint) Parameters Type Name Description Vector3 worldPoint Returns Type Description Vector3 | Improve this Doc View Source WorldVectorToRoomSpace(Vector3) Declaration public Vector3 WorldVectorToRoomSpace(Vector3 worldVector) Parameters Type Name Description Vector3 worldVector Returns Type Description Vector3"
  },
  "api/IVLab.MinVR3.SharedToken.html": {
    "href": "api/IVLab.MinVR3.SharedToken.html",
    "title": "Class SharedToken | MinVR3",
    "keywords": "Class SharedToken Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Inheritance object Object Component Behaviour MonoBehaviour SharedToken Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Building Blocks/Shared Token\")] public class SharedToken : MonoBehaviour Properties | Improve this Doc View Source currentOwner Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Declaration public MonoBehaviour currentOwner { get; } Property Value Type Description MonoBehaviour | Improve this Doc View Source tokenName Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Declaration public string tokenName { get; set; } Property Value Type Description string Methods | Improve this Doc View Source AddAvailabilityListener(UnityAction<bool>) Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Declaration public void AddAvailabilityListener(UnityAction<bool> callback) Parameters Type Name Description UnityAction<bool> callback | Improve this Doc View Source ForceRequestToken(MonoBehaviour) Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Declaration public void ForceRequestToken(MonoBehaviour requester) Parameters Type Name Description MonoBehaviour requester | Improve this Doc View Source HasToken(MonoBehaviour) Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Declaration public bool HasToken(MonoBehaviour possibleOwner) Parameters Type Name Description MonoBehaviour possibleOwner Returns Type Description bool | Improve this Doc View Source ReleaseToken(MonoBehaviour) Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Declaration public bool ReleaseToken(MonoBehaviour owner) Parameters Type Name Description MonoBehaviour owner Returns Type Description bool | Improve this Doc View Source RemoveAvailabilityListener(UnityAction<bool>) Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Declaration public void RemoveAvailabilityListener(UnityAction<bool> callback) Parameters Type Name Description UnityAction<bool> callback | Improve this Doc View Source RequestToken(MonoBehaviour) Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. Declaration public bool RequestToken(MonoBehaviour requester) Parameters Type Name Description MonoBehaviour requester Returns Type Description bool"
  },
  "api/IVLab.MinVR3.SimpleEventListener.html": {
    "href": "api/IVLab.MinVR3.SimpleEventListener.html",
    "title": "Class SimpleEventListener | MinVR3",
    "keywords": "Class SimpleEventListener Inheritance object Object Component Behaviour MonoBehaviour SimpleEventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Building Blocks/Simple Event Listener\")] public class SimpleEventListener : MonoBehaviour Properties | Improve this Doc View Source onVREvent Declaration public VREventCallbackAny onVREvent { get; set; } Property Value Type Description VREventCallbackAny"
  },
  "api/IVLab.MinVR3.SimplePlaySoundOnVREvent.html": {
    "href": "api/IVLab.MinVR3.SimplePlaySoundOnVREvent.html",
    "title": "Class SimplePlaySoundOnVREvent | MinVR3",
    "keywords": "Class SimplePlaySoundOnVREvent Inheritance object Object Component Behaviour MonoBehaviour SimplePlaySoundOnVREvent Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [RequireComponent(typeof(SpatialAudioClient))] public class SimplePlaySoundOnVREvent : MonoBehaviour, IVREventListener Fields | Improve this Doc View Source playSoundOnVREvent Declaration [SerializeField] [Tooltip(\"Play the sound file when THIS VREvent is received\")] public VREventPrototypeAny playSoundOnVREvent Field Value Type Description VREventPrototypeAny | Improve this Doc View Source soundFileName Declaration [SerializeField] [Tooltip(\"Name of the sound file to play (MUST exist on Sound Server)\")] public string soundFileName Field Value Type Description string Methods | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent evt) Parameters Type Name Description VREvent evt | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.Singleton-1.html": {
    "href": "api/IVLab.MinVR3.Singleton-1.html",
    "title": "Class Singleton<T> | MinVR3",
    "keywords": "Class Singleton<T> Inherit from this base class to create a singleton. Several flavors of singleton are possible to implement in Unity. This singleton persists across scene loads/unloads. It also inherits from MonoBehaviour, so your class can implememnt the typical Start(), Update(), and other MonoBehaviour methods. When you access MyClassName.Instance from a script, the singleton instance of MyClassName will be created \"on demand\" and added to the scene hierarchy in the DontDestroyOnLoad section. Alternatively, if you prefer to have MyClassName visible in the editor, you can attach your MyClassName script to a GameObject in your scene. However, you should only do this in one place in your scene (otherwise it will not be a singleton). An assertion will fire if two or more MyClassName objects are found in the scene. Also, to remain persistent across scene loads, the Unity imposes a constraing that the GameObject your MyClassName script is attached to must be placed in the root of the hierarchy. This example shows how to create a script that inherets from Singleton. Inheritance object Object Component Behaviour MonoBehaviour Singleton<T> VREngine Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class Singleton<T> : MonoBehaviour where T : MonoBehaviour Type Parameters Name Description T Examples public class MyClassName : Singleton<MyClassName> { } // MyClassName will now be a \"Singleton\" and can be accessed via .Instance or .GetInstance() public class Testing : MonoBehaviour { void Start() { Debug.Log(MyClassName.Instance.GetHashCode()); } } Properties | Improve this Doc View Source Instance Access singleton instance through this propriety. Note: Both uppercase \"Instance\" and lowercase \"instance\" accessors are provided to support projects that follow typical C# style guidelines where properties begin with an uppercase letter and the style of Unity's API, where all properties begin with lowercase letters. Declaration public static T Instance { get; } Property Value Type Description T | Improve this Doc View Source instance Access singleton instance through this propriety. Note: Both uppercase \"Instance\" and lowercase \"instance\" accessors are provided to support projects that follow typical C# style guidelines where properties begin with an uppercase letter and the style of Unity's API, where all properties begin with lowercase letters. Declaration public static T instance { get; } Property Value Type Description T Methods | Improve this Doc View Source Awake() Inherit from this base class to create a singleton. Several flavors of singleton are possible to implement in Unity. This singleton persists across scene loads/unloads. It also inherits from MonoBehaviour, so your class can implememnt the typical Start(), Update(), and other MonoBehaviour methods. When you access MyClassName.Instance from a script, the singleton instance of MyClassName will be created \"on demand\" and added to the scene hierarchy in the DontDestroyOnLoad section. Alternatively, if you prefer to have MyClassName visible in the editor, you can attach your MyClassName script to a GameObject in your scene. However, you should only do this in one place in your scene (otherwise it will not be a singleton). An assertion will fire if two or more MyClassName objects are found in the scene. Also, to remain persistent across scene loads, the Unity imposes a constraing that the GameObject your MyClassName script is attached to must be placed in the root of the hierarchy. This example shows how to create a script that inherets from Singleton. Declaration protected virtual void Awake() Examples public class MyClassName : Singleton<MyClassName> { } // MyClassName will now be a \"Singleton\" and can be accessed via .Instance or .GetInstance() public class Testing : MonoBehaviour { void Start() { Debug.Log(MyClassName.Instance.GetHashCode()); } } | Improve this Doc View Source GetInstance() Inherit from this base class to create a singleton. Several flavors of singleton are possible to implement in Unity. This singleton persists across scene loads/unloads. It also inherits from MonoBehaviour, so your class can implememnt the typical Start(), Update(), and other MonoBehaviour methods. When you access MyClassName.Instance from a script, the singleton instance of MyClassName will be created \"on demand\" and added to the scene hierarchy in the DontDestroyOnLoad section. Alternatively, if you prefer to have MyClassName visible in the editor, you can attach your MyClassName script to a GameObject in your scene. However, you should only do this in one place in your scene (otherwise it will not be a singleton). An assertion will fire if two or more MyClassName objects are found in the scene. Also, to remain persistent across scene loads, the Unity imposes a constraing that the GameObject your MyClassName script is attached to must be placed in the root of the hierarchy. This example shows how to create a script that inherets from Singleton. Declaration public static T GetInstance() Returns Type Description T Examples public class MyClassName : Singleton<MyClassName> { } // MyClassName will now be a \"Singleton\" and can be accessed via .Instance or .GetInstance() public class Testing : MonoBehaviour { void Start() { Debug.Log(MyClassName.Instance.GetHashCode()); } }"
  },
  "api/IVLab.MinVR3.SmartScene.html": {
    "href": "api/IVLab.MinVR3.SmartScene.html",
    "title": "Class SmartScene | MinVR3",
    "keywords": "Class SmartScene Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s Inheritance object Object Component Behaviour MonoBehaviour SmartScene Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Navigation & Manipulation/SmartScene\")] public class SmartScene : MonoBehaviour Methods | Improve this Doc View Source Awake() Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s Declaration public void Awake() | Improve this Doc View Source InitManipulation() Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s Declaration public void InitManipulation() | Improve this Doc View Source OneHandMove(int, Vector3) Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s Declaration public void OneHandMove(int cursorID, Vector3 pos) Parameters Type Name Description int cursorID Vector3 pos | Improve this Doc View Source Reset() Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s Declaration public void Reset() | Improve this Doc View Source RoomToWorld(Vector3) Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s Declaration public Vector3 RoomToWorld(Vector3 roomPoint) Parameters Type Name Description Vector3 roomPoint Returns Type Description Vector3 | Improve this Doc View Source TwoHandMove(int, Vector3) Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s Declaration public void TwoHandMove(int cursorID, Vector3 pos) Parameters Type Name Description int cursorID Vector3 pos | Improve this Doc View Source WorldToLocal(Vector3, Transform) Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s Declaration public Vector3 WorldToLocal(Vector3 worldPoint, Transform localFrame) Parameters Type Name Description Vector3 worldPoint Transform localFrame Returns Type Description Vector3"
  },
  "api/IVLab.MinVR3.SpatialAudioClient.html": {
    "href": "api/IVLab.MinVR3.SpatialAudioClient.html",
    "title": "Class SpatialAudioClient | MinVR3",
    "keywords": "Class SpatialAudioClient Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Inheritance object Object Component Behaviour MonoBehaviour SpatialAudioClient Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR3/Audio/Spatial Audio Client\")] [DefaultExecutionOrder(-899)] public class SpatialAudioClient : MonoBehaviour Fields | Improve this Doc View Source ScriptPriority Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public const int ScriptPriority = -899 Field Value Type Description int | Improve this Doc View Source outputCoordSystem Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration [SerializeField] [Tooltip(\"Coordinate system to output sound coordinates to\")] public CoordConversion.CoordSystem outputCoordSystem Field Value Type Description CoordConversion.CoordSystem | Improve this Doc View Source resetServerOnStartup Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration [SerializeField] [Tooltip(\"Reset the audio server on startup\")] public bool resetServerOnStartup Field Value Type Description bool | Improve this Doc View Source serverAddress Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration [SerializeField] [Tooltip(\"Spatial audio server address to connect to (sound_server.py)\")] public string serverAddress Field Value Type Description string Properties | Improve this Doc View Source Initialized Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public bool Initialized { get; } Property Value Type Description bool Methods | Improve this Doc View Source Awake() Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration protected void Awake() | Improve this Doc View Source CreateSource(int, string) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void CreateSource(int sourceID, string soundFile) Parameters Type Name Description int sourceID string soundFile | Improve this Doc View Source CreateSource(int, string, Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void CreateSource(int sourceID, string soundFile, Vector3 position) Parameters Type Name Description int sourceID string soundFile Vector3 position | Improve this Doc View Source CreateSource(int, string, Vector3, bool) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void CreateSource(int sourceID, string soundFile, Vector3 position, bool looping) Parameters Type Name Description int sourceID string soundFile Vector3 position bool looping | Improve this Doc View Source DeleteSource(int) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void DeleteSource(int sourceID) Parameters Type Name Description int sourceID | Improve this Doc View Source LoopSimple(string) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void LoopSimple(string soundFile) Parameters Type Name Description string soundFile | Improve this Doc View Source PauseSource(int) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void PauseSource(int sourceID) Parameters Type Name Description int sourceID | Improve this Doc View Source PlaySimple(string) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void PlaySimple(string soundFile) Parameters Type Name Description string soundFile | Improve this Doc View Source PlaySource(int) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void PlaySource(int sourceID) Parameters Type Name Description int sourceID | Improve this Doc View Source ResetAudio() Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void ResetAudio() | Improve this Doc View Source RewindSource(int) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void RewindSource(int sourceID) Parameters Type Name Description int sourceID | Improve this Doc View Source SetListenerFront(Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetListenerFront(Vector3 v) Parameters Type Name Description Vector3 v | Improve this Doc View Source SetListenerGain(float) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetListenerGain(float g) Parameters Type Name Description float g | Improve this Doc View Source SetListenerPosition(Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetListenerPosition(Vector3 v) Parameters Type Name Description Vector3 v | Improve this Doc View Source SetListenerUp(Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetListenerUp(Vector3 v) Parameters Type Name Description Vector3 v | Improve this Doc View Source SetListenerVelocity(Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetListenerVelocity(Vector3 v) Parameters Type Name Description Vector3 v | Improve this Doc View Source SetSourceDirection(int, Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetSourceDirection(int sourceID, Vector3 v) Parameters Type Name Description int sourceID Vector3 v | Improve this Doc View Source SetSourceFront(int, Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetSourceFront(int sourceID, Vector3 v) Parameters Type Name Description int sourceID Vector3 v | Improve this Doc View Source SetSourceGain(int, float) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetSourceGain(int sourceID, float g) Parameters Type Name Description int sourceID float g | Improve this Doc View Source SetSourceLooping(int, bool) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetSourceLooping(int sourceID, bool l) Parameters Type Name Description int sourceID bool l | Improve this Doc View Source SetSourcePitch(int, float) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetSourcePitch(int sourceID, float p) Parameters Type Name Description int sourceID float p | Improve this Doc View Source SetSourcePosition(int, Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetSourcePosition(int sourceID, Vector3 v) Parameters Type Name Description int sourceID Vector3 v | Improve this Doc View Source SetSourceUp(int, Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetSourceUp(int sourceID, Vector3 v) Parameters Type Name Description int sourceID Vector3 v | Improve this Doc View Source SetSourceVelocity(int, Vector3) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void SetSourceVelocity(int sourceID, Vector3 v) Parameters Type Name Description int sourceID Vector3 v | Improve this Doc View Source StopAllSimple() Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void StopAllSimple() | Improve this Doc View Source StopSimple(string) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void StopSimple(string soundFile) Parameters Type Name Description string soundFile | Improve this Doc View Source StopSource(int) Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public void StopSource(int sourceID) Parameters Type Name Description int sourceID | Improve this Doc View Source WaitForInitialized() Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. Declaration public Task WaitForInitialized() Returns Type Description Task"
  },
  "api/IVLab.MinVR3.SpatialPlaySoundOnVREvent.html": {
    "href": "api/IVLab.MinVR3.SpatialPlaySoundOnVREvent.html",
    "title": "Class SpatialPlaySoundOnVREvent | MinVR3",
    "keywords": "Class SpatialPlaySoundOnVREvent Inheritance object Object Component Behaviour MonoBehaviour SpatialPlaySoundOnVREvent Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [DefaultExecutionOrder(-900)] [RequireComponent(typeof(SpatialAudioClient))] public class SpatialPlaySoundOnVREvent : MonoBehaviour, IVREventListener Fields | Improve this Doc View Source listenerPositionVREvent Declaration [SerializeField] [Tooltip(\"Position the listener based on these events\")] public VREventPrototypeVector3 listenerPositionVREvent Field Value Type Description VREventPrototypeVector3 | Improve this Doc View Source playSoundOnVREvent Declaration [SerializeField] [Tooltip(\"Play the sound file when THIS VREvent is received\")] public VREventPrototypeAny playSoundOnVREvent Field Value Type Description VREventPrototypeAny | Improve this Doc View Source soundFileName Declaration [SerializeField] [Tooltip(\"Name of the sound file to play (MUST exist on Sound Server)\")] public string soundFileName Field Value Type Description string | Improve this Doc View Source sourcePositionVREvent Declaration [SerializeField] [Tooltip(\"Position the source based on these events\")] public VREventPrototypeVector3 sourcePositionVREvent Field Value Type Description VREventPrototypeVector3 Methods | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent evt) Parameters Type Name Description VREvent evt | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.SphereMove.html": {
    "href": "api/IVLab.MinVR3.SphereMove.html",
    "title": "Class SphereMove | MinVR3",
    "keywords": "Class SphereMove Inheritance object Object Component Behaviour MonoBehaviour SphereMove Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class SphereMove : MonoBehaviour, IVREventListener Fields | Improve this Doc View Source distanceMultiplier Declaration public int distanceMultiplier Field Value Type Description int | Improve this Doc View Source movingSphereA Declaration public GameObject movingSphereA Field Value Type Description GameObject | Improve this Doc View Source movingSphereB Declaration public GameObject movingSphereB Field Value Type Description GameObject | Improve this Doc View Source touchDownEventA Declaration public VREventPrototypeVector2 touchDownEventA Field Value Type Description VREventPrototypeVector2 | Improve this Doc View Source touchDownEventB Declaration public VREventPrototypeVector2 touchDownEventB Field Value Type Description VREventPrototypeVector2 | Improve this Doc View Source touchMoveEventA Declaration public VREventPrototypeVector2 touchMoveEventA Field Value Type Description VREventPrototypeVector2 | Improve this Doc View Source touchMoveEventB Declaration public VREventPrototypeVector2 touchMoveEventB Field Value Type Description VREventPrototypeVector2 | Improve this Doc View Source touchUpEventA Declaration public VREventPrototypeVector2 touchUpEventA Field Value Type Description VREventPrototypeVector2 | Improve this Doc View Source touchUpEventB Declaration public VREventPrototypeVector2 touchUpEventB Field Value Type Description VREventPrototypeVector2 Methods | Improve this Doc View Source CalculateAngleBetweenPoints() Declaration public void CalculateAngleBetweenPoints() | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.SphericalCoordinate.html": {
    "href": "api/IVLab.MinVR3.SphericalCoordinate.html",
    "title": "Class SphericalCoordinate | MinVR3",
    "keywords": "Class SphericalCoordinate A tiny class to hold the spherical coordinates for a point, used primarily for working with planetarium domes -- see SphericalDome.cs. Inheritance object SphericalCoordinate Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class SphericalCoordinate Constructors | Improve this Doc View Source SphericalCoordinate() A tiny class to hold the spherical coordinates for a point, used primarily for working with planetarium domes -- see SphericalDome.cs. Declaration public SphericalCoordinate() | Improve this Doc View Source SphericalCoordinate(float, float, float) A tiny class to hold the spherical coordinates for a point, used primarily for working with planetarium domes -- see SphericalDome.cs. Declaration public SphericalCoordinate(float radialDist, float polarAngleInDeg, float azimuthalAngleInDeg) Parameters Type Name Description float radialDist float polarAngleInDeg float azimuthalAngleInDeg Fields | Improve this Doc View Source azimuthalAngleInDeg A tiny class to hold the spherical coordinates for a point, used primarily for working with planetarium domes -- see SphericalDome.cs. Declaration public float azimuthalAngleInDeg Field Value Type Description float | Improve this Doc View Source polarAngleInDeg A tiny class to hold the spherical coordinates for a point, used primarily for working with planetarium domes -- see SphericalDome.cs. Declaration public float polarAngleInDeg Field Value Type Description float | Improve this Doc View Source radialDist A tiny class to hold the spherical coordinates for a point, used primarily for working with planetarium domes -- see SphericalDome.cs. Declaration public float radialDist Field Value Type Description float"
  },
  "api/IVLab.MinVR3.SphericalDome.html": {
    "href": "api/IVLab.MinVR3.SphericalDome.html",
    "title": "Class SphericalDome | MinVR3",
    "keywords": "Class SphericalDome A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Inheritance object Object Component Behaviour MonoBehaviour SphericalDome Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [ExecuteAlways] public class SphericalDome : MonoBehaviour Fields | Improve this Doc View Source m_DebugLinesMaterial A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration [Tooltip(\"The material for the lines, Unity's default material is used.\")] [SerializeField] public Material m_DebugLinesMaterial Field Value Type Description Material Properties | Improve this Doc View Source domeRadius Radius of the spherical dome (in meters) Declaration public float domeRadius { get; set; } Property Value Type Description float | Improve this Doc View Source domeViewAngle 180 degrees if the dome is a full hemisphere; otherwise the total angle covered by the projection (in degrees), i.e., two times the polar angle from zenith down to the bottom edge of the projection. Declaration public float domeViewAngle { get; set; } Property Value Type Description float | Improve this Doc View Source forward The dome's forward direction in Dome Space coordinates. (See documentation at the top of the class for more description.) Declaration public Vector3 forward { get; } Property Value Type Description Vector3 | Improve this Doc View Source maxPolarAngleInView In the dome's spherical coordinate system, the polar angle is measured from the zenith direction, which points straight up toward the center point of the dome. This is the maximum polar angle that can be displayed on the dome, i.e., graphics positioned at this angle will be drawn right on the edge of the spherical dome, any greater angle will make the graphics fall \"off the screen\". Declaration public float maxPolarAngleInView { get; } Property Value Type Description float | Improve this Doc View Source zenith A spherical dome is like taking a ball and cutting through it with a plane, leaving a cap. The zenith direction points from the center of the original ball to the center point on the cap. If we think of being inside a big ball and taking a slice through the ball that is parallel to the \"ground\", then the zenith direction is straight up. However, if we then rotate the cap by, say, 15 degrees around the X-axis, as is often done in a planetarium with stadium seating, the zenith will be tilted in the same way. Put another way, the zenith will always point from the center of the sphere toward the center of the projection screen. In \"dome space\", this will always be the Up vector, but if the dome is tilted, that means \"dome space\" is rotated relative to the physical \"room space\". In this case, the zenith will not be the same as the \"room space\" Up vector. Declaration public Vector3 zenith { get; } Property Value Type Description Vector3 Methods | Improve this Doc View Source CenterInWorldSpace() A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 CenterInWorldSpace() Returns Type Description Vector3 | Improve this Doc View Source ClosestPointOnDome(Vector3) Given a Dome Space point, p, that does not necessarily lie on the surface of the Dome, returns the closest point to p that is on the visible, projection-screen surface of the dome. Declaration public Vector3 ClosestPointOnDome(Vector3 p) Parameters Type Name Description Vector3 p Returns Type Description Vector3 | Improve this Doc View Source ClosestPointOnSphere(Vector3) Given a Dome Space point, p, that does not necessarily lie on the surface of the Dome's, sphere, returns the closest point to p that is on the surface of the sphere. Declaration public Vector3 ClosestPointOnSphere(Vector3 p) Parameters Type Name Description Vector3 p Returns Type Description Vector3 | Improve this Doc View Source DomeDirectionToRoomSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 DomeDirectionToRoomSpace(Vector3 domeDirection) Parameters Type Name Description Vector3 domeDirection Returns Type Description Vector3 | Improve this Doc View Source DomeDirectionToWorldSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 DomeDirectionToWorldSpace(Vector3 domeDirection) Parameters Type Name Description Vector3 domeDirection Returns Type Description Vector3 | Improve this Doc View Source DomePointToRoomSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 DomePointToRoomSpace(Vector3 domePoint) Parameters Type Name Description Vector3 domePoint Returns Type Description Vector3 | Improve this Doc View Source DomePointToWorldSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 DomePointToWorldSpace(Vector3 domePoint) Parameters Type Name Description Vector3 domePoint Returns Type Description Vector3 | Improve this Doc View Source DomeVectorToRoomSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 DomeVectorToRoomSpace(Vector3 domeVector) Parameters Type Name Description Vector3 domeVector Returns Type Description Vector3 | Improve this Doc View Source DomeVectorToWorldSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 DomeVectorToWorldSpace(Vector3 domeVector) Parameters Type Name Description Vector3 domeVector Returns Type Description Vector3 | Improve this Doc View Source InwardFacingRotation(float, float) Returns the rotation that will orient a GameObject on the surface of the dome so that the GameObject's forward direction (it's local +Z) faces away from the center of the dome sphere and the GameObject's up direction (it's local +Y) faces as close to the zenith as possible. Declaration public Quaternion InwardFacingRotation(float polarAngleInDeg, float azimuthalAngleInDeg) Parameters Type Name Description float polarAngleInDeg float azimuthalAngleInDeg Returns Type Description Quaternion | Improve this Doc View Source InwardFacingRotation(Vector3) Returns the rotation that will orient a GameObject on the surface of the dome so that the GameObject's forward direction (it's local +Z) faces away from the center of the dome sphere and the GameObject's up direction (it's local +Y) faces as close to the zenith as possible. Declaration public Quaternion InwardFacingRotation(Vector3 pointInDomeSpace) Parameters Type Name Description Vector3 pointInDomeSpace Returns Type Description Quaternion | Improve this Doc View Source IsPointInsideDome(Vector3) Recall, the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. This function returns true if the point would lie anywhere inside the portion of the sphere that was sliced by the plane to form the spherical cap. Declaration public bool IsPointInsideDome(Vector3 pointInDomeSpace) Parameters Type Name Description Vector3 pointInDomeSpace Returns Type Description bool | Improve this Doc View Source IsPointInsideSphere(Vector3) Recall, the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. This function returns true if the point would lie anywhere inside the original sphere before it was sliced. Declaration public bool IsPointInsideSphere(Vector3 pointInDomeSpace) Parameters Type Name Description Vector3 pointInDomeSpace Returns Type Description bool | Improve this Doc View Source PointOnDome(float, float) If the polarAngleInDeg is less than the maxPolarAngleInView, returns the Dome Space rectangular coordinates for the point on the dome's surface uniquely defined by the two angles and the dome's radius. Otherwise, the polarAngleInDeg is clamped to the maximum value, and the closet point that is actually visible on the dome's screen is returned. Declaration public Vector3 PointOnDome(float polarAngleInDeg, float azimuthalAngleInDeg) Parameters Type Name Description float polarAngleInDeg float azimuthalAngleInDeg Returns Type Description Vector3 | Improve this Doc View Source PointOnSphere(float, float) Returns the Dome Space rectangular coordinates for the point on the dome sphere's surface uniquely defined by the two angles and the dome's radius. Note, if the polar angle is greater than the max polar angle in view, the point will like on the dome's sphere, but will not be visible on the dome. Declaration public Vector3 PointOnSphere(float polarAngleInDeg, float azimuthalAngleInDeg) Parameters Type Name Description float polarAngleInDeg float azimuthalAngleInDeg Returns Type Description Vector3 | Improve this Doc View Source RandomPointOnDome() Returns a random point on the surface of the dome. Declaration public Vector3 RandomPointOnDome() Returns Type Description Vector3 | Improve this Doc View Source RectangularPointToSpherical(Vector3) Converts points in Dome Space rectangular coordinates to Dome Space spherical coordinates. Declaration public SphericalCoordinate RectangularPointToSpherical(Vector3 rPoint) Parameters Type Name Description Vector3 rPoint Returns Type Description SphericalCoordinate | Improve this Doc View Source RoomDirectionToDomeSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 RoomDirectionToDomeSpace(Vector3 roomDirection) Parameters Type Name Description Vector3 roomDirection Returns Type Description Vector3 | Improve this Doc View Source RoomPointToDomeSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 RoomPointToDomeSpace(Vector3 roomPoint) Parameters Type Name Description Vector3 roomPoint Returns Type Description Vector3 | Improve this Doc View Source RoomVectorToDomeSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 RoomVectorToDomeSpace(Vector3 roomVector) Parameters Type Name Description Vector3 roomVector Returns Type Description Vector3 | Improve this Doc View Source SphericalPointToRectangular(SphericalCoordinate) Converts points in Dome Space spherical coordinates to Dome Space rectangular coordinates. Declaration public Vector3 SphericalPointToRectangular(SphericalCoordinate sPoint) Parameters Type Name Description SphericalCoordinate sPoint Returns Type Description Vector3 | Improve this Doc View Source WorldDirectionToDomeSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 WorldDirectionToDomeSpace(Vector3 worldDirection) Parameters Type Name Description Vector3 worldDirection Returns Type Description Vector3 | Improve this Doc View Source WorldPointToDomeSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 WorldPointToDomeSpace(Vector3 worldPoint) Parameters Type Name Description Vector3 worldPoint Returns Type Description Vector3 | Improve this Doc View Source WorldVectorToDomeSpace(Vector3) A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; Declaration public Vector3 WorldVectorToDomeSpace(Vector3 worldVector) Parameters Type Name Description Vector3 worldVector Returns Type Description Vector3"
  },
  "api/IVLab.MinVR3.TcpJsonVREventConnection.html": {
    "href": "api/IVLab.MinVR3.TcpJsonVREventConnection.html",
    "title": "Class TcpJsonVREventConnection | MinVR3",
    "keywords": "Class TcpJsonVREventConnection This class uses Tcp sockets to implement the IVREventConnection interface with Json serialization of events. Inheritance object Object Component Behaviour MonoBehaviour TcpJsonVREventConnection Implements IVREventConnection Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Connection/TcpJsonVREventConnection\")] public class TcpJsonVREventConnection : MonoBehaviour, IVREventConnection Properties | Improve this Doc View Source OnVREventReceived Subscribe to OnVREventReceived to recieve a callback whenever a VREvent is received over the network \"connection\", Declaration public OnVREventReceived.OnVREventReceivedDelegate OnVREventReceived { get; set; } Property Value Type Description OnVREventReceived.OnVREventReceivedDelegate Methods | Improve this Doc View Source CanReceive() Returns true if the VREventConnection supports receiving VREvents. Declaration public bool CanReceive() Returns Type Description bool | Improve this Doc View Source CanSend() Returns true if the VREventConnection supports sending VREvents. Declaration public bool CanSend() Returns Type Description bool | Improve this Doc View Source Send(in VREvent) Send a VR event to the other end of this \"connection\" Declaration public void Send(in VREvent evt) Parameters Type Name Description VREvent evt Implements IVREventConnection"
  },
  "api/IVLab.MinVR3.TcpVREventConnection.html": {
    "href": "api/IVLab.MinVR3.TcpVREventConnection.html",
    "title": "Class TcpVREventConnection | MinVR3",
    "keywords": "Class TcpVREventConnection This class uses Tcp sockets to implement the IVREventConnection interface with C# binary serialization of events. This style of serialization is not particularly portable -- i.e., it requires the other end of the connection to also be implemented using C# binary serialization. Use the TcpJsonVREventConnection instead when there is a need to connect to a server written in some other language. Inheritance object Object Component Behaviour MonoBehaviour TcpVREventConnection Implements IVREventConnection Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Connection/TcpVREventConnection\")] public class TcpVREventConnection : MonoBehaviour, IVREventConnection Properties | Improve this Doc View Source OnVREventReceived Subscribe to OnVREventReceived to recieve a callback whenever a VREvent is received over the network \"connection\", Declaration public OnVREventReceived.OnVREventReceivedDelegate OnVREventReceived { get; set; } Property Value Type Description OnVREventReceived.OnVREventReceivedDelegate Methods | Improve this Doc View Source CanReceive() Returns true if the VREventConnection supports receiving VREvents. Declaration public bool CanReceive() Returns Type Description bool | Improve this Doc View Source CanSend() Returns true if the VREventConnection supports sending VREvents. Declaration public bool CanSend() Returns Type Description bool | Improve this Doc View Source Send(in VREvent) Send a VR event to the other end of this \"connection\" Declaration public void Send(in VREvent evt) Parameters Type Name Description VREvent evt Implements IVREventConnection"
  },
  "api/IVLab.MinVR3.TestSpatialAudio.html": {
    "href": "api/IVLab.MinVR3.TestSpatialAudio.html",
    "title": "Class TestSpatialAudio | MinVR3",
    "keywords": "Class TestSpatialAudio Inheritance object Object Component Behaviour MonoBehaviour TestSpatialAudio Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [RequireComponent(typeof(SpatialAudioClient))] public class TestSpatialAudio : MonoBehaviour Fields | Improve this Doc View Source testOnStart Declaration public bool testOnStart Field Value Type Description bool Methods | Improve this Doc View Source TestAudio() Declaration public void TestAudio()"
  },
  "api/IVLab.MinVR3.TouchBuiltin.html": {
    "href": "api/IVLab.MinVR3.TouchBuiltin.html",
    "title": "Class TouchBuiltin | MinVR3",
    "keywords": "Class TouchBuiltin Converts touch events from Unity's built-in touch system to VREvents. Inheritance object Object Component Behaviour MonoBehaviour TouchBuiltin Implements IPolledInputDevice IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Input/Touch (Unity Built-in Sensing)\")] public class TouchBuiltin : MonoBehaviour, IPolledInputDevice, IVREventProducer Fields | Improve this Doc View Source m_BaseEventNames Converts touch events from Unity's built-in touch system to VREvents. Declaration [Tooltip(\"Similar to the way you can assign a custom VREvent name to a keyboard keypress event, you can also customize the touch event names. To remap every possible event, the size of the array should equal the max number of simultaneous touches supported by the hardware. A default name will be used if the array does not contain enough entries. Indices are reused and most systems have no way of telling whether the exact same finger was lifted and then placed down again, so indices are consistent between the DOWN and UP events, but once an UP event is received there is no guarantee that index 0 will be assigned to the same physical finger the next time that finger produces a touch.\")] public string[] m_BaseEventNames Field Value Type Description string[] | Improve this Doc View Source m_ForceLegacyInput Converts touch events from Unity's built-in touch system to VREvents. Declaration [Tooltip(\"If true, will use the Unity's Legacy InputModule even if the New Input System is available this may be needed on mobile devices or other platforms where the new input system is not yet fully functional\")] public bool m_ForceLegacyInput Field Value Type Description bool | Improve this Doc View Source m_IncludePressureEvents Converts touch events from Unity's built-in touch system to VREvents. Declaration [Tooltip(\"If true, each position update event will be followed immediately by a pressure update event.\")] public bool m_IncludePressureEvents Field Value Type Description bool Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source PollForEvents(ref List<VREvent>) Calling Poll adds to the queue any input events generated since the last call to poll. Declaration public void PollForEvents(ref List<VREvent> eventQueue) Parameters Type Name Description List<VREvent> eventQueue Implements IPolledInputDevice IVREventProducer"
  },
  "api/IVLab.MinVR3.TouchscreenState.TouchInputPhase.html": {
    "href": "api/IVLab.MinVR3.TouchscreenState.TouchInputPhase.html",
    "title": "Enum TouchscreenState.TouchInputPhase | MinVR3",
    "keywords": "Enum TouchscreenState.TouchInputPhase Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum TouchscreenState.TouchInputPhase Fields Name Description Began Canceled Ended Moved None Stationary"
  },
  "api/IVLab.MinVR3.TouchscreenState.html": {
    "href": "api/IVLab.MinVR3.TouchscreenState.html",
    "title": "Class TouchscreenState | MinVR3",
    "keywords": "Class TouchscreenState Inheritance object TouchscreenState Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class TouchscreenState Methods | Improve this Doc View Source GetTouchCount(bool) Declaration public static int GetTouchCount(bool forceLegacy) Parameters Type Name Description bool forceLegacy Returns Type Description int | Improve this Doc View Source GetTouchID(int, bool) Declaration public static int GetTouchID(int touchIndex, bool forceLegacy) Parameters Type Name Description int touchIndex bool forceLegacy Returns Type Description int | Improve this Doc View Source GetTouchPhase(int, bool) Declaration public static TouchscreenState.TouchInputPhase GetTouchPhase(int touchIndex, bool forceLegacy) Parameters Type Name Description int touchIndex bool forceLegacy Returns Type Description TouchscreenState.TouchInputPhase | Improve this Doc View Source GetTouchPosition(int, bool) Declaration public static Vector2 GetTouchPosition(int touchIndex, bool forceLegacy) Parameters Type Name Description int touchIndex bool forceLegacy Returns Type Description Vector2 | Improve this Doc View Source GetTouchPressure(int, bool) Declaration public static float GetTouchPressure(int touchIndex, bool forceLegacy) Parameters Type Name Description int touchIndex bool forceLegacy Returns Type Description float"
  },
  "api/IVLab.MinVR3.TrackballCamera.TrackballState.html": {
    "href": "api/IVLab.MinVR3.TrackballCamera.TrackballState.html",
    "title": "Enum TrackballCamera.TrackballState | MinVR3",
    "keywords": "Enum TrackballCamera.TrackballState Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum TrackballCamera.TrackballState Fields Name Description Orbit Pan Rotate Truck"
  },
  "api/IVLab.MinVR3.TrackballCamera.html": {
    "href": "api/IVLab.MinVR3.TrackballCamera.html",
    "title": "Class TrackballCamera | MinVR3",
    "keywords": "Class TrackballCamera Clickable and draggable camera for trackball camera movement in Unity. Can optionally enable \"acceleration\" to avoid users getting sick in situations like a planetarium. TODO: @bridger: It seems like this class only works properly if the hierarchy is setup in a certain way. It seems this script must be on an object under another object that is the \"trackball parent\" -- does that mean it contains all of the geometry that should be rotated by the trackball? And, the camera must be a child of the gameobject this script is attached to? Can you add documentation on how the hierarchy must be arranged? And, for the GameObject menu, when you add one of these to the scene, it would be useful if it could create the required mini-hierarchy for you. Inheritance object Object Component Behaviour MonoBehaviour TrackballCamera Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Desktop/TrackballCamera\")] public class TrackballCamera : MonoBehaviour Methods | Improve this Doc View Source OnMovement(TrackballState, Vector2) Clickable and draggable camera for trackball camera movement in Unity. Can optionally enable \"acceleration\" to avoid users getting sick in situations like a planetarium. TODO: @bridger: It seems like this class only works properly if the hierarchy is setup in a certain way. It seems this script must be on an object under another object that is the \"trackball parent\" -- does that mean it contains all of the geometry that should be rotated by the trackball? And, the camera must be a child of the gameobject this script is attached to? Can you add documentation on how the hierarchy must be arranged? And, for the GameObject menu, when you add one of these to the scene, it would be useful if it could create the required mini-hierarchy for you. Declaration public void OnMovement(TrackballCamera.TrackballState movement, Vector2 mousePosition) Parameters Type Name Description TrackballCamera.TrackballState movement Vector2 mousePosition | Improve this Doc View Source OnMovementEnd(TrackballState) Clickable and draggable camera for trackball camera movement in Unity. Can optionally enable \"acceleration\" to avoid users getting sick in situations like a planetarium. TODO: @bridger: It seems like this class only works properly if the hierarchy is setup in a certain way. It seems this script must be on an object under another object that is the \"trackball parent\" -- does that mean it contains all of the geometry that should be rotated by the trackball? And, the camera must be a child of the gameobject this script is attached to? Can you add documentation on how the hierarchy must be arranged? And, for the GameObject menu, when you add one of these to the scene, it would be useful if it could create the required mini-hierarchy for you. Declaration public void OnMovementEnd(TrackballCamera.TrackballState mvmt) Parameters Type Name Description TrackballCamera.TrackballState mvmt | Improve this Doc View Source OnMovementStart(TrackballState) Clickable and draggable camera for trackball camera movement in Unity. Can optionally enable \"acceleration\" to avoid users getting sick in situations like a planetarium. TODO: @bridger: It seems like this class only works properly if the hierarchy is setup in a certain way. It seems this script must be on an object under another object that is the \"trackball parent\" -- does that mean it contains all of the geometry that should be rotated by the trackball? And, the camera must be a child of the gameobject this script is attached to? Can you add documentation on how the hierarchy must be arranged? And, for the GameObject menu, when you add one of these to the scene, it would be useful if it could create the required mini-hierarchy for you. Declaration public void OnMovementStart(TrackballCamera.TrackballState mvmt) Parameters Type Name Description TrackballCamera.TrackballState mvmt"
  },
  "api/IVLab.MinVR3.TrackedDesktopCamera.html": {
    "href": "api/IVLab.MinVR3.TrackedDesktopCamera.html",
    "title": "Class TrackedDesktopCamera | MinVR3",
    "keywords": "Class TrackedDesktopCamera Makes a regular desktop camera move about in respone to VREvents so you can control it, for example, from a HMD simulator. Inheritance object Object Component Behaviour MonoBehaviour TrackedDesktopCamera Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Display/Tracked Desktop Camera\")] public class TrackedDesktopCamera : MonoBehaviour, IVREventListener Properties | Improve this Doc View Source positionEvent Makes a regular desktop camera move about in respone to VREvents so you can control it, for example, from a HMD simulator. Declaration public VREventPrototypeVector3 positionEvent { get; set; } Property Value Type Description VREventPrototypeVector3 | Improve this Doc View Source rotationEvent Makes a regular desktop camera move about in respone to VREvents so you can control it, for example, from a HMD simulator. Declaration public VREventPrototypeQuaternion rotationEvent { get; set; } Property Value Type Description VREventPrototypeQuaternion | Improve this Doc View Source trackedCamera Makes a regular desktop camera move about in respone to VREvents so you can control it, for example, from a HMD simulator. Declaration public Camera trackedCamera { get; set; } Property Value Type Description Camera Methods | Improve this Doc View Source OnVREvent(VREvent) Makes a regular desktop camera move about in respone to VREvents so you can control it, for example, from a HMD simulator. Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source StartListening() Makes a regular desktop camera move about in respone to VREvents so you can control it, for example, from a HMD simulator. Declaration public void StartListening() | Improve this Doc View Source StopListening() Makes a regular desktop camera move about in respone to VREvents so you can control it, for example, from a HMD simulator. Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.TrackedPoseDriver.TrackingType.html": {
    "href": "api/IVLab.MinVR3.TrackedPoseDriver.TrackingType.html",
    "title": "Enum TrackedPoseDriver.TrackingType | MinVR3",
    "keywords": "Enum TrackedPoseDriver.TrackingType Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum TrackedPoseDriver.TrackingType Fields Name Description PositionOnly RotationAndPosition RotationOnly"
  },
  "api/IVLab.MinVR3.TrackedPoseDriver.UpdateType.html": {
    "href": "api/IVLab.MinVR3.TrackedPoseDriver.UpdateType.html",
    "title": "Enum TrackedPoseDriver.UpdateType | MinVR3",
    "keywords": "Enum TrackedPoseDriver.UpdateType Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum TrackedPoseDriver.UpdateType Fields Name Description BeforeRender Update UpdateAndBeforeRender"
  },
  "api/IVLab.MinVR3.TrackedPoseDriver.html": {
    "href": "api/IVLab.MinVR3.TrackedPoseDriver.html",
    "title": "Class TrackedPoseDriver | MinVR3",
    "keywords": "Class TrackedPoseDriver Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Inheritance object Object Component Behaviour MonoBehaviour TrackedPoseDriver Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Cursors/Tracked Pose Driver\")] public class TrackedPoseDriver : MonoBehaviour, IVREventListener Properties | Improve this Doc View Source calibrationRotation Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration public Quaternion calibrationRotation { get; set; } Property Value Type Description Quaternion | Improve this Doc View Source calibrationTranslation Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration public Vector3 calibrationTranslation { get; set; } Property Value Type Description Vector3 | Improve this Doc View Source positionEvent Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration public VREventPrototypeVector3 positionEvent { get; set; } Property Value Type Description VREventPrototypeVector3 | Improve this Doc View Source rotationEvent Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration public VREventPrototypeQuaternion rotationEvent { get; set; } Property Value Type Description VREventPrototypeQuaternion | Improve this Doc View Source trackingType The tracking type being used by the tracked pose driver Declaration public TrackedPoseDriver.TrackingType trackingType { get; set; } Property Value Type Description TrackedPoseDriver.TrackingType | Improve this Doc View Source updateType The update type being used by the tracked pose driver Declaration public TrackedPoseDriver.UpdateType updateType { get; set; } Property Value Type Description TrackedPoseDriver.UpdateType Methods | Improve this Doc View Source Awake() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected virtual void Awake() | Improve this Doc View Source LateUpdate() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected void LateUpdate() | Improve this Doc View Source OnBeforeRender() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected virtual void OnBeforeRender() | Improve this Doc View Source OnDestroy() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected virtual void OnDestroy() | Improve this Doc View Source OnEnable() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected void OnEnable() | Improve this Doc View Source OnUpdate() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected virtual void OnUpdate() | Improve this Doc View Source OnVREvent(VREvent) Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source PerformUpdate() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected virtual void PerformUpdate() | Improve this Doc View Source SetLocalTransform(Vector3, Quaternion) Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected virtual void SetLocalTransform(Vector3 newPosition, Quaternion newRotation) Parameters Type Name Description Vector3 newPosition Quaternion newRotation | Improve this Doc View Source StartListening() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration public void StartListening() | Improve this Doc View Source StopListening() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration public void StopListening() | Improve this Doc View Source Update() Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. Declaration protected void Update() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.TrackedProjectionScreen.ProjectionType.html": {
    "href": "api/IVLab.MinVR3.TrackedProjectionScreen.ProjectionType.html",
    "title": "Enum TrackedProjectionScreen.ProjectionType | MinVR3",
    "keywords": "Enum TrackedProjectionScreen.ProjectionType Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum TrackedProjectionScreen.ProjectionType Fields Name Description Parallel Perspective"
  },
  "api/IVLab.MinVR3.TrackedProjectionScreen.ScreenCorners.html": {
    "href": "api/IVLab.MinVR3.TrackedProjectionScreen.ScreenCorners.html",
    "title": "Class TrackedProjectionScreen.ScreenCorners | MinVR3",
    "keywords": "Class TrackedProjectionScreen.ScreenCorners Inheritance object TrackedProjectionScreen.ScreenCorners Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class TrackedProjectionScreen.ScreenCorners Fields | Improve this Doc View Source bottomLeft Declaration public Vector3 bottomLeft Field Value Type Description Vector3 | Improve this Doc View Source bottomRight Declaration public Vector3 bottomRight Field Value Type Description Vector3 | Improve this Doc View Source topLeft Declaration public Vector3 topLeft Field Value Type Description Vector3 | Improve this Doc View Source topRight Declaration public Vector3 topRight Field Value Type Description Vector3"
  },
  "api/IVLab.MinVR3.TrackedProjectionScreen.html": {
    "href": "api/IVLab.MinVR3.TrackedProjectionScreen.html",
    "title": "Class TrackedProjectionScreen | MinVR3",
    "keywords": "Class TrackedProjectionScreen Inheritance object Object Component Behaviour MonoBehaviour TrackedProjectionScreen Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [ExecuteAlways] [AddComponentMenu(\"MinVR/Display/Tracked Projection Screen\")] public class TrackedProjectionScreen : MonoBehaviour, IVREventListener Fields | Improve this Doc View Source cam Declaration [Tooltip(\"To apply the projection and view matrices to a camera other than the main camera, attach it here.\")] public Camera cam Field Value Type Description Camera | Improve this Doc View Source debugColor Declaration [Tooltip(\"Color to use when drawing the projection plane and off-axis view frustrum in the editor.\")] public Color debugColor Field Value Type Description Color | Improve this Doc View Source headTrackingPosEvent Declaration [Tooltip(\"The VREvent that provides head tracking position updates.\")] public VREventPrototypeVector3 headTrackingPosEvent Field Value Type Description VREventPrototypeVector3 | Improve this Doc View Source headTrackingRotEvent Declaration [Tooltip(\"The VREvent that provides head tracking rotation updates.\")] public VREventPrototypeQuaternion headTrackingRotEvent Field Value Type Description VREventPrototypeQuaternion | Improve this Doc View Source projectionType Declaration [Tooltip(\"Perspective projection is typically (always?) used for head tracked displays.\")] public TrackedProjectionScreen.ProjectionType projectionType Field Value Type Description TrackedProjectionScreen.ProjectionType | Improve this Doc View Source trackingSpaceCorners Declaration [Tooltip(\"Positions in the physical tracking space coordinate system for the four corners of the projection screen. These must form a rectangle.\")] public TrackedProjectionScreen.ScreenCorners trackingSpaceCorners Field Value Type Description TrackedProjectionScreen.ScreenCorners | Improve this Doc View Source useWorldSpaceForCorners Declaration [Tooltip(\"Use world space for tracking corners\")] public bool useWorldSpaceForCorners Field Value Type Description bool Methods | Improve this Doc View Source GetBottomLeftCorner() Declaration public Vector3 GetBottomLeftCorner() Returns Type Description Vector3 | Improve this Doc View Source GetBottomRightCorner() Declaration public Vector3 GetBottomRightCorner() Returns Type Description Vector3 | Improve this Doc View Source GetLeftEyePosition() Declaration public Vector3 GetLeftEyePosition() Returns Type Description Vector3 | Improve this Doc View Source GetRightEyePosition() Declaration public Vector3 GetRightEyePosition() Returns Type Description Vector3 | Improve this Doc View Source GetTopLeftCorner() Declaration public Vector3 GetTopLeftCorner() Returns Type Description Vector3 | Improve this Doc View Source GetTopRightCorner() Declaration public Vector3 GetTopRightCorner() Returns Type Description Vector3 | Improve this Doc View Source IsListening() Declaration public bool IsListening() Returns Type Description bool | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.TransformExtensions.html": {
    "href": "api/IVLab.MinVR3.TransformExtensions.html",
    "title": "Class TransformExtensions | MinVR3",
    "keywords": "Class TransformExtensions Inheritance object TransformExtensions Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public static class TransformExtensions Methods | Improve this Doc View Source FromMatrix(Transform, Matrix4x4) Declaration public static void FromMatrix(this Transform transform, Matrix4x4 matrix) Parameters Type Name Description Transform transform Matrix4x4 matrix | Improve this Doc View Source LocalDirectionToParentSpace(Transform, Vector3) Declaration public static Vector3 LocalDirectionToParentSpace(this Transform t, Vector3 localDirection) Parameters Type Name Description Transform t Vector3 localDirection Returns Type Description Vector3 | Improve this Doc View Source LocalDirectionToRoomSpace(Transform, Vector3) Declaration public static Vector3 LocalDirectionToRoomSpace(this Transform t, Vector3 localDirection) Parameters Type Name Description Transform t Vector3 localDirection Returns Type Description Vector3 | Improve this Doc View Source LocalDirectionToWorldSpace(Transform, Vector3) Declaration public static Vector3 LocalDirectionToWorldSpace(this Transform t, Vector3 localDirection) Parameters Type Name Description Transform t Vector3 localDirection Returns Type Description Vector3 | Improve this Doc View Source LocalPointToParentSpace(Transform, Vector3) Declaration public static Vector3 LocalPointToParentSpace(this Transform t, Vector3 localPoint) Parameters Type Name Description Transform t Vector3 localPoint Returns Type Description Vector3 | Improve this Doc View Source LocalPointToRoomSpace(Transform, Vector3) Declaration public static Vector3 LocalPointToRoomSpace(this Transform t, Vector3 localPoint) Parameters Type Name Description Transform t Vector3 localPoint Returns Type Description Vector3 | Improve this Doc View Source LocalPointToWorldSpace(Transform, Vector3) Declaration public static Vector3 LocalPointToWorldSpace(this Transform t, Vector3 localPoint) Parameters Type Name Description Transform t Vector3 localPoint Returns Type Description Vector3 | Improve this Doc View Source LocalVectorToParentSpace(Transform, Vector3) Declaration public static Vector3 LocalVectorToParentSpace(this Transform t, Vector3 localVector) Parameters Type Name Description Transform t Vector3 localVector Returns Type Description Vector3 | Improve this Doc View Source LocalVectorToRoomSpace(Transform, Vector3) Declaration public static Vector3 LocalVectorToRoomSpace(this Transform t, Vector3 localVector) Parameters Type Name Description Transform t Vector3 localVector Returns Type Description Vector3 | Improve this Doc View Source LocalVectorToWorldSpace(Transform, Vector3) Declaration public static Vector3 LocalVectorToWorldSpace(this Transform t, Vector3 localVector) Parameters Type Name Description Transform t Vector3 localVector Returns Type Description Vector3 | Improve this Doc View Source ParentDirectionToLocalSpace(Transform, Vector3) Declaration public static Vector3 ParentDirectionToLocalSpace(this Transform t, Vector3 parentDirection) Parameters Type Name Description Transform t Vector3 parentDirection Returns Type Description Vector3 | Improve this Doc View Source ParentPointToLocalSpace(Transform, Vector3) Declaration public static Vector3 ParentPointToLocalSpace(this Transform t, Vector3 parentPoint) Parameters Type Name Description Transform t Vector3 parentPoint Returns Type Description Vector3 | Improve this Doc View Source ParentVectorToLocalSpace(Transform, Vector3) Declaration public static Vector3 ParentVectorToLocalSpace(this Transform t, Vector3 parentVector) Parameters Type Name Description Transform t Vector3 parentVector Returns Type Description Vector3 | Improve this Doc View Source RoomDirectionToLocalSpace(Transform, Vector3) Declaration public static Vector3 RoomDirectionToLocalSpace(this Transform t, Vector3 roomDirection) Parameters Type Name Description Transform t Vector3 roomDirection Returns Type Description Vector3 | Improve this Doc View Source RoomPointToLocalSpace(Transform, Vector3) Declaration public static Vector3 RoomPointToLocalSpace(this Transform t, Vector3 roomPoint) Parameters Type Name Description Transform t Vector3 roomPoint Returns Type Description Vector3 | Improve this Doc View Source RoomVectorToLocalSpace(Transform, Vector3) Declaration public static Vector3 RoomVectorToLocalSpace(this Transform t, Vector3 roomVector) Parameters Type Name Description Transform t Vector3 roomVector Returns Type Description Vector3 | Improve this Doc View Source RotateAroundLocalOrigin(Transform, Quaternion) Declaration public static void RotateAroundLocalOrigin(this Transform t, Quaternion deltaRot) Parameters Type Name Description Transform t Quaternion deltaRot | Improve this Doc View Source RotateAroundLocalPoint(Transform, Vector3, Quaternion) Declaration public static void RotateAroundLocalPoint(this Transform t, Vector3 point, Quaternion deltaRot) Parameters Type Name Description Transform t Vector3 point Quaternion deltaRot | Improve this Doc View Source RotateAroundWorldOrigin(Transform, Quaternion) Declaration public static void RotateAroundWorldOrigin(this Transform t, Quaternion deltaRot) Parameters Type Name Description Transform t Quaternion deltaRot | Improve this Doc View Source RotateAroundWorldPoint(Transform, Vector3, Quaternion) Declaration public static void RotateAroundWorldPoint(this Transform t, Vector3 point, Quaternion deltaRot) Parameters Type Name Description Transform t Vector3 point Quaternion deltaRot | Improve this Doc View Source ScaleAroundLocalOrigin(Transform, float) Declaration public static void ScaleAroundLocalOrigin(this Transform t, float deltaScale) Parameters Type Name Description Transform t float deltaScale | Improve this Doc View Source ScaleAroundLocalPoint(Transform, Vector3, float) Declaration public static void ScaleAroundLocalPoint(this Transform t, Vector3 point, float deltaScale) Parameters Type Name Description Transform t Vector3 point float deltaScale | Improve this Doc View Source ScaleAroundWorldOrigin(Transform, float) Declaration public static void ScaleAroundWorldOrigin(this Transform t, float deltaScale) Parameters Type Name Description Transform t float deltaScale | Improve this Doc View Source ScaleAroundWorldPoint(Transform, Vector3, float) Declaration public static void ScaleAroundWorldPoint(this Transform t, Vector3 point, float deltaScale) Parameters Type Name Description Transform t Vector3 point float deltaScale | Improve this Doc View Source SetGlobalScale(Transform, Vector3) Declaration public static void SetGlobalScale(this Transform transform, Vector3 globalScale) Parameters Type Name Description Transform transform Vector3 globalScale | Improve this Doc View Source TranslateByLocalVector(Transform, Vector3) Declaration public static void TranslateByLocalVector(this Transform t, Vector3 deltaTrans) Parameters Type Name Description Transform t Vector3 deltaTrans | Improve this Doc View Source TranslateByWorldVector(Transform, Vector3) Declaration public static void TranslateByWorldVector(this Transform t, Vector3 deltaTrans) Parameters Type Name Description Transform t Vector3 deltaTrans | Improve this Doc View Source WorldDirectionToLocalSpace(Transform, Vector3) Declaration public static Vector3 WorldDirectionToLocalSpace(this Transform t, Vector3 worldDirection) Parameters Type Name Description Transform t Vector3 worldDirection Returns Type Description Vector3 | Improve this Doc View Source WorldPointToLocalSpace(Transform, Vector3) Declaration public static Vector3 WorldPointToLocalSpace(this Transform t, Vector3 worldPoint) Parameters Type Name Description Transform t Vector3 worldPoint Returns Type Description Vector3 | Improve this Doc View Source WorldVectorToLocalSpace(Transform, Vector3) Declaration public static Vector3 WorldVectorToLocalSpace(this Transform t, Vector3 worldVector) Parameters Type Name Description Transform t Vector3 worldVector Returns Type Description Vector3"
  },
  "api/IVLab.MinVR3.UniCam.html": {
    "href": "api/IVLab.MinVR3.UniCam.html",
    "title": "Class UniCam | MinVR3",
    "keywords": "Class UniCam This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. Inheritance object Object Component Behaviour MonoBehaviour UniCam Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR Interaction/Desktop/UniCam\")] public class UniCam : MonoBehaviour, IVREventListener Methods | Improve this Doc View Source Awake() This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. Declaration public void Awake() | Improve this Doc View Source NormalizedDeviceCoordsToScreenCoords(Vector2) This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. Declaration public Vector2 NormalizedDeviceCoordsToScreenCoords(Vector2 ndcPt) Parameters Type Name Description Vector2 ndcPt Returns Type Description Vector2 | Improve this Doc View Source OnVREvent(VREvent) This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source RayIntersectSphere(Ray, Vector3, float, out float, out Vector3) This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. Declaration public bool RayIntersectSphere(Ray ray, Vector3 center, float radius, out float iTime, out Vector3 iPoint) Parameters Type Name Description Ray ray Vector3 center float radius float iTime Vector3 iPoint Returns Type Description bool | Improve this Doc View Source Reset() This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. Declaration public void Reset() | Improve this Doc View Source ScreenCoordsToNormalizedDeviceCoords(Vector2) Normalized Device Coords have (0,0) at the center of the screen, (-1,-1) in the bottom left, and (1,1) in the top right. Declaration public Vector2 ScreenCoordsToNormalizedDeviceCoords(Vector2 screenPt) Parameters Type Name Description Vector2 screenPt Returns Type Description Vector2 | Improve this Doc View Source StartListening() This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. Declaration public void StartListening() | Improve this Doc View Source StopListening() This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.VRCallback.html": {
    "href": "api/IVLab.MinVR3.VRCallback.html",
    "title": "Class VRCallback | MinVR3",
    "keywords": "Class VRCallback Inheritance object UnityEventBase UnityEvent VRCallback Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallback : UnityEvent, ISerializationCallbackReceiver, IVRCallback Constructors | Improve this Doc View Source VRCallback() Declaration public VRCallback() Methods | Improve this Doc View Source AddRuntimeListener(UnityAction) For callbacks created while your program is running (i.e., from within Start(), Update(), etc.). Note that callbacks added this way will not show up in the inspector -- that is a limitation/feature of the UnityEvent* classes upon which this implmementation is based. Declaration public void AddRuntimeListener(UnityAction listener) Parameters Type Name Description UnityAction listener | Improve this Doc View Source CreateRuntime(UnityAction) Declaration public static VRCallback CreateRuntime(UnityAction callbackFunc) Parameters Type Name Description UnityAction callbackFunc Returns Type Description VRCallback | Improve this Doc View Source InvokeWithVREvent(VREvent) Declaration public void InvokeWithVREvent(VREvent e) Parameters Type Name Description VREvent e | Improve this Doc View Source RemoveRuntimeListener(UnityAction) Declaration public void RemoveRuntimeListener(UnityAction listener) Parameters Type Name Description UnityAction listener Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackAny.html": {
    "href": "api/IVLab.MinVR3.VRCallbackAny.html",
    "title": "Class VRCallbackAny | MinVR3",
    "keywords": "Class VRCallbackAny Inheritance object VRCallbackAny Implements IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackAny : IVRCallback Constructors | Improve this Doc View Source VRCallbackAny() Declaration public VRCallbackAny() Methods | Improve this Doc View Source AddRuntimeListener(UnityAction) For callbacks created while your program is running (i.e., from within Start(), Update(), etc.). Note that callbacks added this way will not show up in the inspector -- that is a limitation/feature of the UnityEvent* classes upon which this implmementation is based. Declaration public void AddRuntimeListener(UnityAction listener) Parameters Type Name Description UnityAction listener | Improve this Doc View Source AddRuntimeListener<T>(UnityAction<T>) Declaration public void AddRuntimeListener<T>(UnityAction<T> listener) Parameters Type Name Description UnityAction<T> listener Type Parameters Name Description T | Improve this Doc View Source CreateRuntime(UnityAction) Declaration public static VRCallbackAny CreateRuntime(UnityAction callbackFunc) Parameters Type Name Description UnityAction callbackFunc Returns Type Description VRCallbackAny | Improve this Doc View Source CreateRuntime<T>(UnityAction<T>) Declaration public static VRCallbackAny CreateRuntime<T>(UnityAction<T> callbackFunc) Parameters Type Name Description UnityAction<T> callbackFunc Returns Type Description VRCallbackAny Type Parameters Name Description T | Improve this Doc View Source InitAllCallbacks() Declaration public void InitAllCallbacks() | Improve this Doc View Source InvokeWithVREvent(VREvent) Declaration public void InvokeWithVREvent(VREvent e) Parameters Type Name Description VREvent e | Improve this Doc View Source RemoveRuntimeListener(UnityAction) Declaration public void RemoveRuntimeListener(UnityAction listener) Parameters Type Name Description UnityAction listener | Improve this Doc View Source RemoveRuntimeListener<T>(UnityAction<T>) Declaration public void RemoveRuntimeListener<T>(UnityAction<T> listener) Parameters Type Name Description UnityAction<T> listener Type Parameters Name Description T | Improve this Doc View Source SetEventDataType(string) Declaration public void SetEventDataType(string eventDataTypeName) Parameters Type Name Description string eventDataTypeName | Improve this Doc View Source SetEventDataType(Type) Declaration public void SetEventDataType(Type eventDataType) Parameters Type Name Description Type eventDataType | Improve this Doc View Source SetShowDataTypeInEditor(bool) Declaration public void SetShowDataTypeInEditor(bool show) Parameters Type Name Description bool show | Improve this Doc View Source SupportsDataType(string) Declaration public bool SupportsDataType(string dataTypeName) Parameters Type Name Description string dataTypeName Returns Type Description bool | Improve this Doc View Source SupportsDataType(Type) Declaration public bool SupportsDataType(Type dataType) Parameters Type Name Description Type dataType Returns Type Description bool Implements IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackAnyDrawer.html": {
    "href": "api/IVLab.MinVR3.VRCallbackAnyDrawer.html",
    "title": "Class VRCallbackAnyDrawer | MinVR3",
    "keywords": "Class VRCallbackAnyDrawer Inheritance object GUIDrawer PropertyDrawer VRCallbackAnyDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VRCallbackAny))] public class VRCallbackAnyDrawer : PropertyDrawer Methods | Improve this Doc View Source GetPropertyHeight(SerializedProperty, GUIContent) Override this method to specify how tall the GUI for this field is in pixels. Declaration public override float GetPropertyHeight(SerializedProperty property, GUIContent label) Parameters Type Name Description SerializedProperty property The SerializedProperty to make the custom GUI for. GUIContent label The label of this property. Returns Type Description float The height in pixels. Overrides UnityEditor.PropertyDrawer.GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent) | Improve this Doc View Source OnGUI(Rect, SerializedProperty, GUIContent) Override this method to make your own IMGUI based GUI for the property. Declaration public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) Parameters Type Name Description Rect position Rectangle on the screen to use for the property GUI. SerializedProperty property The SerializedProperty to make the custom GUI for. GUIContent label The label of this property. Overrides UnityEditor.PropertyDrawer.OnGUI(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.GUIContent)"
  },
  "api/IVLab.MinVR3.VRCallbackDrawer.html": {
    "href": "api/IVLab.MinVR3.VRCallbackDrawer.html",
    "title": "Class VRCallbackDrawer | MinVR3",
    "keywords": "Class VRCallbackDrawer Inheritance object GUIDrawer PropertyDrawer UnityEventDrawer VRCallbackDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VRCallback))] public class VRCallbackDrawer : UnityEventDrawer"
  },
  "api/IVLab.MinVR3.VRCallbackFloat.html": {
    "href": "api/IVLab.MinVR3.VRCallbackFloat.html",
    "title": "Class VRCallbackFloat | MinVR3",
    "keywords": "Class VRCallbackFloat Inheritance object UnityEventBase UnityEvent<float> VRCallbackT<float> VRCallbackFloat Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackFloat : VRCallbackT<float>, ISerializationCallbackReceiver, IVRCallback Methods | Improve this Doc View Source CreateRuntime(UnityAction<float>) Declaration public static VRCallbackFloat CreateRuntime(UnityAction<float> callbackFunc) Parameters Type Name Description UnityAction<float> callbackFunc Returns Type Description VRCallbackFloat Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackGameObject.html": {
    "href": "api/IVLab.MinVR3.VRCallbackGameObject.html",
    "title": "Class VRCallbackGameObject | MinVR3",
    "keywords": "Class VRCallbackGameObject Inheritance object UnityEventBase UnityEvent<GameObject> VRCallbackT<GameObject> VRCallbackGameObject Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackGameObject : VRCallbackT<GameObject>, ISerializationCallbackReceiver, IVRCallback Methods | Improve this Doc View Source CreateRuntime(UnityAction<GameObject>) Declaration public static VRCallbackGameObject CreateRuntime(UnityAction<GameObject> callbackFunc) Parameters Type Name Description UnityAction<GameObject> callbackFunc Returns Type Description VRCallbackGameObject Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackInt.html": {
    "href": "api/IVLab.MinVR3.VRCallbackInt.html",
    "title": "Class VRCallbackInt | MinVR3",
    "keywords": "Class VRCallbackInt Inheritance object UnityEventBase UnityEvent<int> VRCallbackT<int> VRCallbackInt Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackInt : VRCallbackT<int>, ISerializationCallbackReceiver, IVRCallback Methods | Improve this Doc View Source CreateRuntime(UnityAction<int>) Declaration public static VRCallbackInt CreateRuntime(UnityAction<int> callbackFunc) Parameters Type Name Description UnityAction<int> callbackFunc Returns Type Description VRCallbackInt Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackQuaternion.html": {
    "href": "api/IVLab.MinVR3.VRCallbackQuaternion.html",
    "title": "Class VRCallbackQuaternion | MinVR3",
    "keywords": "Class VRCallbackQuaternion Inheritance object UnityEventBase UnityEvent<Quaternion> VRCallbackT<Quaternion> VRCallbackQuaternion Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackQuaternion : VRCallbackT<Quaternion>, ISerializationCallbackReceiver, IVRCallback Methods | Improve this Doc View Source CreateRuntime(UnityAction<Quaternion>) Declaration public static VRCallbackQuaternion CreateRuntime(UnityAction<Quaternion> callbackFunc) Parameters Type Name Description UnityAction<Quaternion> callbackFunc Returns Type Description VRCallbackQuaternion Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackString.html": {
    "href": "api/IVLab.MinVR3.VRCallbackString.html",
    "title": "Class VRCallbackString | MinVR3",
    "keywords": "Class VRCallbackString Inheritance object UnityEventBase UnityEvent<string> VRCallbackT<string> VRCallbackString Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackString : VRCallbackT<string>, ISerializationCallbackReceiver, IVRCallback Methods | Improve this Doc View Source CreateRuntime(UnityAction<string>) Declaration public static VRCallbackString CreateRuntime(UnityAction<string> callbackFunc) Parameters Type Name Description UnityAction<string> callbackFunc Returns Type Description VRCallbackString Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackT-1.html": {
    "href": "api/IVLab.MinVR3.VRCallbackT-1.html",
    "title": "Class VRCallbackT<T> | MinVR3",
    "keywords": "Class VRCallbackT<T> Inheritance object UnityEventBase UnityEvent<T> VRCallbackT<T> VRCallbackFloat VRCallbackGameObject VRCallbackInt VRCallbackQuaternion VRCallbackString VRCallbackVector2 VRCallbackVector3 VRCallbackVector4 Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackT<T> : UnityEvent<T>, ISerializationCallbackReceiver, IVRCallback Type Parameters Name Description T Constructors | Improve this Doc View Source VRCallbackT() Declaration public VRCallbackT() Methods | Improve this Doc View Source AddRuntimeListener(UnityAction<T>) For callbacks created while your program is running (i.e., from within Start(), Update(), etc.). Note that callbacks added this way will not show up in the inspector -- that is a limitation/feature of the UnityEvent* classes upon which this implmementation is based. Declaration public void AddRuntimeListener(UnityAction<T> listener) Parameters Type Name Description UnityAction<T> listener | Improve this Doc View Source InvokeWithVREvent(VREvent) Declaration public void InvokeWithVREvent(VREvent e) Parameters Type Name Description VREvent e | Improve this Doc View Source RemoveRuntimeListener(UnityAction<T>) Declaration public void RemoveRuntimeListener(UnityAction<T> listener) Parameters Type Name Description UnityAction<T> listener Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackTDrawer.html": {
    "href": "api/IVLab.MinVR3.VRCallbackTDrawer.html",
    "title": "Class VRCallbackTDrawer | MinVR3",
    "keywords": "Class VRCallbackTDrawer Inheritance object GUIDrawer PropertyDrawer UnityEventDrawer VRCallbackTDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VRCallbackT<>))] public class VRCallbackTDrawer : UnityEventDrawer"
  },
  "api/IVLab.MinVR3.VRCallbackVector2.html": {
    "href": "api/IVLab.MinVR3.VRCallbackVector2.html",
    "title": "Class VRCallbackVector2 | MinVR3",
    "keywords": "Class VRCallbackVector2 Inheritance object UnityEventBase UnityEvent<Vector2> VRCallbackT<Vector2> VRCallbackVector2 Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackVector2 : VRCallbackT<Vector2>, ISerializationCallbackReceiver, IVRCallback Methods | Improve this Doc View Source CreateRuntime(UnityAction<Vector2>) Declaration public static VRCallbackVector2 CreateRuntime(UnityAction<Vector2> callbackFunc) Parameters Type Name Description UnityAction<Vector2> callbackFunc Returns Type Description VRCallbackVector2 Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackVector3.html": {
    "href": "api/IVLab.MinVR3.VRCallbackVector3.html",
    "title": "Class VRCallbackVector3 | MinVR3",
    "keywords": "Class VRCallbackVector3 Inheritance object UnityEventBase UnityEvent<Vector3> VRCallbackT<Vector3> VRCallbackVector3 Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackVector3 : VRCallbackT<Vector3>, ISerializationCallbackReceiver, IVRCallback Methods | Improve this Doc View Source CreateRuntime(UnityAction<Vector3>) Declaration public static VRCallbackVector3 CreateRuntime(UnityAction<Vector3> callbackFunc) Parameters Type Name Description UnityAction<Vector3> callbackFunc Returns Type Description VRCallbackVector3 Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRCallbackVector4.html": {
    "href": "api/IVLab.MinVR3.VRCallbackVector4.html",
    "title": "Class VRCallbackVector4 | MinVR3",
    "keywords": "Class VRCallbackVector4 Inheritance object UnityEventBase UnityEvent<Vector4> VRCallbackT<Vector4> VRCallbackVector4 Implements ISerializationCallbackReceiver IVRCallback Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VRCallbackVector4 : VRCallbackT<Vector4>, ISerializationCallbackReceiver, IVRCallback Methods | Improve this Doc View Source CreateRuntime(UnityAction<Vector4>) Declaration public static VRCallbackVector4 CreateRuntime(UnityAction<Vector4> callbackFunc) Parameters Type Name Description UnityAction<Vector4> callbackFunc Returns Type Description VRCallbackVector4 Implements UnityEngine.ISerializationCallbackReceiver IVRCallback"
  },
  "api/IVLab.MinVR3.VRConfig.html": {
    "href": "api/IVLab.MinVR3.VRConfig.html",
    "title": "Class VRConfig | MinVR3",
    "keywords": "Class VRConfig Attach to game objects you wish to act as VRConfig objects. Inheritance object Object Component Behaviour MonoBehaviour VRConfig Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Config/VRConfig\")] public class VRConfig : MonoBehaviour Methods | Improve this Doc View Source ParseConfigFiles() Attach to game objects you wish to act as VRConfig objects. Declaration public void ParseConfigFiles()"
  },
  "api/IVLab.MinVR3.VRConfigManager.html": {
    "href": "api/IVLab.MinVR3.VRConfigManager.html",
    "title": "Class VRConfigManager | MinVR3",
    "keywords": "Class VRConfigManager The VRConfigManager should not be created directly. Instead, use the one attached to VREngine. Inheritance object Object Component Behaviour MonoBehaviour VRConfigManager Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [DisallowMultipleComponent] public class VRConfigManager : MonoBehaviour Properties | Improve this Doc View Source startupConfig The VRConfigManager should not be created directly. Instead, use the one attached to VREngine. Declaration public VRConfig startupConfig { get; set; } Property Value Type Description VRConfig | Improve this Doc View Source startupConfigName The VRConfigManager should not be created directly. Instead, use the one attached to VREngine. Declaration public string startupConfigName { get; } Property Value Type Description string Methods | Improve this Doc View Source EnableStartupVRConfigAndDisableOthers() Enables and disables Game Objects based on the VRConfig that is starting up. This impacts GameObjects with VRConfig or VRConfigMask components attached. All GOs with VRConfig components are disabled EXCEPT for the one that has the startup VRConfig. For GOs that have VRConfigMask components attached, they are enabled if the mask includes a checkmark next to the startup VRConfig and disabled otherwise. Declaration public void EnableStartupVRConfigAndDisableOthers() | Improve this Doc View Source GetAvailableConfigs() The VRConfigManager should not be created directly. Instead, use the one attached to VREngine. Declaration public VRConfig[] GetAvailableConfigs() Returns Type Description VRConfig[] | Improve this Doc View Source GetConfigByName(string) The VRConfigManager should not be created directly. Instead, use the one attached to VREngine. Declaration public VRConfig GetConfigByName(string configName) Parameters Type Name Description string configName Returns Type Description VRConfig | Improve this Doc View Source ParseConfigFiles() The VRConfigManager should not be created directly. Instead, use the one attached to VREngine. Declaration public void ParseConfigFiles()"
  },
  "api/IVLab.MinVR3.VRConfigManagerEditor.html": {
    "href": "api/IVLab.MinVR3.VRConfigManagerEditor.html",
    "title": "Class VRConfigManagerEditor | MinVR3",
    "keywords": "Class VRConfigManagerEditor Inheritance object Object ScriptableObject Editor VRConfigManagerEditor Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomEditor(typeof(VRConfigManager))] public class VRConfigManagerEditor : Editor Methods | Improve this Doc View Source OnEnable() Declaration public void OnEnable() | Improve this Doc View Source OnInspectorGUI() Implement this function to make a custom inspector. Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/IVLab.MinVR3.VRConfigMask.html": {
    "href": "api/IVLab.MinVR3.VRConfigMask.html",
    "title": "Class VRConfigMask | MinVR3",
    "keywords": "Class VRConfigMask Automatically enables or disables the GameObject based on the active VRConfig when the VREngine starts. Configure which VRConfig is active on start using the VRConfigManager attached to VREngine, or by specifying command line arguments when running the application. Inheritance object Object Component Behaviour MonoBehaviour VRConfigMask Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Config/VRConfigMask\")] public class VRConfigMask : MonoBehaviour Methods | Improve this Doc View Source AddEnabledConfig(VRConfig) Automatically enables or disables the GameObject based on the active VRConfig when the VREngine starts. Configure which VRConfig is active on start using the VRConfigManager attached to VREngine, or by specifying command line arguments when running the application. Declaration public void AddEnabledConfig(VRConfig config) Parameters Type Name Description VRConfig config | Improve this Doc View Source IsEnabledForConfig(VRConfig) Automatically enables or disables the GameObject based on the active VRConfig when the VREngine starts. Configure which VRConfig is active on start using the VRConfigManager attached to VREngine, or by specifying command line arguments when running the application. Declaration public bool IsEnabledForConfig(VRConfig config) Parameters Type Name Description VRConfig config Returns Type Description bool | Improve this Doc View Source IsEnabledForConfig(string) Automatically enables or disables the GameObject based on the active VRConfig when the VREngine starts. Configure which VRConfig is active on start using the VRConfigManager attached to VREngine, or by specifying command line arguments when running the application. Declaration public bool IsEnabledForConfig(string configName) Parameters Type Name Description string configName Returns Type Description bool | Improve this Doc View Source RemoveEnabledConfig(VRConfig) Automatically enables or disables the GameObject based on the active VRConfig when the VREngine starts. Configure which VRConfig is active on start using the VRConfigManager attached to VREngine, or by specifying command line arguments when running the application. Declaration public void RemoveEnabledConfig(VRConfig config) Parameters Type Name Description VRConfig config"
  },
  "api/IVLab.MinVR3.VRConfigMaskEditor.html": {
    "href": "api/IVLab.MinVR3.VRConfigMaskEditor.html",
    "title": "Class VRConfigMaskEditor | MinVR3",
    "keywords": "Class VRConfigMaskEditor Inheritance object Object ScriptableObject Editor VRConfigMaskEditor Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomEditor(typeof(VRConfigMask))] public class VRConfigMaskEditor : Editor Methods | Improve this Doc View Source OnInspectorGUI() Implement this function to make a custom inspector. Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/IVLab.MinVR3.VRConvert.html": {
    "href": "api/IVLab.MinVR3.VRConvert.html",
    "title": "Class VRConvert | MinVR3",
    "keywords": "Class VRConvert Inheritance object VRConvert Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class VRConvert Methods | Improve this Doc View Source ToDoubleArray(Matrix4x4) Declaration public static double[] ToDoubleArray(Matrix4x4 m) Parameters Type Name Description Matrix4x4 m Returns Type Description double[] | Improve this Doc View Source ToDoubleArray(Vector3) Declaration public static double[] ToDoubleArray(Vector3 v) Parameters Type Name Description Vector3 v Returns Type Description double[] | Improve this Doc View Source ToFloatArray(Matrix4x4) Declaration public static float[] ToFloatArray(Matrix4x4 m) Parameters Type Name Description Matrix4x4 m Returns Type Description float[] | Improve this Doc View Source ToFloatArray(Vector3) Declaration public static float[] ToFloatArray(Vector3 v) Parameters Type Name Description Vector3 v Returns Type Description float[] | Improve this Doc View Source ToMatrix4x4(double[]) Declaration public static Matrix4x4 ToMatrix4x4(double[] d) Parameters Type Name Description double[] d Returns Type Description Matrix4x4 | Improve this Doc View Source ToMatrix4x4(float[]) Declaration public static Matrix4x4 ToMatrix4x4(float[] d) Parameters Type Name Description float[] d Returns Type Description Matrix4x4 | Improve this Doc View Source ToVector3(double[]) Declaration public static Vector3 ToVector3(double[] d) Parameters Type Name Description double[] d Returns Type Description Vector3 | Improve this Doc View Source ToVector3(float[]) Declaration public static Vector3 ToVector3(float[] d) Parameters Type Name Description float[] d Returns Type Description Vector3"
  },
  "api/IVLab.MinVR3.VREngine.html": {
    "href": "api/IVLab.MinVR3.VREngine.html",
    "title": "Class VREngine | MinVR3",
    "keywords": "Class VREngine This class is the main manager for any MinVR3 application. It's Script Priority is maxed out to make sure it is the first class that starts up when your application starts. On startup, the first thing it will do is enable the VRConfig that you have selected as the \"Startup VRConfig\" and disable all other VRConfigs it finds in the scene. You can set the Startup VRConfig via the Inspector by modifying its value under the VRConfigManager component that is attached to the VREngine GameObject. OR, you can set the Startup VRConfig using command line arguments. This is especially useful when running in a cluster mode, when you may have a run script that starts several instances of the same application but each with a different VRConfig. While your application is running, VREngine's main job is to handle VREvents. VREngine.instance.eventManager acts as the event manager for the whole application. If running in cluster mode, VREngine will make sure its eventManager is synched up each frame with the eventManagers on all of cluster nodes. In cluster mode, the VREngine also synchronizes the graphics \"SwapBuffers\" calls across all nodes so that each node displays the same frame at exactly the same time. VREngine is implmented using a Singleton that makes sure there is only ever one instance of the VREngine that exists at a time and that this instance persists across scene loads and unloads and is not destroyed until the application quits. You should access this single instance of the VREngine class via the static instance variable, like this: VREngine.instance From there, you can access the key classes that VREngine uses to manage the application. For example: VREngine.instance.eventManager VREngine.instance.configManager VREngine.instance.roomSpaceOrigin An important implementation detail is that these key classes are not themselves Singletons, but since we only ever access them through VREngine.instance, they act a bit like singletons in practice. MinVR is designed so that VREngine is the one singleton in the MinVR3 codebase, and the one VREngine.instance that it provides includes critical services like an eventManger, configManger, etc. While, technically speaking, one could add additional VREventMangers or VRConfigManagers to a scene, we can't (today) imagine a situation where that would be useful. Generally, when you want to access to a VREventManager, you will want to access the one being used by the VREngine. This design is an example of a Singleton that uses a \"Service Provider\" pattern. Singletons can be super useful, but they are like \"bringing out the big guns\". It's a really big design decision to decide a class should be a Singleton because they are difficult to work with in Unity's editor, and if the assumption that there will only ever be one instance of the class ever changes, it usually requires a major refactoring of the code to \"undo\" the original decision to make the class a Singleton. We think MinVR3's approach of using just one VREngine singleton that provides access to key services implemented in other \"regular\" classes is a good \"best of both worlds\" approach. Inheritance object Object Component Behaviour MonoBehaviour Singleton<VREngine> VREngine Implements IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [RequireComponent(typeof(VRConfigManager))] [RequireComponent(typeof(VREventManager))] [DefaultExecutionOrder(-900)] public class VREngine : Singleton<VREngine>, IVREventProducer Fields | Improve this Doc View Source ScriptPriority This class is the main manager for any MinVR3 application. It's Script Priority is maxed out to make sure it is the first class that starts up when your application starts. On startup, the first thing it will do is enable the VRConfig that you have selected as the \"Startup VRConfig\" and disable all other VRConfigs it finds in the scene. You can set the Startup VRConfig via the Inspector by modifying its value under the VRConfigManager component that is attached to the VREngine GameObject. OR, you can set the Startup VRConfig using command line arguments. This is especially useful when running in a cluster mode, when you may have a run script that starts several instances of the same application but each with a different VRConfig. While your application is running, VREngine's main job is to handle VREvents. VREngine.instance.eventManager acts as the event manager for the whole application. If running in cluster mode, VREngine will make sure its eventManager is synched up each frame with the eventManagers on all of cluster nodes. In cluster mode, the VREngine also synchronizes the graphics \"SwapBuffers\" calls across all nodes so that each node displays the same frame at exactly the same time. VREngine is implmented using a Singleton that makes sure there is only ever one instance of the VREngine that exists at a time and that this instance persists across scene loads and unloads and is not destroyed until the application quits. You should access this single instance of the VREngine class via the static instance variable, like this: VREngine.instance From there, you can access the key classes that VREngine uses to manage the application. For example: VREngine.instance.eventManager VREngine.instance.configManager VREngine.instance.roomSpaceOrigin An important implementation detail is that these key classes are not themselves Singletons, but since we only ever access them through VREngine.instance, they act a bit like singletons in practice. MinVR is designed so that VREngine is the one singleton in the MinVR3 codebase, and the one VREngine.instance that it provides includes critical services like an eventManger, configManger, etc. While, technically speaking, one could add additional VREventMangers or VRConfigManagers to a scene, we can't (today) imagine a situation where that would be useful. Generally, when you want to access to a VREventManager, you will want to access the one being used by the VREngine. This design is an example of a Singleton that uses a \"Service Provider\" pattern. Singletons can be super useful, but they are like \"bringing out the big guns\". It's a really big design decision to decide a class should be a Singleton because they are difficult to work with in Unity's editor, and if the assumption that there will only ever be one instance of the class ever changes, it usually requires a major refactoring of the code to \"undo\" the original decision to make the class a Singleton. We think MinVR3's approach of using just one VREngine singleton that provides access to key services implemented in other \"regular\" classes is a good \"best of both worlds\" approach. Declaration public const int ScriptPriority = -900 Field Value Type Description int Properties | Improve this Doc View Source DeltaTimeEventPrototype Time event for delta time synchronization across nodes in a network. Useful for implementing animations on a clustered setup where Time.deltaTime may be different on individual nodes and it's useful to have a \"ground truth\" timing event. By default, this gets sent in Update() for both cluster and non-cluster setups. Declaration public static VREventPrototypeFloat DeltaTimeEventPrototype { get; } Property Value Type Description VREventPrototypeFloat | Improve this Doc View Source ShutdownEventPrototype Shutdown event that gets sent when Unity is quitting. This event gets sent when the user has pressed the play button to \"unplay\" the app in editor, or quits the built application. Declaration public static VREventPrototype ShutdownEventPrototype { get; } Property Value Type Description VREventPrototype | Improve this Doc View Source configManager This class is the main manager for any MinVR3 application. It's Script Priority is maxed out to make sure it is the first class that starts up when your application starts. On startup, the first thing it will do is enable the VRConfig that you have selected as the \"Startup VRConfig\" and disable all other VRConfigs it finds in the scene. You can set the Startup VRConfig via the Inspector by modifying its value under the VRConfigManager component that is attached to the VREngine GameObject. OR, you can set the Startup VRConfig using command line arguments. This is especially useful when running in a cluster mode, when you may have a run script that starts several instances of the same application but each with a different VRConfig. While your application is running, VREngine's main job is to handle VREvents. VREngine.instance.eventManager acts as the event manager for the whole application. If running in cluster mode, VREngine will make sure its eventManager is synched up each frame with the eventManagers on all of cluster nodes. In cluster mode, the VREngine also synchronizes the graphics \"SwapBuffers\" calls across all nodes so that each node displays the same frame at exactly the same time. VREngine is implmented using a Singleton that makes sure there is only ever one instance of the VREngine that exists at a time and that this instance persists across scene loads and unloads and is not destroyed until the application quits. You should access this single instance of the VREngine class via the static instance variable, like this: VREngine.instance From there, you can access the key classes that VREngine uses to manage the application. For example: VREngine.instance.eventManager VREngine.instance.configManager VREngine.instance.roomSpaceOrigin An important implementation detail is that these key classes are not themselves Singletons, but since we only ever access them through VREngine.instance, they act a bit like singletons in practice. MinVR is designed so that VREngine is the one singleton in the MinVR3 codebase, and the one VREngine.instance that it provides includes critical services like an eventManger, configManger, etc. While, technically speaking, one could add additional VREventMangers or VRConfigManagers to a scene, we can't (today) imagine a situation where that would be useful. Generally, when you want to access to a VREventManager, you will want to access the one being used by the VREngine. This design is an example of a Singleton that uses a \"Service Provider\" pattern. Singletons can be super useful, but they are like \"bringing out the big guns\". It's a really big design decision to decide a class should be a Singleton because they are difficult to work with in Unity's editor, and if the assumption that there will only ever be one instance of the class ever changes, it usually requires a major refactoring of the code to \"undo\" the original decision to make the class a Singleton. We think MinVR3's approach of using just one VREngine singleton that provides access to key services implemented in other \"regular\" classes is a good \"best of both worlds\" approach. Declaration public VRConfigManager configManager { get; } Property Value Type Description VRConfigManager | Improve this Doc View Source eventManager This class is the main manager for any MinVR3 application. It's Script Priority is maxed out to make sure it is the first class that starts up when your application starts. On startup, the first thing it will do is enable the VRConfig that you have selected as the \"Startup VRConfig\" and disable all other VRConfigs it finds in the scene. You can set the Startup VRConfig via the Inspector by modifying its value under the VRConfigManager component that is attached to the VREngine GameObject. OR, you can set the Startup VRConfig using command line arguments. This is especially useful when running in a cluster mode, when you may have a run script that starts several instances of the same application but each with a different VRConfig. While your application is running, VREngine's main job is to handle VREvents. VREngine.instance.eventManager acts as the event manager for the whole application. If running in cluster mode, VREngine will make sure its eventManager is synched up each frame with the eventManagers on all of cluster nodes. In cluster mode, the VREngine also synchronizes the graphics \"SwapBuffers\" calls across all nodes so that each node displays the same frame at exactly the same time. VREngine is implmented using a Singleton that makes sure there is only ever one instance of the VREngine that exists at a time and that this instance persists across scene loads and unloads and is not destroyed until the application quits. You should access this single instance of the VREngine class via the static instance variable, like this: VREngine.instance From there, you can access the key classes that VREngine uses to manage the application. For example: VREngine.instance.eventManager VREngine.instance.configManager VREngine.instance.roomSpaceOrigin An important implementation detail is that these key classes are not themselves Singletons, but since we only ever access them through VREngine.instance, they act a bit like singletons in practice. MinVR is designed so that VREngine is the one singleton in the MinVR3 codebase, and the one VREngine.instance that it provides includes critical services like an eventManger, configManger, etc. While, technically speaking, one could add additional VREventMangers or VRConfigManagers to a scene, we can't (today) imagine a situation where that would be useful. Generally, when you want to access to a VREventManager, you will want to access the one being used by the VREngine. This design is an example of a Singleton that uses a \"Service Provider\" pattern. Singletons can be super useful, but they are like \"bringing out the big guns\". It's a really big design decision to decide a class should be a Singleton because they are difficult to work with in Unity's editor, and if the assumption that there will only ever be one instance of the class ever changes, it usually requires a major refactoring of the code to \"undo\" the original decision to make the class a Singleton. We think MinVR3's approach of using just one VREngine singleton that provides access to key services implemented in other \"regular\" classes is a good \"best of both worlds\" approach. Declaration public VREventManager eventManager { get; } Property Value Type Description VREventManager | Improve this Doc View Source roomSpaceOrigin This class is the main manager for any MinVR3 application. It's Script Priority is maxed out to make sure it is the first class that starts up when your application starts. On startup, the first thing it will do is enable the VRConfig that you have selected as the \"Startup VRConfig\" and disable all other VRConfigs it finds in the scene. You can set the Startup VRConfig via the Inspector by modifying its value under the VRConfigManager component that is attached to the VREngine GameObject. OR, you can set the Startup VRConfig using command line arguments. This is especially useful when running in a cluster mode, when you may have a run script that starts several instances of the same application but each with a different VRConfig. While your application is running, VREngine's main job is to handle VREvents. VREngine.instance.eventManager acts as the event manager for the whole application. If running in cluster mode, VREngine will make sure its eventManager is synched up each frame with the eventManagers on all of cluster nodes. In cluster mode, the VREngine also synchronizes the graphics \"SwapBuffers\" calls across all nodes so that each node displays the same frame at exactly the same time. VREngine is implmented using a Singleton that makes sure there is only ever one instance of the VREngine that exists at a time and that this instance persists across scene loads and unloads and is not destroyed until the application quits. You should access this single instance of the VREngine class via the static instance variable, like this: VREngine.instance From there, you can access the key classes that VREngine uses to manage the application. For example: VREngine.instance.eventManager VREngine.instance.configManager VREngine.instance.roomSpaceOrigin An important implementation detail is that these key classes are not themselves Singletons, but since we only ever access them through VREngine.instance, they act a bit like singletons in practice. MinVR is designed so that VREngine is the one singleton in the MinVR3 codebase, and the one VREngine.instance that it provides includes critical services like an eventManger, configManger, etc. While, technically speaking, one could add additional VREventMangers or VRConfigManagers to a scene, we can't (today) imagine a situation where that would be useful. Generally, when you want to access to a VREventManager, you will want to access the one being used by the VREngine. This design is an example of a Singleton that uses a \"Service Provider\" pattern. Singletons can be super useful, but they are like \"bringing out the big guns\". It's a really big design decision to decide a class should be a Singleton because they are difficult to work with in Unity's editor, and if the assumption that there will only ever be one instance of the class ever changes, it usually requires a major refactoring of the code to \"undo\" the original decision to make the class a Singleton. We think MinVR3's approach of using just one VREngine singleton that provides access to key services implemented in other \"regular\" classes is a good \"best of both worlds\" approach. Declaration public RoomSpaceOrigin roomSpaceOrigin { get; } Property Value Type Description RoomSpaceOrigin Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source Start() This class is the main manager for any MinVR3 application. It's Script Priority is maxed out to make sure it is the first class that starts up when your application starts. On startup, the first thing it will do is enable the VRConfig that you have selected as the \"Startup VRConfig\" and disable all other VRConfigs it finds in the scene. You can set the Startup VRConfig via the Inspector by modifying its value under the VRConfigManager component that is attached to the VREngine GameObject. OR, you can set the Startup VRConfig using command line arguments. This is especially useful when running in a cluster mode, when you may have a run script that starts several instances of the same application but each with a different VRConfig. While your application is running, VREngine's main job is to handle VREvents. VREngine.instance.eventManager acts as the event manager for the whole application. If running in cluster mode, VREngine will make sure its eventManager is synched up each frame with the eventManagers on all of cluster nodes. In cluster mode, the VREngine also synchronizes the graphics \"SwapBuffers\" calls across all nodes so that each node displays the same frame at exactly the same time. VREngine is implmented using a Singleton that makes sure there is only ever one instance of the VREngine that exists at a time and that this instance persists across scene loads and unloads and is not destroyed until the application quits. You should access this single instance of the VREngine class via the static instance variable, like this: VREngine.instance From there, you can access the key classes that VREngine uses to manage the application. For example: VREngine.instance.eventManager VREngine.instance.configManager VREngine.instance.roomSpaceOrigin An important implementation detail is that these key classes are not themselves Singletons, but since we only ever access them through VREngine.instance, they act a bit like singletons in practice. MinVR is designed so that VREngine is the one singleton in the MinVR3 codebase, and the one VREngine.instance that it provides includes critical services like an eventManger, configManger, etc. While, technically speaking, one could add additional VREventMangers or VRConfigManagers to a scene, we can't (today) imagine a situation where that would be useful. Generally, when you want to access to a VREventManager, you will want to access the one being used by the VREngine. This design is an example of a Singleton that uses a \"Service Provider\" pattern. Singletons can be super useful, but they are like \"bringing out the big guns\". It's a really big design decision to decide a class should be a Singleton because they are difficult to work with in Unity's editor, and if the assumption that there will only ever be one instance of the class ever changes, it usually requires a major refactoring of the code to \"undo\" the original decision to make the class a Singleton. We think MinVR3's approach of using just one VREngine singleton that provides access to key services implemented in other \"regular\" classes is a good \"best of both worlds\" approach. Declaration public void Start() | Improve this Doc View Source Update() This class is the main manager for any MinVR3 application. It's Script Priority is maxed out to make sure it is the first class that starts up when your application starts. On startup, the first thing it will do is enable the VRConfig that you have selected as the \"Startup VRConfig\" and disable all other VRConfigs it finds in the scene. You can set the Startup VRConfig via the Inspector by modifying its value under the VRConfigManager component that is attached to the VREngine GameObject. OR, you can set the Startup VRConfig using command line arguments. This is especially useful when running in a cluster mode, when you may have a run script that starts several instances of the same application but each with a different VRConfig. While your application is running, VREngine's main job is to handle VREvents. VREngine.instance.eventManager acts as the event manager for the whole application. If running in cluster mode, VREngine will make sure its eventManager is synched up each frame with the eventManagers on all of cluster nodes. In cluster mode, the VREngine also synchronizes the graphics \"SwapBuffers\" calls across all nodes so that each node displays the same frame at exactly the same time. VREngine is implmented using a Singleton that makes sure there is only ever one instance of the VREngine that exists at a time and that this instance persists across scene loads and unloads and is not destroyed until the application quits. You should access this single instance of the VREngine class via the static instance variable, like this: VREngine.instance From there, you can access the key classes that VREngine uses to manage the application. For example: VREngine.instance.eventManager VREngine.instance.configManager VREngine.instance.roomSpaceOrigin An important implementation detail is that these key classes are not themselves Singletons, but since we only ever access them through VREngine.instance, they act a bit like singletons in practice. MinVR is designed so that VREngine is the one singleton in the MinVR3 codebase, and the one VREngine.instance that it provides includes critical services like an eventManger, configManger, etc. While, technically speaking, one could add additional VREventMangers or VRConfigManagers to a scene, we can't (today) imagine a situation where that would be useful. Generally, when you want to access to a VREventManager, you will want to access the one being used by the VREngine. This design is an example of a Singleton that uses a \"Service Provider\" pattern. Singletons can be super useful, but they are like \"bringing out the big guns\". It's a really big design decision to decide a class should be a Singleton because they are difficult to work with in Unity's editor, and if the assumption that there will only ever be one instance of the class ever changes, it usually requires a major refactoring of the code to \"undo\" the original decision to make the class a Singleton. We think MinVR3's approach of using just one VREngine singleton that provides access to key services implemented in other \"regular\" classes is a good \"best of both worlds\" approach. Declaration public void Update() Implements IVREventProducer"
  },
  "api/IVLab.MinVR3.VREngineEditor.html": {
    "href": "api/IVLab.MinVR3.VREngineEditor.html",
    "title": "Class VREngineEditor | MinVR3",
    "keywords": "Class VREngineEditor Inheritance object Object ScriptableObject Editor VREngineEditor Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomEditor(typeof(VREngine))] public class VREngineEditor : Editor Methods | Improve this Doc View Source OnInspectorGUI() Implement this function to make a custom inspector. Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/IVLab.MinVR3.VREvent.html": {
    "href": "api/IVLab.MinVR3.VREvent.html",
    "title": "Class VREvent | MinVR3",
    "keywords": "Class VREvent Inheritance object VREvent VREventT<T> Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREvent : ISerializable Constructors | Improve this Doc View Source VREvent() Declaration public VREvent() | Improve this Doc View Source VREvent(SerializationInfo, StreamingContext) Declaration protected VREvent(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREvent(string) Declaration public VREvent(string eventName) Parameters Type Name Description string eventName Fields | Improve this Doc View Source m_DataTypeName Declaration [SerializeField] protected string m_DataTypeName Field Value Type Description string | Improve this Doc View Source m_Name Declaration [SerializeField] protected string m_Name Field Value Type Description string Properties | Improve this Doc View Source AvailableDataTypes Declaration public static Dictionary<string, Type> AvailableDataTypes { get; } Property Value Type Description Dictionary<string, Type> | Improve this Doc View Source name Declaration public string name { get; set; } Property Value Type Description string Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public virtual VREvent Clone() Returns Type Description VREvent | Improve this Doc View Source CreateFromJson(string) Declaration public static VREvent CreateFromJson(string eventJson) Parameters Type Name Description string eventJson Returns Type Description VREvent | Improve this Doc View Source GetDataTypeName() Declaration public string GetDataTypeName() Returns Type Description string | Improve this Doc View Source GetData<T>() Declaration public T GetData<T>() Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source GetName() Declaration public string GetName() Returns Type Description string | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public virtual void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source IsClusterSafe() True for raw VREvents created from input devices, trackers, etc. These need to be sent across the network to synchronize nodes when running in cluster mode so that all nodes receive the same input at the same time. It is also possible to use VREvents for message passing within an application, and in that case, the data might reference some local object like a GameObject. These are considered secondary (i.e., application-specific) events, and they should not be sent across the network because the reference to a local object will not transfer to another cluster node running a separate copy of the application. Instead, secondary events should be regenerated from the primary events by running the same secondary-event-producing script on each node in the cluster. Declaration public virtual bool IsClusterSafe() Returns Type Description bool | Improve this Doc View Source Matches(IVREventPrototype) Declaration public bool Matches(IVREventPrototype eventPrototype) Parameters Type Name Description IVREventPrototype eventPrototype Returns Type Description bool | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventAlias.AliasStrategy.html": {
    "href": "api/IVLab.MinVR3.VREventAlias.AliasStrategy.html",
    "title": "Enum VREventAlias.AliasStrategy | MinVR3",
    "keywords": "Enum VREventAlias.AliasStrategy Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum VREventAlias.AliasStrategy Fields Name Description RenameClone RenameOriginal"
  },
  "api/IVLab.MinVR3.VREventAlias.html": {
    "href": "api/IVLab.MinVR3.VREventAlias.html",
    "title": "Class VREventAlias | MinVR3",
    "keywords": "Class VREventAlias Inheritance object Object Component Behaviour MonoBehaviour VREventAlias Implements IVREventFilter IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Input/VREvent Alias\")] public class VREventAlias : MonoBehaviour, IVREventFilter, IVREventProducer Properties | Improve this Doc View Source aliasEventName Declaration public string aliasEventName { get; set; } Property Value Type Description string | Improve this Doc View Source aliasStrategy Declaration public VREventAlias.AliasStrategy aliasStrategy { get; set; } Property Value Type Description VREventAlias.AliasStrategy | Improve this Doc View Source originalEvents Declaration public List<VREventPrototypeAny> originalEvents { get; set; } Property Value Type Description List<VREventPrototypeAny> Methods | Improve this Doc View Source FilterEvent(VREvent, ref List<VREvent>) Each frame, IVREventFilters can process events and optionally modify them before the events are sent to IVREventListeners. The VREventManager passes each event through the active filters just before that event is to be sent out to listeners. A filter can then decide what to do with the event. For example, an EventAlias filter could change the name of the event. A ProximityEvent filter could listen for the position of two trackers and when they are within some threshold, generate a new event in response. A filter could also completely discard the event. the event from view of the IVREventListeners. Declaration public bool FilterEvent(VREvent e, ref List<VREvent> filterResult) Parameters Type Name Description VREvent e One event at a time is passed into the filter List<VREvent> filterResult If the filter modifies the event in some way, this list returns the result of those modifications. This parameter is a list rather than a single event since some filters may create a new event in response to the event and return both the original and the new events. This will essentially \"insert\" a new event in the event queue as it is processed. Returns Type Description bool true if the filter has modified the event in some way and returned the result in filterResult. falseif the event passes through the filter without change. | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. | Improve this Doc View Source Reset() Declaration protected virtual void Reset() Implements IVREventFilter IVREventProducer"
  },
  "api/IVLab.MinVR3.VREventCallback.html": {
    "href": "api/IVLab.MinVR3.VREventCallback.html",
    "title": "Class VREventCallback | MinVR3",
    "keywords": "Class VREventCallback Inheritance object VREventCallback Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallback : IVREventPrototype, IVRCallback, IVREventListener Constructors | Improve this Doc View Source VREventCallback() Declaration public VREventCallback() Methods | Improve this Doc View Source AddRuntimeListener(UnityAction) Declaration public void AddRuntimeListener(UnityAction listener) Parameters Type Name Description UnityAction listener | Improve this Doc View Source Clone() Declaration public IVREventPrototype Clone() Returns Type Description IVREventPrototype | Improve this Doc View Source CreateRuntime(VREventPrototype, UnityAction) Declaration public static VREventCallback CreateRuntime(VREventPrototype listenForEvent, UnityAction callbackFunc = null) Parameters Type Name Description VREventPrototype listenForEvent UnityAction callbackFunc Returns Type Description VREventCallback | Improve this Doc View Source CreateRuntime(string, UnityAction) Declaration public static VREventCallback CreateRuntime(string listenForEvent, UnityAction callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction callbackFunc Returns Type Description VREventCallback | Improve this Doc View Source GetEventDataTypeName() Declaration public string GetEventDataTypeName() Returns Type Description string | Improve this Doc View Source GetEventDisplayName() Declaration public string GetEventDisplayName() Returns Type Description string | Improve this Doc View Source GetEventName() Declaration public string GetEventName() Returns Type Description string | Improve this Doc View Source InvokeWithVREvent(VREvent) Declaration public void InvokeWithVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source RemoveRuntimeListener(UnityAction) Declaration public void RemoveRuntimeListener(UnityAction listener) Parameters Type Name Description UnityAction listener | Improve this Doc View Source SetEventName(string) Declaration public void SetEventName(string eventName) Parameters Type Name Description string eventName | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackAny.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackAny.html",
    "title": "Class VREventCallbackAny | MinVR3",
    "keywords": "Class VREventCallbackAny Inheritance object VREventCallbackAny Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackAny : IVREventPrototype, IVRCallback, IVREventListener Constructors | Improve this Doc View Source VREventCallbackAny() Declaration public VREventCallbackAny() Methods | Improve this Doc View Source AddRuntimeListener(UnityAction) Declaration public void AddRuntimeListener(UnityAction listener) Parameters Type Name Description UnityAction listener | Improve this Doc View Source AddRuntimeListener<T>(UnityAction<T>) Declaration public void AddRuntimeListener<T>(UnityAction<T> listener) Parameters Type Name Description UnityAction<T> listener Type Parameters Name Description T | Improve this Doc View Source Clone() Declaration public IVREventPrototype Clone() Returns Type Description IVREventPrototype | Improve this Doc View Source CreateRuntime(VREventPrototype, UnityAction) Declaration public static VREventCallbackAny CreateRuntime(VREventPrototype listenForEvent, UnityAction callbackFunc = null) Parameters Type Name Description VREventPrototype listenForEvent UnityAction callbackFunc Returns Type Description VREventCallbackAny | Improve this Doc View Source CreateRuntime(string, UnityAction) Declaration public static VREventCallbackAny CreateRuntime(string listenForEvent, UnityAction callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction callbackFunc Returns Type Description VREventCallbackAny | Improve this Doc View Source CreateRuntime<T>(VREventPrototypeT<T>, UnityAction<T>) Declaration public static VREventCallbackAny CreateRuntime<T>(VREventPrototypeT<T> listenForEvent, UnityAction<T> callbackFunc = null) Parameters Type Name Description VREventPrototypeT<T> listenForEvent UnityAction<T> callbackFunc Returns Type Description VREventCallbackAny Type Parameters Name Description T | Improve this Doc View Source CreateRuntime<T>(string, UnityAction<T>) Declaration public static VREventCallbackAny CreateRuntime<T>(string listenForEvent, UnityAction<T> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<T> callbackFunc Returns Type Description VREventCallbackAny Type Parameters Name Description T | Improve this Doc View Source GetEventDataTypeName() Declaration public string GetEventDataTypeName() Returns Type Description string | Improve this Doc View Source GetEventDisplayName() Declaration public string GetEventDisplayName() Returns Type Description string | Improve this Doc View Source GetEventName() Declaration public string GetEventName() Returns Type Description string | Improve this Doc View Source InvokeWithVREvent(VREvent) Declaration public void InvokeWithVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source RemoveRuntimeListener(UnityAction) Declaration public void RemoveRuntimeListener(UnityAction listener) Parameters Type Name Description UnityAction listener | Improve this Doc View Source RemoveRuntimeListener<T>(UnityAction<T>) Declaration public void RemoveRuntimeListener<T>(UnityAction<T> listener) Parameters Type Name Description UnityAction<T> listener Type Parameters Name Description T | Improve this Doc View Source SetEventDataType(string) Declaration public void SetEventDataType(string eventDataTypeName) Parameters Type Name Description string eventDataTypeName | Improve this Doc View Source SetEventDataType(Type) Declaration public void SetEventDataType(Type eventDataType) Parameters Type Name Description Type eventDataType | Improve this Doc View Source SetEventName(string) Declaration public void SetEventName(string eventName) Parameters Type Name Description string eventName | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() | Improve this Doc View Source SupportsDataType(string) Declaration public bool SupportsDataType(string dataTypeName) Parameters Type Name Description string dataTypeName Returns Type Description bool | Improve this Doc View Source SupportsDataType(Type) Declaration public bool SupportsDataType(Type dataType) Parameters Type Name Description Type dataType Returns Type Description bool Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackAnyDrawer.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackAnyDrawer.html",
    "title": "Class VREventCallbackAnyDrawer | MinVR3",
    "keywords": "Class VREventCallbackAnyDrawer Inheritance object GUIDrawer PropertyDrawer VREventCallbackDrawer VREventCallbackAnyDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VREventCallbackAny), true)] public class VREventCallbackAnyDrawer : VREventCallbackDrawer Methods | Improve this Doc View Source OnEventPrototypeChanged(SerializedProperty, SerializedProperty) Declaration public override void OnEventPrototypeChanged(SerializedProperty prototypeProp, SerializedProperty callbackProp) Parameters Type Name Description SerializedProperty prototypeProp SerializedProperty callbackProp Overrides VREventCallbackDrawer.OnEventPrototypeChanged(SerializedProperty, SerializedProperty)"
  },
  "api/IVLab.MinVR3.VREventCallbackDrawer.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackDrawer.html",
    "title": "Class VREventCallbackDrawer | MinVR3",
    "keywords": "Class VREventCallbackDrawer Inheritance object GUIDrawer PropertyDrawer VREventCallbackDrawer VREventCallbackAnyDrawer VREventCallbackTDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VREventCallback), true)] public class VREventCallbackDrawer : PropertyDrawer Methods | Improve this Doc View Source GetPropertyHeight(SerializedProperty, GUIContent) Override this method to specify how tall the GUI for this field is in pixels. Declaration public override float GetPropertyHeight(SerializedProperty property, GUIContent label) Parameters Type Name Description SerializedProperty property The SerializedProperty to make the custom GUI for. GUIContent label The label of this property. Returns Type Description float The height in pixels. Overrides UnityEditor.PropertyDrawer.GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent) | Improve this Doc View Source OnEventPrototypeChanged(SerializedProperty, SerializedProperty) Declaration public virtual void OnEventPrototypeChanged(SerializedProperty prototypeProp, SerializedProperty callbackProp) Parameters Type Name Description SerializedProperty prototypeProp SerializedProperty callbackProp | Improve this Doc View Source OnGUI(Rect, SerializedProperty, GUIContent) Override this method to make your own IMGUI based GUI for the property. Declaration public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) Parameters Type Name Description Rect position Rectangle on the screen to use for the property GUI. SerializedProperty property The SerializedProperty to make the custom GUI for. GUIContent label The label of this property. Overrides UnityEditor.PropertyDrawer.OnGUI(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.GUIContent)"
  },
  "api/IVLab.MinVR3.VREventCallbackFloat.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackFloat.html",
    "title": "Class VREventCallbackFloat | MinVR3",
    "keywords": "Class VREventCallbackFloat Inheritance object VREventCallbackT<float> VREventCallbackFloat Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackFloat : VREventCallbackT<float>, IVREventPrototype, IVRCallback, IVREventListener Methods | Improve this Doc View Source CreateRuntime(VREventPrototypeFloat, UnityAction<float>) Declaration public static VREventCallbackFloat CreateRuntime(VREventPrototypeFloat listenForEvent, UnityAction<float> callbackFunc = null) Parameters Type Name Description VREventPrototypeFloat listenForEvent UnityAction<float> callbackFunc Returns Type Description VREventCallbackFloat | Improve this Doc View Source CreateRuntime(string, UnityAction<float>) Declaration public static VREventCallbackFloat CreateRuntime(string listenForEvent, UnityAction<float> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<float> callbackFunc Returns Type Description VREventCallbackFloat Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackGameObject.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackGameObject.html",
    "title": "Class VREventCallbackGameObject | MinVR3",
    "keywords": "Class VREventCallbackGameObject Inheritance object VREventCallbackT<GameObject> VREventCallbackGameObject Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackGameObject : VREventCallbackT<GameObject>, IVREventPrototype, IVRCallback, IVREventListener Methods | Improve this Doc View Source CreateRuntime(VREventPrototypeGameObject, UnityAction<GameObject>) Declaration public static VREventCallbackGameObject CreateRuntime(VREventPrototypeGameObject listenForEvent, UnityAction<GameObject> callbackFunc = null) Parameters Type Name Description VREventPrototypeGameObject listenForEvent UnityAction<GameObject> callbackFunc Returns Type Description VREventCallbackGameObject | Improve this Doc View Source CreateRuntime(string, UnityAction<GameObject>) Declaration public static VREventCallbackGameObject CreateRuntime(string listenForEvent, UnityAction<GameObject> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<GameObject> callbackFunc Returns Type Description VREventCallbackGameObject Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackInt.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackInt.html",
    "title": "Class VREventCallbackInt | MinVR3",
    "keywords": "Class VREventCallbackInt Inheritance object VREventCallbackT<int> VREventCallbackInt Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackInt : VREventCallbackT<int>, IVREventPrototype, IVRCallback, IVREventListener Methods | Improve this Doc View Source CreateRuntime(VREventPrototypeInt, UnityAction<int>) Declaration public static VREventCallbackInt CreateRuntime(VREventPrototypeInt listenForEvent, UnityAction<int> callbackFunc = null) Parameters Type Name Description VREventPrototypeInt listenForEvent UnityAction<int> callbackFunc Returns Type Description VREventCallbackInt | Improve this Doc View Source CreateRuntime(string, UnityAction<int>) Declaration public static VREventCallbackInt CreateRuntime(string listenForEvent, UnityAction<int> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<int> callbackFunc Returns Type Description VREventCallbackInt Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackQuaternion.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackQuaternion.html",
    "title": "Class VREventCallbackQuaternion | MinVR3",
    "keywords": "Class VREventCallbackQuaternion Inheritance object VREventCallbackT<Quaternion> VREventCallbackQuaternion Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackQuaternion : VREventCallbackT<Quaternion>, IVREventPrototype, IVRCallback, IVREventListener Methods | Improve this Doc View Source CreateRuntime(VREventPrototypeQuaternion, UnityAction<Quaternion>) Declaration public static VREventCallbackQuaternion CreateRuntime(VREventPrototypeQuaternion listenForEvent, UnityAction<Quaternion> callbackFunc = null) Parameters Type Name Description VREventPrototypeQuaternion listenForEvent UnityAction<Quaternion> callbackFunc Returns Type Description VREventCallbackQuaternion | Improve this Doc View Source CreateRuntime(string, UnityAction<Quaternion>) Declaration public static VREventCallbackQuaternion CreateRuntime(string listenForEvent, UnityAction<Quaternion> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<Quaternion> callbackFunc Returns Type Description VREventCallbackQuaternion Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackString.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackString.html",
    "title": "Class VREventCallbackString | MinVR3",
    "keywords": "Class VREventCallbackString Inheritance object VREventCallbackT<string> VREventCallbackString Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackString : VREventCallbackT<string>, IVREventPrototype, IVRCallback, IVREventListener Methods | Improve this Doc View Source CreateRuntime(VREventPrototypeString, UnityAction<string>) Declaration public static VREventCallbackString CreateRuntime(VREventPrototypeString listenForEvent, UnityAction<string> callbackFunc = null) Parameters Type Name Description VREventPrototypeString listenForEvent UnityAction<string> callbackFunc Returns Type Description VREventCallbackString | Improve this Doc View Source CreateRuntime(string, UnityAction<string>) Declaration public static VREventCallbackString CreateRuntime(string listenForEvent, UnityAction<string> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<string> callbackFunc Returns Type Description VREventCallbackString Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackT-1.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackT-1.html",
    "title": "Class VREventCallbackT<T> | MinVR3",
    "keywords": "Class VREventCallbackT<T> Inheritance object VREventCallbackT<T> VREventCallbackFloat VREventCallbackGameObject VREventCallbackInt VREventCallbackQuaternion VREventCallbackString VREventCallbackVector2 VREventCallbackVector3 VREventCallbackVector4 Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackT<T> : IVREventPrototype, IVRCallback, IVREventListener Type Parameters Name Description T Constructors | Improve this Doc View Source VREventCallbackT() Declaration public VREventCallbackT() Methods | Improve this Doc View Source AddRuntimeListener(UnityAction<T>) Declaration public void AddRuntimeListener(UnityAction<T> listener) Parameters Type Name Description UnityAction<T> listener | Improve this Doc View Source Clone() Declaration public IVREventPrototype Clone() Returns Type Description IVREventPrototype | Improve this Doc View Source GetEventDataTypeName() Declaration public string GetEventDataTypeName() Returns Type Description string | Improve this Doc View Source GetEventDisplayName() Declaration public string GetEventDisplayName() Returns Type Description string | Improve this Doc View Source GetEventName() Declaration public string GetEventName() Returns Type Description string | Improve this Doc View Source InvokeWithVREvent(VREvent) Declaration public void InvokeWithVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source OnVREvent(VREvent) Declaration public void OnVREvent(VREvent vrEvent) Parameters Type Name Description VREvent vrEvent | Improve this Doc View Source RemoveRuntimeListener(UnityAction<T>) Declaration public void RemoveRuntimeListener(UnityAction<T> listener) Parameters Type Name Description UnityAction<T> listener | Improve this Doc View Source SetEventName(string) Declaration public void SetEventName(string eventName) Parameters Type Name Description string eventName | Improve this Doc View Source StartListening() Declaration public void StartListening() | Improve this Doc View Source StopListening() Declaration public void StopListening() Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackTDrawer.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackTDrawer.html",
    "title": "Class VREventCallbackTDrawer | MinVR3",
    "keywords": "Class VREventCallbackTDrawer Inheritance object GUIDrawer PropertyDrawer VREventCallbackDrawer VREventCallbackTDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VREventCallbackT<>), true)] public class VREventCallbackTDrawer : VREventCallbackDrawer"
  },
  "api/IVLab.MinVR3.VREventCallbackVector2.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackVector2.html",
    "title": "Class VREventCallbackVector2 | MinVR3",
    "keywords": "Class VREventCallbackVector2 Inheritance object VREventCallbackT<Vector2> VREventCallbackVector2 Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackVector2 : VREventCallbackT<Vector2>, IVREventPrototype, IVRCallback, IVREventListener Methods | Improve this Doc View Source CreateRuntime(VREventPrototypeVector2, UnityAction<Vector2>) Declaration public static VREventCallbackVector2 CreateRuntime(VREventPrototypeVector2 listenForEvent, UnityAction<Vector2> callbackFunc = null) Parameters Type Name Description VREventPrototypeVector2 listenForEvent UnityAction<Vector2> callbackFunc Returns Type Description VREventCallbackVector2 | Improve this Doc View Source CreateRuntime(string, UnityAction<Vector2>) Declaration public static VREventCallbackVector2 CreateRuntime(string listenForEvent, UnityAction<Vector2> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<Vector2> callbackFunc Returns Type Description VREventCallbackVector2 Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackVector3.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackVector3.html",
    "title": "Class VREventCallbackVector3 | MinVR3",
    "keywords": "Class VREventCallbackVector3 Inheritance object VREventCallbackT<Vector3> VREventCallbackVector3 Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackVector3 : VREventCallbackT<Vector3>, IVREventPrototype, IVRCallback, IVREventListener Methods | Improve this Doc View Source CreateRuntime(VREventPrototypeVector3, UnityAction<Vector3>) Declaration public static VREventCallbackVector3 CreateRuntime(VREventPrototypeVector3 listenForEvent, UnityAction<Vector3> callbackFunc = null) Parameters Type Name Description VREventPrototypeVector3 listenForEvent UnityAction<Vector3> callbackFunc Returns Type Description VREventCallbackVector3 | Improve this Doc View Source CreateRuntime(string, UnityAction<Vector3>) Declaration public static VREventCallbackVector3 CreateRuntime(string listenForEvent, UnityAction<Vector3> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<Vector3> callbackFunc Returns Type Description VREventCallbackVector3 Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventCallbackVector4.html": {
    "href": "api/IVLab.MinVR3.VREventCallbackVector4.html",
    "title": "Class VREventCallbackVector4 | MinVR3",
    "keywords": "Class VREventCallbackVector4 Inheritance object VREventCallbackT<Vector4> VREventCallbackVector4 Implements IVREventPrototype IVRCallback IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventCallbackVector4 : VREventCallbackT<Vector4>, IVREventPrototype, IVRCallback, IVREventListener Methods | Improve this Doc View Source CreateRuntime(VREventPrototypeVector4, UnityAction<Vector4>) Declaration public static VREventCallbackVector4 CreateRuntime(VREventPrototypeVector4 listenForEvent, UnityAction<Vector4> callbackFunc = null) Parameters Type Name Description VREventPrototypeVector4 listenForEvent UnityAction<Vector4> callbackFunc Returns Type Description VREventCallbackVector4 | Improve this Doc View Source CreateRuntime(string, UnityAction<Vector4>) Declaration public static VREventCallbackVector4 CreateRuntime(string listenForEvent, UnityAction<Vector4> callbackFunc = null) Parameters Type Name Description string listenForEvent UnityAction<Vector4> callbackFunc Returns Type Description VREventCallbackVector4 Implements IVREventPrototype IVRCallback IVREventListener"
  },
  "api/IVLab.MinVR3.VREventConnectionReceiver.html": {
    "href": "api/IVLab.MinVR3.VREventConnectionReceiver.html",
    "title": "Class VREventConnectionReceiver | MinVR3",
    "keywords": "Class VREventConnectionReceiver MonoBehaviour that receives events sent over a VREventConnection and places them in the VR Event Manager's Queue. There are two common uses for this class: To implement a virtual input device with data sent over a network connection. This class can receive events generated by some other app, even a webpage, and insert the events received into the VREventManager's queue, just as if the events were generated from a local input device. In this case, this component will probably be the only place in your scene where such events would be \"produced\", so it is important for the class to specify a VREventPrototype for each event it expects to receive. For sharing event data between multiple MinVR applications and when the strict, frame-level synchronization of events and rendering provided by MinVR's cluster mode is not required. While cluster-mode works well for tiled dispalys powered by a cluster of identical machines, this class is useful for synchronizing event data across heterogeneous devices used together by a single user (e.g., an AR headset used together with a multi- touch tablet) or in multi-user situations (e.g., multiple users each wearning their own HMD). In these sitautions, the connection may just be responsible for sending/receiving events that are already defined with VREventPrototypes elsewhere in the scene. If that is the case, it it not necessary (but also does not hurt) to redefine the prototypes within this cass. See also VREventConnectionSender. (formerly ConnectionVREventProducer) Inheritance object Object Component Behaviour MonoBehaviour VREventConnectionReceiver Implements IVREventProducer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [RequireComponent(typeof(IVREventConnection))] [ExecuteInEditMode] [AddComponentMenu(\"MinVR/Connection/VREventConnectionReceiver\")] public class VREventConnectionReceiver : MonoBehaviour, IVREventProducer Properties | Improve this Doc View Source eventPrototypes MonoBehaviour that receives events sent over a VREventConnection and places them in the VR Event Manager's Queue. There are two common uses for this class: To implement a virtual input device with data sent over a network connection. This class can receive events generated by some other app, even a webpage, and insert the events received into the VREventManager's queue, just as if the events were generated from a local input device. In this case, this component will probably be the only place in your scene where such events would be \"produced\", so it is important for the class to specify a VREventPrototype for each event it expects to receive. For sharing event data between multiple MinVR applications and when the strict, frame-level synchronization of events and rendering provided by MinVR's cluster mode is not required. While cluster-mode works well for tiled dispalys powered by a cluster of identical machines, this class is useful for synchronizing event data across heterogeneous devices used together by a single user (e.g., an AR headset used together with a multi- touch tablet) or in multi-user situations (e.g., multiple users each wearning their own HMD). In these sitautions, the connection may just be responsible for sending/receiving events that are already defined with VREventPrototypes elsewhere in the scene. If that is the case, it it not necessary (but also does not hurt) to redefine the prototypes within this cass. See also VREventConnectionSender. (formerly ConnectionVREventProducer) Declaration public List<VREventPrototypeAny> eventPrototypes { get; set; } Property Value Type Description List<VREventPrototypeAny> Methods | Improve this Doc View Source GetEventPrototypes() All event producers must implement this function to tell MinVR the names and data types for each possible event that can be produced. Declaration public List<IVREventPrototype> GetEventPrototypes() Returns Type Description List<IVREventPrototype> List of prototypes of events that can be produced at runtime. Implements IVREventProducer"
  },
  "api/IVLab.MinVR3.VREventConnectionReceiverEditor.html": {
    "href": "api/IVLab.MinVR3.VREventConnectionReceiverEditor.html",
    "title": "Class VREventConnectionReceiverEditor | MinVR3",
    "keywords": "Class VREventConnectionReceiverEditor Inheritance object Object ScriptableObject Editor VREventConnectionReceiverEditor Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomEditor(typeof(VREventConnectionReceiver))] public class VREventConnectionReceiverEditor : Editor Methods | Improve this Doc View Source OnEnable() Declaration public void OnEnable() | Improve this Doc View Source OnInspectorGUI() Implement this function to make a custom inspector. Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/IVLab.MinVR3.VREventConnectionSender.html": {
    "href": "api/IVLab.MinVR3.VREventConnectionSender.html",
    "title": "Class VREventConnectionSender | MinVR3",
    "keywords": "Class VREventConnectionSender Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Inheritance object Object Component Behaviour MonoBehaviour VREventConnectionSender Implements IVREventListener Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [RequireComponent(typeof(IVREventConnection))] [AddComponentMenu(\"MinVR/Connection/VREventConnectionSender\")] public class VREventConnectionSender : MonoBehaviour, IVREventListener Properties | Improve this Doc View Source noSendListPrototypes Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public List<VREventPrototypeAny> noSendListPrototypes { get; set; } Property Value Type Description List<VREventPrototypeAny> | Improve this Doc View Source noSendListStartsWithStrings Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public List<string> noSendListStartsWithStrings { get; set; } Property Value Type Description List<string> | Improve this Doc View Source sendListPrototypes Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public List<VREventPrototypeAny> sendListPrototypes { get; set; } Property Value Type Description List<VREventPrototypeAny> | Improve this Doc View Source sendListStartsWithStrings Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public List<string> sendListStartsWithStrings { get; set; } Property Value Type Description List<string> | Improve this Doc View Source useNoSendList Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public bool useNoSendList { get; set; } Property Value Type Description bool | Improve this Doc View Source useSendList Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public bool useSendList { get; set; } Property Value Type Description bool Methods | Improve this Doc View Source InNoSendList(VREvent) Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public bool InNoSendList(VREvent evt) Parameters Type Name Description VREvent evt Returns Type Description bool | Improve this Doc View Source InSendList(VREvent) Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public bool InSendList(VREvent evt) Parameters Type Name Description VREvent evt Returns Type Description bool | Improve this Doc View Source OnVREvent(VREvent) Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public void OnVREvent(VREvent evt) Parameters Type Name Description VREvent evt | Improve this Doc View Source StartListening() Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public void StartListening() | Improve this Doc View Source StopListening() Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) Declaration public void StopListening() Implements IVREventListener"
  },
  "api/IVLab.MinVR3.VREventConnectionSenderEditor.html": {
    "href": "api/IVLab.MinVR3.VREventConnectionSenderEditor.html",
    "title": "Class VREventConnectionSenderEditor | MinVR3",
    "keywords": "Class VREventConnectionSenderEditor Inheritance object Object ScriptableObject Editor VREventConnectionSenderEditor Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomEditor(typeof(VREventConnectionSender))] public class VREventConnectionSenderEditor : Editor Methods | Improve this Doc View Source OnEnable() Declaration public void OnEnable() | Improve this Doc View Source OnInspectorGUI() Implement this function to make a custom inspector. Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/IVLab.MinVR3.VREventFloat.html": {
    "href": "api/IVLab.MinVR3.VREventFloat.html",
    "title": "Class VREventFloat | MinVR3",
    "keywords": "Class VREventFloat Inheritance object VREvent VREventT<float> VREventFloat Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventFloat : VREventT<float>, ISerializable Constructors | Improve this Doc View Source VREventFloat(SerializationInfo, StreamingContext) Declaration protected VREventFloat(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREventFloat(string, float) Declaration public VREventFloat(string name, float data) Parameters Type Name Description string name float data Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public override VREvent Clone() Returns Type Description VREvent Overrides VREvent.Clone() | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Overrides VREventT<float>.GetObjectData(SerializationInfo, StreamingContext) Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventGameObject.html": {
    "href": "api/IVLab.MinVR3.VREventGameObject.html",
    "title": "Class VREventGameObject | MinVR3",
    "keywords": "Class VREventGameObject Inheritance object VREvent VREventT<GameObject> VREventGameObject Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventGameObject : VREventT<GameObject>, ISerializable Constructors | Improve this Doc View Source VREventGameObject(string, GameObject) Declaration public VREventGameObject(string name, GameObject data) Parameters Type Name Description string name GameObject data Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public override VREvent Clone() Returns Type Description VREvent Overrides VREvent.Clone() | Improve this Doc View Source IsClusterSafe() True for raw VREvents created from input devices, trackers, etc. These need to be sent across the network to synchronize nodes when running in cluster mode so that all nodes receive the same input at the same time. It is also possible to use VREvents for message passing within an application, and in that case, the data might reference some local object like a GameObject. These are considered secondary (i.e., application-specific) events, and they should not be sent across the network because the reference to a local object will not transfer to another cluster node running a separate copy of the application. Instead, secondary events should be regenerated from the primary events by running the same secondary-event-producing script on each node in the cluster. Declaration public override bool IsClusterSafe() Returns Type Description bool Overrides VREvent.IsClusterSafe() Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventInt.html": {
    "href": "api/IVLab.MinVR3.VREventInt.html",
    "title": "Class VREventInt | MinVR3",
    "keywords": "Class VREventInt Inheritance object VREvent VREventT<int> VREventInt Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventInt : VREventT<int>, ISerializable Constructors | Improve this Doc View Source VREventInt(SerializationInfo, StreamingContext) Declaration protected VREventInt(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREventInt(string, int) Declaration public VREventInt(string name, int data) Parameters Type Name Description string name int data Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public override VREvent Clone() Returns Type Description VREvent Overrides VREvent.Clone() | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Overrides VREventT<int>.GetObjectData(SerializationInfo, StreamingContext) Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventManager.html": {
    "href": "api/IVLab.MinVR3.VREventManager.html",
    "title": "Class VREventManager | MinVR3",
    "keywords": "Class VREventManager Inheritance object Object Component Behaviour MonoBehaviour VREventManager Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [DefaultExecutionOrder(-899)] [DisallowMultipleComponent] public class VREventManager : MonoBehaviour Fields | Improve this Doc View Source DefaultListenerPriority Declaration public const int DefaultListenerPriority = 10 Field Value Type Description int | Improve this Doc View Source ScriptPriority Declaration public const int ScriptPriority = -899 Field Value Type Description int | Improve this Doc View Source m_DebugOutputFilter Declaration [Tooltip(\"Logs events to the console as they are processed\")] public string m_DebugOutputFilter Field Value Type Description string | Improve this Doc View Source m_ShowDebuggingOutput Declaration [Tooltip(\"Logs events to the console as they are processed\")] public bool m_ShowDebuggingOutput Field Value Type Description bool Methods | Improve this Doc View Source AddEventFilter(IVREventFilter) Declaration public void AddEventFilter(IVREventFilter filter) Parameters Type Name Description IVREventFilter filter | Improve this Doc View Source AddEventFilter(IVREventFilter, int) Add an event filter and specify the priority (index) with which it should be run relative to other event filters. Declaration public void AddEventFilter(IVREventFilter filter, int priority) Parameters Type Name Description IVREventFilter filter int priority | Improve this Doc View Source AddEventListener(IVREventListener, int) Declaration public void AddEventListener(IVREventListener listener, int priority = 10) Parameters Type Name Description IVREventListener listener int priority | Improve this Doc View Source AddPolledInputDevice(IPolledInputDevice) Declaration public void AddPolledInputDevice(IPolledInputDevice device) Parameters Type Name Description IPolledInputDevice device | Improve this Doc View Source GetAllEventPrototypes() Not fast; intended only for populating dropdown lists in the Unity Editor Declaration public static List<IVREventPrototype> GetAllEventPrototypes() Returns Type Description List<IVREventPrototype> A list of all events produced by all sources | Improve this Doc View Source GetEventQueue() Declaration public List<VREvent> GetEventQueue() Returns Type Description List<VREvent> | Improve this Doc View Source GetMatchingEventPrototypes(string, bool) Not fast; intended only for populating dropdown lists in the Unity Editor. For a given data type, the dataTypeString should be equal to the value returned by typeof(T).Name. The string \"\" will match events that do not have a data payload, and the wildcard character * will match events of any datatype. Declaration public static List<IVREventPrototype> GetMatchingEventPrototypes(string dataTypeName, bool includeInactive = true) Parameters Type Name Description string dataTypeName bool includeInactive Returns Type Description List<IVREventPrototype> A list of all events with the specified datatype produced by all sources | Improve this Doc View Source InsertInQueue(VREvent) Declaration public void InsertInQueue(VREvent e) Parameters Type Name Description VREvent e | Improve this Doc View Source PollInputDevices() Declaration public void PollInputDevices() | Improve this Doc View Source ProcessEvent(VREvent) Declaration public void ProcessEvent(VREvent e) Parameters Type Name Description VREvent e | Improve this Doc View Source ProcessEventQueue() Declaration public void ProcessEventQueue() | Improve this Doc View Source QueueEvent(VREvent) Declaration public void QueueEvent(VREvent e) Parameters Type Name Description VREvent e | Improve this Doc View Source QueueEvent(int, VREvent) Declaration public void QueueEvent(int index, VREvent e) Parameters Type Name Description int index VREvent e | Improve this Doc View Source RemoveEventFilter(IVREventFilter) Declaration public void RemoveEventFilter(IVREventFilter filter) Parameters Type Name Description IVREventFilter filter | Improve this Doc View Source RemoveEventListener(IVREventListener) Declaration public void RemoveEventListener(IVREventListener listener) Parameters Type Name Description IVREventListener listener | Improve this Doc View Source RemovePolledInputDevice(IPolledInputDevice) Declaration public void RemovePolledInputDevice(IPolledInputDevice device) Parameters Type Name Description IPolledInputDevice device | Improve this Doc View Source SetEventQueue(List<VREvent>) Declaration public void SetEventQueue(List<VREvent> newQueue) Parameters Type Name Description List<VREvent> newQueue | Improve this Doc View Source Update() Declaration public void Update()"
  },
  "api/IVLab.MinVR3.VREventManagerEditor.html": {
    "href": "api/IVLab.MinVR3.VREventManagerEditor.html",
    "title": "Class VREventManagerEditor | MinVR3",
    "keywords": "Class VREventManagerEditor Inheritance object Object ScriptableObject Editor VREventManagerEditor Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomEditor(typeof(VREventManager))] public class VREventManagerEditor : Editor Methods | Improve this Doc View Source OnInspectorGUI() Implement this function to make a custom inspector. Declaration public override void OnInspectorGUI() Overrides Editor.OnInspectorGUI()"
  },
  "api/IVLab.MinVR3.VREventPrototype.html": {
    "href": "api/IVLab.MinVR3.VREventPrototype.html",
    "title": "Class VREventPrototype | MinVR3",
    "keywords": "Class VREventPrototype Inheritance object VREventPrototype Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototype : IVREventPrototype Constructors | Improve this Doc View Source VREventPrototype() Declaration public VREventPrototype() Fields | Improve this Doc View Source m_EventName Declaration [SerializeField] protected string m_EventName Field Value Type Description string Methods | Improve this Doc View Source Clone() Declaration public virtual IVREventPrototype Clone() Returns Type Description IVREventPrototype | Improve this Doc View Source Create(string) Declaration public static VREventPrototype Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototype | Improve this Doc View Source GetEventDataTypeName() Declaration public string GetEventDataTypeName() Returns Type Description string | Improve this Doc View Source GetEventDisplayName() Declaration public string GetEventDisplayName() Returns Type Description string | Improve this Doc View Source GetEventName() Declaration public string GetEventName() Returns Type Description string | Improve this Doc View Source SetEventName(string) Declaration public void SetEventName(string eventName) Parameters Type Name Description string eventName Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeAny.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeAny.html",
    "title": "Class VREventPrototypeAny | MinVR3",
    "keywords": "Class VREventPrototypeAny Inheritance object VREventPrototypeAny Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeAny : IVREventPrototype Constructors | Improve this Doc View Source VREventPrototypeAny() Declaration public VREventPrototypeAny() Properties | Improve this Doc View Source AllEventPrototypes Declaration public Dictionary<string, IVREventPrototype> AllEventPrototypes { get; } Property Value Type Description Dictionary<string, IVREventPrototype> Methods | Improve this Doc View Source Clone() Declaration public IVREventPrototype Clone() Returns Type Description IVREventPrototype | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeAny Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeAny | Improve this Doc View Source Create<T>(string) Declaration public static VREventPrototypeAny Create<T>(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeAny Type Parameters Name Description T | Improve this Doc View Source DataTypeLocked() Declaration public bool DataTypeLocked() Returns Type Description bool | Improve this Doc View Source GetEventDataTypeName() Declaration public string GetEventDataTypeName() Returns Type Description string | Improve this Doc View Source GetEventDisplayName() Declaration public string GetEventDisplayName() Returns Type Description string | Improve this Doc View Source GetEventName() Declaration public string GetEventName() Returns Type Description string | Improve this Doc View Source LockDataType() Declaration public void LockDataType() | Improve this Doc View Source SetDefineNewPrototypeInEditor(bool) Declaration public void SetDefineNewPrototypeInEditor(bool value) Parameters Type Name Description bool value | Improve this Doc View Source SetEventDataType(string) Declaration public void SetEventDataType(string eventDataTypeName) Parameters Type Name Description string eventDataTypeName | Improve this Doc View Source SetEventDataType(Type) Declaration public void SetEventDataType(Type eventDataType) Parameters Type Name Description Type eventDataType | Improve this Doc View Source SetEventName(string) Declaration public void SetEventName(string eventName) Parameters Type Name Description string eventName | Improve this Doc View Source SupportsDataType(string) Declaration public bool SupportsDataType(string dataTypeName) Parameters Type Name Description string dataTypeName Returns Type Description bool | Improve this Doc View Source SupportsDataType(Type) Declaration public bool SupportsDataType(Type dataType) Parameters Type Name Description Type dataType Returns Type Description bool | Improve this Doc View Source UnlockDataType() Declaration public void UnlockDataType() Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeAnyDrawer.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeAnyDrawer.html",
    "title": "Class VREventPrototypeAnyDrawer | MinVR3",
    "keywords": "Class VREventPrototypeAnyDrawer Inheritance object GUIDrawer PropertyDrawer VREventPrototypeDrawer VREventPrototypeAnyDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VREventPrototypeAny), true)] public class VREventPrototypeAnyDrawer : VREventPrototypeDrawer Methods | Improve this Doc View Source GetExpectedEventPrototypes(SerializedProperty) Declaration protected override List<IVREventPrototype> GetExpectedEventPrototypes(SerializedProperty property) Parameters Type Name Description SerializedProperty property Returns Type Description List<IVREventPrototype> Overrides VREventPrototypeDrawer.GetExpectedEventPrototypes(SerializedProperty) | Improve this Doc View Source SetDataType(SerializedProperty, string) Declaration protected override void SetDataType(SerializedProperty property, string value) Parameters Type Name Description SerializedProperty property string value Overrides VREventPrototypeDrawer.SetDataType(SerializedProperty, string)"
  },
  "api/IVLab.MinVR3.VREventPrototypeDrawer.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeDrawer.html",
    "title": "Class VREventPrototypeDrawer | MinVR3",
    "keywords": "Class VREventPrototypeDrawer Inheritance object GUIDrawer PropertyDrawer VREventPrototypeDrawer VREventPrototypeAnyDrawer VREventPrototypeTemplatedDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VREventPrototype), true)] public class VREventPrototypeDrawer : PropertyDrawer Methods | Improve this Doc View Source GetExpectedEventPrototypes(SerializedProperty) Declaration protected virtual List<IVREventPrototype> GetExpectedEventPrototypes(SerializedProperty property) Parameters Type Name Description SerializedProperty property Returns Type Description List<IVREventPrototype> | Improve this Doc View Source GetPropertyHeight(SerializedProperty, GUIContent) Override this method to specify how tall the GUI for this field is in pixels. Declaration public override float GetPropertyHeight(SerializedProperty property, GUIContent label) Parameters Type Name Description SerializedProperty property The SerializedProperty to make the custom GUI for. GUIContent label The label of this property. Returns Type Description float The height in pixels. Overrides UnityEditor.PropertyDrawer.GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent) | Improve this Doc View Source OnGUI(Rect, SerializedProperty, GUIContent) Override this method to make your own IMGUI based GUI for the property. Declaration public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) Parameters Type Name Description Rect position Rectangle on the screen to use for the property GUI. SerializedProperty property The SerializedProperty to make the custom GUI for. GUIContent label The label of this property. Overrides UnityEditor.PropertyDrawer.OnGUI(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.GUIContent) | Improve this Doc View Source SetDataType(SerializedProperty, string) Declaration protected virtual void SetDataType(SerializedProperty property, string value) Parameters Type Name Description SerializedProperty property string value"
  },
  "api/IVLab.MinVR3.VREventPrototypeFloat.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeFloat.html",
    "title": "Class VREventPrototypeFloat | MinVR3",
    "keywords": "Class VREventPrototypeFloat Inheritance object VREventPrototypeT<float> VREventPrototypeFloat Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeFloat : VREventPrototypeT<float>, IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration public override IVREventPrototype Clone() Returns Type Description IVREventPrototype Overrides VREventPrototypeT<float>.Clone() | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeFloat Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeFloat Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeGameObject.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeGameObject.html",
    "title": "Class VREventPrototypeGameObject | MinVR3",
    "keywords": "Class VREventPrototypeGameObject Inheritance object VREventPrototypeT<GameObject> VREventPrototypeGameObject Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeGameObject : VREventPrototypeT<GameObject>, IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration public override IVREventPrototype Clone() Returns Type Description IVREventPrototype Overrides VREventPrototypeT<GameObject>.Clone() | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeGameObject Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeGameObject Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeInt.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeInt.html",
    "title": "Class VREventPrototypeInt | MinVR3",
    "keywords": "Class VREventPrototypeInt Inheritance object VREventPrototypeT<int> VREventPrototypeInt Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeInt : VREventPrototypeT<int>, IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration public override IVREventPrototype Clone() Returns Type Description IVREventPrototype Overrides VREventPrototypeT<int>.Clone() | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeInt Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeInt Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeQuaternion.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeQuaternion.html",
    "title": "Class VREventPrototypeQuaternion | MinVR3",
    "keywords": "Class VREventPrototypeQuaternion Inheritance object VREventPrototypeT<Quaternion> VREventPrototypeQuaternion Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeQuaternion : VREventPrototypeT<Quaternion>, IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration public override IVREventPrototype Clone() Returns Type Description IVREventPrototype Overrides VREventPrototypeT<Quaternion>.Clone() | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeQuaternion Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeQuaternion Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeString.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeString.html",
    "title": "Class VREventPrototypeString | MinVR3",
    "keywords": "Class VREventPrototypeString Inheritance object VREventPrototypeT<string> VREventPrototypeString Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeString : VREventPrototypeT<string>, IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration public override IVREventPrototype Clone() Returns Type Description IVREventPrototype Overrides VREventPrototypeT<string>.Clone() | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeString Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeString Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeT-1.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeT-1.html",
    "title": "Class VREventPrototypeT<T> | MinVR3",
    "keywords": "Class VREventPrototypeT<T> Inheritance object VREventPrototypeT<T> VREventPrototypeFloat VREventPrototypeGameObject VREventPrototypeInt VREventPrototypeQuaternion VREventPrototypeString VREventPrototypeVector2 VREventPrototypeVector3 VREventPrototypeVector4 Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeT<T> : IVREventPrototype Type Parameters Name Description T Constructors | Improve this Doc View Source VREventPrototypeT() Declaration public VREventPrototypeT() Fields | Improve this Doc View Source m_EventName Declaration [SerializeField] protected string m_EventName Field Value Type Description string Methods | Improve this Doc View Source Clone() Declaration public virtual IVREventPrototype Clone() Returns Type Description IVREventPrototype | Improve this Doc View Source GetEventDataTypeName() Declaration public string GetEventDataTypeName() Returns Type Description string | Improve this Doc View Source GetEventDisplayName() Declaration public string GetEventDisplayName() Returns Type Description string | Improve this Doc View Source GetEventName() Declaration public string GetEventName() Returns Type Description string | Improve this Doc View Source SetEventName(string) Declaration public void SetEventName(string eventName) Parameters Type Name Description string eventName Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeTemplatedDrawer.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeTemplatedDrawer.html",
    "title": "Class VREventPrototypeTemplatedDrawer | MinVR3",
    "keywords": "Class VREventPrototypeTemplatedDrawer Inheritance object GUIDrawer PropertyDrawer VREventPrototypeDrawer VREventPrototypeTemplatedDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VREventPrototypeT<>), true)] public class VREventPrototypeTemplatedDrawer : VREventPrototypeDrawer"
  },
  "api/IVLab.MinVR3.VREventPrototypeVector2.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeVector2.html",
    "title": "Class VREventPrototypeVector2 | MinVR3",
    "keywords": "Class VREventPrototypeVector2 Inheritance object VREventPrototypeT<Vector2> VREventPrototypeVector2 Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeVector2 : VREventPrototypeT<Vector2>, IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration public override IVREventPrototype Clone() Returns Type Description IVREventPrototype Overrides VREventPrototypeT<Vector2>.Clone() | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeVector2 Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeVector2 Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeVector3.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeVector3.html",
    "title": "Class VREventPrototypeVector3 | MinVR3",
    "keywords": "Class VREventPrototypeVector3 Inheritance object VREventPrototypeT<Vector3> VREventPrototypeVector3 Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeVector3 : VREventPrototypeT<Vector3>, IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration public override IVREventPrototype Clone() Returns Type Description IVREventPrototype Overrides VREventPrototypeT<Vector3>.Clone() | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeVector3 Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeVector3 Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventPrototypeVector4.html": {
    "href": "api/IVLab.MinVR3.VREventPrototypeVector4.html",
    "title": "Class VREventPrototypeVector4 | MinVR3",
    "keywords": "Class VREventPrototypeVector4 Inheritance object VREventPrototypeT<Vector4> VREventPrototypeVector4 Implements IVREventPrototype Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventPrototypeVector4 : VREventPrototypeT<Vector4>, IVREventPrototype Methods | Improve this Doc View Source Clone() Declaration public override IVREventPrototype Clone() Returns Type Description IVREventPrototype Overrides VREventPrototypeT<Vector4>.Clone() | Improve this Doc View Source Create(string) Declaration public static VREventPrototypeVector4 Create(string eventName) Parameters Type Name Description string eventName Returns Type Description VREventPrototypeVector4 Implements IVREventPrototype"
  },
  "api/IVLab.MinVR3.VREventQuaternion.html": {
    "href": "api/IVLab.MinVR3.VREventQuaternion.html",
    "title": "Class VREventQuaternion | MinVR3",
    "keywords": "Class VREventQuaternion Inheritance object VREvent VREventT<Quaternion> VREventQuaternion Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventQuaternion : VREventT<Quaternion>, ISerializable Constructors | Improve this Doc View Source VREventQuaternion(SerializationInfo, StreamingContext) Declaration protected VREventQuaternion(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREventQuaternion(string, Quaternion) Declaration public VREventQuaternion(string name, Quaternion data) Parameters Type Name Description string name Quaternion data Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public override VREvent Clone() Returns Type Description VREvent Overrides VREvent.Clone() | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Overrides VREventT<Quaternion>.GetObjectData(SerializationInfo, StreamingContext) Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventString.html": {
    "href": "api/IVLab.MinVR3.VREventString.html",
    "title": "Class VREventString | MinVR3",
    "keywords": "Class VREventString Inheritance object VREvent VREventT<string> VREventString Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventString : VREventT<string>, ISerializable Constructors | Improve this Doc View Source VREventString(SerializationInfo, StreamingContext) Declaration protected VREventString(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREventString(string, string) Declaration public VREventString(string name, string data) Parameters Type Name Description string name string data Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public override VREvent Clone() Returns Type Description VREvent Overrides VREvent.Clone() | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Overrides VREventT<string>.GetObjectData(SerializationInfo, StreamingContext) Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventT-1.html": {
    "href": "api/IVLab.MinVR3.VREventT-1.html",
    "title": "Class VREventT<T> | MinVR3",
    "keywords": "Class VREventT<T> Inheritance object VREvent VREventT<T> VREventFloat VREventGameObject VREventInt VREventQuaternion VREventString VREventVector2 VREventVector3 VREventVector4 Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventT<T> : VREvent, ISerializable Type Parameters Name Description T Constructors | Improve this Doc View Source VREventT() Declaration protected VREventT() | Improve this Doc View Source VREventT(SerializationInfo, StreamingContext) Declaration protected VREventT(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREventT(string, T) Declaration protected VREventT(string eventName, T eventData) Parameters Type Name Description string eventName T eventData Fields | Improve this Doc View Source m_Data Declaration [SerializeField] protected T m_Data Field Value Type Description T Properties | Improve this Doc View Source data Declaration public T data { get; } Property Value Type Description T Methods | Improve this Doc View Source GetData() Declaration public T GetData() Returns Type Description T | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Overrides VREvent.GetObjectData(SerializationInfo, StreamingContext) | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides VREvent.ToString() Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventTypeRepr.html": {
    "href": "api/IVLab.MinVR3.VREventTypeRepr.html",
    "title": "Class VREventTypeRepr | MinVR3",
    "keywords": "Class VREventTypeRepr String representation of a VREvent Type, useful for choosing VREvent producer types with unknown origin Inheritance object VREventTypeRepr Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventTypeRepr Properties | Improve this Doc View Source EventDataType String representation of a VREvent Type, useful for choosing VREvent producer types with unknown origin Declaration public Type EventDataType { get; } Property Value Type Description Type Methods | Improve this Doc View Source ToString() String representation of a VREvent Type, useful for choosing VREvent producer types with unknown origin Declaration public override string ToString() Returns Type Description string Overrides object.ToString()"
  },
  "api/IVLab.MinVR3.VREventTypeReprDrawer.html": {
    "href": "api/IVLab.MinVR3.VREventTypeReprDrawer.html",
    "title": "Class VREventTypeReprDrawer | MinVR3",
    "keywords": "Class VREventTypeReprDrawer Inheritance object GUIDrawer PropertyDrawer VREventTypeReprDrawer Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Editor.dll Syntax [CustomPropertyDrawer(typeof(VREventTypeRepr), true)] public class VREventTypeReprDrawer : PropertyDrawer Methods | Improve this Doc View Source OnGUI(Rect, SerializedProperty, GUIContent) Override this method to make your own IMGUI based GUI for the property. Declaration public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) Parameters Type Name Description Rect position Rectangle on the screen to use for the property GUI. SerializedProperty property The SerializedProperty to make the custom GUI for. GUIContent label The label of this property. Overrides UnityEditor.PropertyDrawer.OnGUI(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.GUIContent)"
  },
  "api/IVLab.MinVR3.VREventVector2.html": {
    "href": "api/IVLab.MinVR3.VREventVector2.html",
    "title": "Class VREventVector2 | MinVR3",
    "keywords": "Class VREventVector2 Inheritance object VREvent VREventT<Vector2> VREventVector2 Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventVector2 : VREventT<Vector2>, ISerializable Constructors | Improve this Doc View Source VREventVector2(SerializationInfo, StreamingContext) Declaration protected VREventVector2(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREventVector2(string, Vector2) Declaration public VREventVector2(string name, Vector2 data) Parameters Type Name Description string name Vector2 data Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public override VREvent Clone() Returns Type Description VREvent Overrides VREvent.Clone() | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Overrides VREventT<Vector2>.GetObjectData(SerializationInfo, StreamingContext) Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventVector3.html": {
    "href": "api/IVLab.MinVR3.VREventVector3.html",
    "title": "Class VREventVector3 | MinVR3",
    "keywords": "Class VREventVector3 Inheritance object VREvent VREventT<Vector3> VREventVector3 Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventVector3 : VREventT<Vector3>, ISerializable Constructors | Improve this Doc View Source VREventVector3(SerializationInfo, StreamingContext) Declaration protected VREventVector3(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREventVector3(string, Vector3) Declaration public VREventVector3(string name, Vector3 data) Parameters Type Name Description string name Vector3 data Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public override VREvent Clone() Returns Type Description VREvent Overrides VREvent.Clone() | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Overrides VREventT<Vector3>.GetObjectData(SerializationInfo, StreamingContext) Implements ISerializable"
  },
  "api/IVLab.MinVR3.VREventVector4.html": {
    "href": "api/IVLab.MinVR3.VREventVector4.html",
    "title": "Class VREventVector4 | MinVR3",
    "keywords": "Class VREventVector4 Inheritance object VREvent VREventT<Vector4> VREventVector4 Implements ISerializable Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [Serializable] public class VREventVector4 : VREventT<Vector4>, ISerializable Constructors | Improve this Doc View Source VREventVector4(SerializationInfo, StreamingContext) Declaration protected VREventVector4(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source VREventVector4(string, Vector4) Declaration public VREventVector4(string name, Vector4 data) Parameters Type Name Description string name Vector4 data Methods | Improve this Doc View Source Clone() Does a deep copy of the VREvent, subclasses override this to preserve the correct type of event. Declaration public override VREvent Clone() Returns Type Description VREvent Overrides VREvent.Clone() | Improve this Doc View Source GetObjectData(SerializationInfo, StreamingContext) Declaration public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Overrides VREventT<Vector4>.GetObjectData(SerializationInfo, StreamingContext) Implements ISerializable"
  },
  "api/IVLab.MinVR3.WindowSettings.ApplyConfigTiming.html": {
    "href": "api/IVLab.MinVR3.WindowSettings.ApplyConfigTiming.html",
    "title": "Enum WindowSettings.ApplyConfigTiming | MinVR3",
    "keywords": "Enum WindowSettings.ApplyConfigTiming Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public enum WindowSettings.ApplyConfigTiming Fields Name Description LateUpdate OnAwake OnEnable Start Update"
  },
  "api/IVLab.MinVR3.WindowSettings.html": {
    "href": "api/IVLab.MinVR3.WindowSettings.html",
    "title": "Class WindowSettings | MinVR3",
    "keywords": "Class WindowSettings Inheritance object Object Component Behaviour MonoBehaviour WindowSettings Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax [AddComponentMenu(\"MinVR/Display/Window Settings\")] public class WindowSettings : MonoBehaviour Fields | Improve this Doc View Source applyConfigTiming Declaration [Header(\"When to Apply Window Configuration\")] [SerializeField] [Tooltip(\"When in the MonoBehaviour lifecycle to apply the configuration specified above\")] public WindowSettings.ApplyConfigTiming applyConfigTiming Field Value Type Description WindowSettings.ApplyConfigTiming | Improve this Doc View Source fullScreenMode Declaration [SerializeField] [Tooltip(\"Control the fullscreen mode of the application\")] public FullScreenMode fullScreenMode Field Value Type Description FullScreenMode | Improve this Doc View Source height Declaration [SerializeField] [Tooltip(\"Window height, in pixels\")] public int height Field Value Type Description int | Improve this Doc View Source refreshRate Declaration [SerializeField] [Tooltip(\"Control the desired refresh rate of the application (0 = default / max)\")] public int refreshRate Field Value Type Description int | Improve this Doc View Source setFullscreenMode Declaration [SerializeField] public bool setFullscreenMode Field Value Type Description bool | Improve this Doc View Source setShowBorders Declaration [SerializeField] public bool setShowBorders Field Value Type Description bool | Improve this Doc View Source setWindowPositionAndSize Declaration [SerializeField] public bool setWindowPositionAndSize Field Value Type Description bool | Improve this Doc View Source setWindowTitle Declaration [Header(\"Window Configuration Options\")] [SerializeField] public bool setWindowTitle Field Value Type Description bool | Improve this Doc View Source showWindowBorders Declaration [SerializeField] [Tooltip(\"Show the window decorations or not\")] public bool showWindowBorders Field Value Type Description bool | Improve this Doc View Source upperLeftX Declaration [SerializeField] [Tooltip(\"Upper left x-coordinate of the window, in pixels\")] public int upperLeftX Field Value Type Description int | Improve this Doc View Source upperLeftY Declaration [SerializeField] [Tooltip(\"Upper left y-coordinate of the window, in pixels\")] public int upperLeftY Field Value Type Description int | Improve this Doc View Source width Declaration [SerializeField] [Tooltip(\"Window width, in pixels\")] public int width Field Value Type Description int | Improve this Doc View Source windowTitle Declaration [SerializeField] [Tooltip(\"Set the title for this window\")] public string windowTitle Field Value Type Description string"
  },
  "api/IVLab.MinVR3.XMLUtils.html": {
    "href": "api/IVLab.MinVR3.XMLUtils.html",
    "title": "Class XMLUtils | MinVR3",
    "keywords": "Class XMLUtils Inheritance object XMLUtils Namespace: IVLab.MinVR3 Assembly: IVLab.MinVR3.Runtime.dll Syntax public class XMLUtils Methods | Improve this Doc View Source FindNth(string, string, int) Declaration public static int FindNth(string str, string substr, int n) Parameters Type Name Description string str string substr int n Returns Type Description int | Improve this Doc View Source GetNextXMLFieldName(string) Declaration public static string GetNextXMLFieldName(string input) Parameters Type Name Description string input Returns Type Description string | Improve this Doc View Source GetXMLField(string, string, ref Dictionary<string, string>, ref string, ref string) Declaration public static bool GetXMLField(string input, string fieldName, ref Dictionary<string, string> propertiesAndValues, ref string fieldData, ref string leftoverInput) Parameters Type Name Description string input string fieldName Dictionary<string, string> propertiesAndValues string fieldData string leftoverInput Returns Type Description bool | Improve this Doc View Source NumSubstringOccurances(string, string) Declaration public static int NumSubstringOccurances(string str, string substr) Parameters Type Name Description string str string substr Returns Type Description int | Improve this Doc View Source WriteXMLField(string, Dictionary<string, string>, string) Declaration public static string WriteXMLField(string fieldName, Dictionary<string, string> propertiesAndValues, string fieldData) Parameters Type Name Description string fieldName Dictionary<string, string> propertiesAndValues string fieldData Returns Type Description string"
  },
  "api/IVLab.MinVR3.html": {
    "href": "api/IVLab.MinVR3.html",
    "title": "Namespace IVLab.MinVR3 | MinVR3",
    "keywords": "Namespace IVLab.MinVR3 Classes BasicHighlighter BasicObjectSelector BimanualObjectManipulator This class implements yet another technique for bimanual object manipulation. This implementation is based off the 6DOF technique described in the paper Mid-Air Interactions Above Stereoscopic Interactive Tables (Mendes / Fonesca / Araujo 2014), but similar techniques exist prior to that paper as well. BimanualObjectSelector BoundsHighlighter CallableEventProducer Implements a virtual input device where the prototypes for the VREvents generated by the device can be specified in the Editor and the corresponding events can be produced at runtime by calling a ProduceVREvent(..) method with the event's name and an appropriate data payload (if any). CavePaintingBrushCursor Creates a mesh for the 3D Brush cursor used in the original CavePainting, 2001 paper. ClusterClient ClusterServer ColorPicker Condition Conditions can be used to programmatically restrict the FSM's ability to transition along an arc unless some condition is met. Subclass from this class and implement the condition inside this abstract function. Then, attach your new class to the desired arc(s). Then, the arc will only be traversed when it is triggered AND the condition is true. Note that if you want a simple arc guard that does not depend on any custom code this might be better implmented using the SharedToken scriptable object, which is useful, for example, to coordinate between FSMs to determine which should have focus. ConfigVal A static class that provides easy, read-only assess to configuration settings loaded from config files. File Naming and Attaching to Unity Game Objects Config Files should be included in your Unity project as text file assets. This requires them to have a .txt extension. Our naming convention is configname.minvr.txt. Where \"configname\" is replaced with \"common\" for files that are attached to VREngine, since these are common to all VRConfigs, and the name of the VRConfig for files that are attached to a specific VRConfig. Config File Format The basic form of a MinVR3 config file is a list of Key = Value pairs, with one entry per line. Beyond this, there are a few extra features: Lines that begin with the # symbol are ignored as comments. A \\ symbol at the end of the line, means the value is continued on the next line. If the value should actually include a , use \\ instead. Values for Vector, Matrix, and other array types should be separated by commas. An example config file looks like this: # MinVR3 Example Config File (common.minvr.txt) MY_INT = 2 MY_FLOAT = 13.0 # Booleans can use true/false or True/False MY_BOOLEAN = False # Strings that are not quoted will have any leading or trailing whitespace removed MY_STRING = Hello my MinVR friends # Strings that are quoted can include whitespace and escaped quotes MY_QUOTED_STRING = \" Hello my \\\"MinVR friends\\\" \" # Values for Vector, Quaternion, and Matrix types must be separated by commas. Optionally, # the values can be enclosed in (), <>, or [] brackets. MY_VECTOR2 = (4.0, 4.0) MY_VECTOR3 = (5.0, 5.0, 5.0) MY_VECTOR4 = (6.0, 6.0, 6.0, 6.0) MY_QUATERNION = (0.0, 0.0, 0.0, 1.0) # Matrix types should list elements in ROW MAJOR order so that the matrix \"looks\" correct when # typed into the config file on four lines as shown below. For a 4x4 homogeneous transformation # matrix, the last row should always be 0.0, 0.0, 0.0, 1.0, the right column contains the # translation, and the upper-left 3x3 contains the rotation and scale. Note the use of \\ at the # end of each line. This is needed to tell the parser that the value continues on the next line. MY_MATRIX4X4 = \\ (1.0, 0.0, 0.0, 2.0, \\ 0.0, 1.0, 0.0, 3.0, \\ 0.0, 0.0, 1.0, 4.0, \\ 0.0, 0.0, 0.0, 1.0) # A generic int array of any length MY_INT_ARRAY = 5, 4, 3, 2, 1 # A generic float array of any length MY_FLOAT_ARRAY = 0.0, 1.0, 2.0, 3.0, 4.0, 5.0 # An array of strings MY_STRING_ARRAY = \"One\", \"Two Three\", \"Four Five Six\", \"a b c d \\\"e\\\" f\", \"done\" After the config file is parsed, the values specified in the example config file above can be accessed from within a script like this: bool b = ConfigVal.Get(\"MY_BOOLEAN\", true); Debug.Log(b); int i = ConfigVal.Get(\"MY_INT\", 2); Debug.Log(i); float f = ConfigVal.Get(\"MY_FLOAT\", 1.0f); Debug.Log(f); string s1 = ConfigVal.Get(\"MY_STRING\", \"\"); Debug.Log(s1); string s2 = ConfigVal.Get(\"MY_QUOTED_STRING\", \"\"); Debug.Log(s2); Vector2 v2 = ConfigVal.Get(\"MY_VECTOR2\", Vector2.zero); Debug.Log(v2); Vector3 v3 = ConfigVal.Get(\"MY_VECTOR3\", Vector3.zero); Debug.Log(v3); Vector4 v4 = ConfigVal.Get(\"MY_VECTOR4\", Vector4.zero); Debug.Log(v4); Quaternion q = ConfigVal.Get(\"MY_QUATERNION\", Quaternion.identity); Debug.Log(q); Matrix4x4 m4 = ConfigVal.Get(\"MY_MATRIX4X4\", Matrix4x4.identity); Debug.Log(m4); int[] intArray = new int[0]; intArray = ConfigVal.Get(\"MY_INT_ARRAY\", intArray); string iStr = \"\"; foreach (int i in intArray) { iStr += i.ToString() + \", \"; } Debug.Log(iStr); float[] floatArray = new float[0]; floatArray = ConfigVal.Get(\"MY_FLOAT_ARRAY\", floatArray); string fStr = \"\"; foreach (float f in floatArray) { fStr += f.ToString() + \", \"; } Debug.Log(fStr); string[] strArray = new string[0]; strArray = ConfigVal.Get(\"MY_STRING_ARRAY\", strArray); foreach (string s in strArray) { Debug.Log(s); } Note that the values are stored internally as strings. They are not interpreted as a specific type until they are accessed with a call to ConfigVal.Get() and the Get() method tries to convert the string to the requested type. To avoid re-converting each frame, consider accessing ConfigVals from within Start() or Awake() and then saving the result in a member variable within your class. CoordConversion This class includes useful routines for converting between 3D coordinate systems that follow different conventions for handedness and up/forward directions. Brief background on Left-Handed vs. Right Handed Coordinates Many (most?) scientific datasets and modeling programs these days use right-handed coordinates but that is just a convention. Mathematically speaking, it is just as reasonable to use left- handed coordinates, as Unity has done and several other major graphics packages have done in the past. Luckily, you can convert between LH and RH coordinates. The conversion itself is not too hard. The hard part is that there are several valid ways to do the conversion so you need to know which conventions are used and stay consistent. This class is intended to help with this by organizing all of the conversion routines here in one place. Converting LH to RH: The big question is, which axis to negate? Converting between LH and RH coordinate systems requires negating one axis. However, the choice of which axis to negate is arbitrary. When Unity does these conversions automatically, like when you drag and drop a model file into your Unity project, it seems to have adopted the convention of negating the X axis (i.e., vertices with positive x values will have negative x values after importing). So, in this class, we intentionally follow the same convention of negating X. If you look for more info online, you will find examples that do the conversion by negating Y or Z. All of these are completely valid, it's just a convention, and we'll try to be as consistent with Unity as possible by doing the same thing and negating x. Converting between +Y=Up, +Z=Up, and other variations In addition to deciding to use a left or right-handed system, datasets and graphics toolkits often also adopt a second convention about which axis points \"Up\", which points \"Forward\", etc. This really has nothing to do with RH vs. LH decision. You could decide to use left-handed with +Y=Up or right-handed with +Y=Up or right-handed with +Z=Up or something else. However, once you pick two directions (say, Up and Forward), the third axis must follow either the right -hand rule or left-hand rule based on whether you are using right or left handed coordinates. Use the left or right hand as appropriate, start with your fingers all pointing toward +X, sweep your palm and curl your fingers toward +Y, and then your thumb should point in +Z. (Or, just Google for a picture if needed.) Once you have converted from RH to LH or vice versa you can easily change the up, forward, and right directions by applying a regular old rotational transformation. So, it can be helpful to think of the entire conversion in two steps. If you have RH data with +Z up, then step 1 is convert the data to LH (this will at least make them viewable in Unity), then step 2 is to apply a rotation as you would for any other object in Unity so that the data's +Z will be up. Since Unity has the convention that +Y is up, this rotation can just be a simple 90 degree rotation around the X axis. Since +Z=Up is pretty common in a lot of our data, we include some routines for doing this kind of conversion with one function call, but if you look at the implementation, you'll see that it is accomplishing this by first converting RH to LH, then applying a rotation. Commonly Encountered Coordinate Systems and Conventions Left-Handed, Y=Up, Z=Forward (Unity) +X = Right +Y = Up +Z = Forward (Into the screen) Right-Handed, Y=Up, Z=Backward (MinGfx, ParaView, many others ...) +X = Right +Y = Up +Z = Backward (Out of Screen) Right-Handed, Z=Up, Y=Forward (Blender, XROMM, Joint-Track, ...) +X = Right +Y = Forward (Into Screen) +Z = Up CoordConversion.CoordSystem This small internal class defines a coordinate system convention based on knowing 3 things: Whether right-handed or left-handed coordinates are used. Which direction is considered \"Up\" Which direction is considered \"Forward\" DebugDraw Additions to Unity's useful debugging utililies like Debug.DrawRay and Debug.DrawLine. These are particularly useful for AR/VR applications where the debug output needs to be seen in the Game View (not just scene view.) All parameters duration will default to a single frame when left at 0, otherwise duration is in seconds. DrawEyes This is useful for debugging displays that use off-axis projection, like the walls of a Cave of a fishtank VR or Powerwall display. The position of each eye (as reported via head tracking) is projected onto the plane of the display and a sphere is drawn for each eye at its projected position. You can then move the glasses around and make sure that these spheres move correctly with them to confirm that you have set offsets from the tracker appropriately (e.g., the offset from the tracking device mounted on the glasses to each eye, making sure the left eye is indeed on the left side, etc.) DrawFPS Displays a frames-per-second counter in the top-left of the screen; useful when working with a VR display that doesn't allow you to easily see Unity's performance data while you are wearing it. DrawTrackers DrawTrackers.TrackerDescription FSM FSMEditor FaceCamera Rotates an object to always face the camera (billboard-style) FakeTrackers Genertates fake VREvents for 3 trackers (usually assigned to the head and 2 hands). This is similar to the XR Device Simulator provided with Unity's XR Interaction Toolkit, but this is a simpler simulator and has better mouse and keyboard controls (IMHO). This is only intended to be used while debugging and testing; not for an actual deployed VR app! To make debugging VR apps easier, you can use the mouse and keyboard to create 'fake' input for two trackers. \"Press the '1' or '2' key to switch between controlling tracker1 or tracker2. Move the mouse around the screen to move the 3D position of that tracker within a plane parallel to the screen. Hold down 'left shift' while moving the mouse vertically to change the 3D depth. Hold 'x', 'y', or 'z' while moving the mouse horizontally to rotate the tracker around the X, Y, or Z axis. Move the head around with the arrow keys. FloatingMenu Simple 3D menu that floats in space and is activated by placing a tracked cursor inside the titlebar or box that holds each menu item and then clicking. GameObjectExtensions GridOfObjects A grid of GameObjects, where the grid can be defined different ways (e.g., on a plane, on the surface of a spherical dome, ...) InfoBoxAttribute InfoBoxAttributeDrawer KeyboardState Facade to hide the different strategies for accessing keyboard input depending on whether using the Legacy InputModule or the New Input System. Matrix4x4Extensions MenuHelpers These constants and functions help to add MinVR items to Unity's internal GameObject, Component, and Asset menus in a consistent way. Use these both within the main MinVR package and plugins. Menu_GameObject_MinVR Adds MinVR items to Unity's GameObject menu. Most options are pretty simple, just creating a new GameObject and adding a MinVR asset to it. Several of the VRConfigs items are more complex as they can create several child objects and initialize them with appropriate settings. A similar functionality could be achieved by instatiating prefabs, but this is not how the built-in functions in Unity's GameObject menu work. Like the way objects created from Unity's GameObject menu work, the idea here is that these objects serve as useful starting points but the expectation is that the Programmer will want/need to edit and add to them. If prefabs are used, this can create some confusion because some modifications, like reordering objects, are not allowed, and it's not completely clear to programmers if they should be updating the original prefab after changes are made or create a new one, etc. As a lower-level support library,it seems best for MinVR to not use prefabs within the GameObject menu. Menu_GameObject_MinVRInteraction Menu_GameObject_MinVR_VRConfigs Menu_GameObject_UmnCave_VRConfigs MobileSensors This script uses the legacy Unity Input Module rather than the \"New Input System\" because the Unity Remote App (used for iOS and Android development) does not yet support the New Input System. It seems that the New Input System works fine if you actually fully deploy the app, but not with Unity Remote, which is super useful for developing mobile apps. So, for now, this uses the Legacy InputModule. When Unity Remote is updated, we should update this script as well so we are consistent with all of MinVR using the New Input System. Note: You can switch which input system you want to use for your app in Player Settings, and it is possible to select \"Both\". That works well if you want to use the New Input System's better support for XR and the Remote's better support for touch, for example. ModifiedEventProducer Listens for two events: a base event and a modifier event. The modifier event must support some kind of ON/OFF logic (e.g. a keyboard key UP / DOWN). When the modifier is ON, this script will send \"modified\" events as specified by the modified event naming strategy MouseAndKeyboard This class translates mouse and keyboard inputs from Unity to VREvents. It will work with either the new input system or the legacy input system. You can name the VREvents whatever you wish, and this can be a useful way to bind desktop-style input to the same events you expect to recieve when running in VR mode. MouseAndKeyboard.KeyToVREventName MouseObjectManipulator Implements a trackball rotate interaction for use with any GameObjects in the scene that have a Collider attached. When the mouse is clicked, a raycast is used to see if any object was picked. By default, this raycast will look at all objects in the scene that have colliders attached, but you can restrict it to a subset by assigning different layers to your gameobjects and including the layers to ignore in the ignoreLayers LayerMask. If the collider on the object selected by the mouse is not a sphere collider, then it is disabled immediately after the initial selection and a temporary sphere collider is added to object since the trackball effect requires intersecting with a bounding sphere. When the mouse button is released, the temporary collider is removed and the original is reenabled. Created by Dan, Morgan, & Sean 2/10/21 MouseState Facade to hide the different strategies for accessing mouse input depending on whether using the Legacy InputModule or the New Input System. NetUtils OnVREventReceived PrintFPS Log the frames per second to the terminal ProximityEventProducer Listens for two 3D position events (typically from VR trackers) and generates VREvents for when the two trackers are moved close together (i.e., in proximity to each other) and when they move apart. QuitOnEscapeKey RoomSpaceOrigin SharedToken Implements a binary semaphor or lock that can be acquired by GameObjects. In a 3DUI system with multiple widgets, this can be used to control which widget has the current input focus. SimpleEventListener SimplePlaySoundOnVREvent Singleton<T> Inherit from this base class to create a singleton. Several flavors of singleton are possible to implement in Unity. This singleton persists across scene loads/unloads. It also inherits from MonoBehaviour, so your class can implememnt the typical Start(), Update(), and other MonoBehaviour methods. When you access MyClassName.Instance from a script, the singleton instance of MyClassName will be created \"on demand\" and added to the scene hierarchy in the DontDestroyOnLoad section. Alternatively, if you prefer to have MyClassName visible in the editor, you can attach your MyClassName script to a GameObject in your scene. However, you should only do this in one place in your scene (otherwise it will not be a singleton). An assertion will fire if two or more MyClassName objects are found in the scene. Also, to remain persistent across scene loads, the Unity imposes a constraing that the GameObject your MyClassName script is attached to must be placed in the root of the hierarchy. This example shows how to create a script that inherets from Singleton. SmartScene Partial implmentation of the classic bimanual UI in MultiGen's SmartScene application (1997-ish), originally developed for use with pinch gloves. The technique is actually rather similar to modern multi-Cursor gestures but works in 3D to translate, rotate, and scale a scene using two hands in combination. Demo of the original 3DUI: https://www.youtube.com/watch?v=q4XmprH1S0s SpatialAudioClient Implements a spatial audio client that connects to the sound_server.py spatial audio server. The spatial audio server must be installed and running for this script to do anything. See https://github.umn.edu/ivlab-cs/sound_server for details on the sound server. SpatialPlaySoundOnVREvent SphereMove SphericalCoordinate A tiny class to hold the spherical coordinates for a point, used primarily for working with planetarium domes -- see SphericalDome.cs. SphericalDome A brush up on spherical coordinate systems may be helpful :) https://en.wikipedia.org/wiki/Spherical_coordinate_system https://en.wikipedia.org/wiki/Spherical_cap This class assumes the dome is a spherical cap, i.e., a portion of a sphere produced by slicing the sphere with a plane. The Bell Museum dome is a hemisphere, meaning the plane slices right through the sphere's center point. However, the traveling \"blow up\" planetariums (think bouncy house) we use when bringing the show on the road are not a full hemisphere. Instead of covering a full 180 degrees, they cover more like 120 degree, so the cap is smaller. This class handles both cases, just set the domeViewAngle appropriately. Definitions and Coordinate Spaces Dome Space is a coordinate system aligned with the spherical cap of the dome so that the Up direction (+Y) points from the center of the sphere to the center point (i.e., \"North Pole\") on the cap. This direction is also the normal of the slicing plane used to create the spherical cap. We also call this direction the \"zenith direction\". When using polar coordinates in Dome Space, polar angles are measured relative to this reference direction. The forward (+Z) direction lies within the slicing plane and, subject to this constraint, points as closely as possible toward the Room Space forward direction, that is, the default direction the audience within the dome is facing. When using polar coordinates in Dome Space, this direction is the reference direction for azimuth angles. Starting a 0 degrees, Azimuth angles increase positively when looking to the right of forward, and negatively when looking to the left. The origin of Dome Space lies at the \"center\" of the sphere. Room Space Just like MinVR's conventions for AR/VR, we call the coordinate system defined by the physical room that the dome is in Room Space. If the dome is oriented so that its slicing plane is parallel to the ground, then Room Space and Dome Space will be equivalent. However, many domes are tilted slightly relative to the phyical ground. For example, in the Bell Planetarium, the dome is tilted 15 degrees so that the forward edge of the projection screen is 15 degrees below the horizon and the rear edge is 15 degrees above the horizon. It can be useful to work in both Dome Space and Room Space. If you want to position an object directly overhead, as in gravity would make it fall straight down onto your head, then the object should be offset above your head using the Room Space Up vector. However, if you want an object to appear in the exact center of the dome's projection screen, then you should position that object along the Dome Space zenith direction. Dome Space to Room Space Transform Following MinVR's conventions, we recommend placing this script on a new GameObject called \"Dome Space\" that is a child of the MinVR \"Room Space\" GameObject. That will mean that the transform for the GameObject this script is attached to is responsbile for transforming Dome Space into Room Space. In other words, the local coordinate system for this GameObject is Dome Space, and the parent coordinate system for this GameObject is Room Space. Then, any objects you attach as children of the \"Dome Space\" object will be positioned relative to the Dome Space coordinate system described above, and just like any other MinVR configuration, any objects you make direct children of the Room Space object, will be positioned in the Room Space coordinate system described above. Spherical Coordinates Internally, Unity uses rectangular (x,y,z) coordinates, so the positions and directions you use will need to be in rectangular coordiantes in order to, for example, position a GameObject by setting its transform. However, when working with these dome spaces, it's often more convenient to work with spherical coordinates. This class helps you do that and then convert the spherical coordinates to rectangular. For example, to position an object directly on the surface of the dome, it is easiest to specify the center point for that object Dome Space polar coordinates (polar angle, azimuth angle, radius), but to actually position a Unity GameObject at that location you will want to: 1. Add the GameObject as a child of this \"Dome Space\" object. 2. Convert the Dome Space spherical coordinates to Dome Space rectangular coordinates using the DomeSpaceSphericalToRectangular() function, 3. Set your GameObject's localPosition equal to the result. Example code: // Create a new GameObject GameObject objOnDomeSurface = new GameObject(); // Make it a Dome Space object, i.e., a child of the GameObject this script is attached to objOnDomeSurface.transform.parent = this.transform.parent; // Define it's position in Dome Space spherical coordinates float polarAngle = 5.0f; float azimuthAngle = 20.0f; // Convert these spherical coordinates to a x,y,z point on the surface of the dome Vector3 domeSpacePosition = PointOnDome(polarAngle, azimuthAngle); // Assign the x,y,z to the local position of the GameObject objOnDomeSurface.transform.localPosition = domeSpacePosition; TcpJsonVREventConnection This class uses Tcp sockets to implement the IVREventConnection interface with Json serialization of events. TcpVREventConnection This class uses Tcp sockets to implement the IVREventConnection interface with C# binary serialization of events. This style of serialization is not particularly portable -- i.e., it requires the other end of the connection to also be implemented using C# binary serialization. Use the TcpJsonVREventConnection instead when there is a need to connect to a server written in some other language. TestSpatialAudio TouchBuiltin Converts touch events from Unity's built-in touch system to VREvents. TouchscreenState TrackballCamera Clickable and draggable camera for trackball camera movement in Unity. Can optionally enable \"acceleration\" to avoid users getting sick in situations like a planetarium. TODO: @bridger: It seems like this class only works properly if the hierarchy is setup in a certain way. It seems this script must be on an object under another object that is the \"trackball parent\" -- does that mean it contains all of the geometry that should be rotated by the trackball? And, the camera must be a child of the gameobject this script is attached to? Can you add documentation on how the hierarchy must be arranged? And, for the GameObject menu, when you add one of these to the scene, it would be useful if it could create the required mini-hierarchy for you. TrackedDesktopCamera Makes a regular desktop camera move about in respone to VREvents so you can control it, for example, from a HMD simulator. TrackedPoseDriver Note: This version of the TrackedPoseDriver is modified from the original provided with Unity's XR Interaction Toolkit. The modified version adds: It listens for VREvents rather than Unity Actions It includes base rotation and translation amounts that can be used, for example, to calibrate a tracker attached to a physical prop. It works with both the new input system and the old input system The TrackedPoseDriver component applies the current Pose value of a tracked device to the transform of the GameObject. TrackedPoseDriver can track multiple types of devices including XR HMDs, controllers, and remotes. TrackedProjectionScreen TrackedProjectionScreen.ScreenCorners TransformExtensions UniCam This implements a user interface for controlling the camera with the mouse. It is a special interface inspired by the \"Unicam\" technique developed by Zeleznik et al. The key feature is that this interface makes it possible to control camera pan, dolly, and rotation with only a single mouse button.That is quite useful because it leaves the other mouse buttons free for pointing, sketching, or other interaction techniques. The only downside of this technique is that it can take some time to learn. In order to enjoy it, you will need to read these brief instructions on how to Pan, Dolly, Rotate, and Spin: Pan: Click and drag horizontally with the mouse.Once you make an initial horizontal movement you can than pan up and down as well, but the key to entering pan mode is to start with a horizontal movement. Dolly: Click and drag vertically with the mouse.The initial movement must be vertical. If you click on some object in the scene, then the speed of dollying is set so that the object will come all the up to the camera lens if you drag the mouse to the bottom of the screen. Rotate: Start with a quick click and release to set the center of rotation. This is most useful if you click on some object in the scene. You will see a black dot appear to mark the center of rotation.If you click on the background then a center of rotation will be selected for you.It will be a point straight ahead and at a depth 4.0 units away. The depth can be adjusted for your application with set_default_depth(). Once your center of rotation is established, move your mouse away a bit and then click and drag to do a trackball rotatation of the scene around this point.Come to a stop before letting go of the mouse button in order to avoid entering the spin state! Spin: For some fun, try \"throwing\" the scene so that it continues to rotate even after you let go.To do this, start a rotation and then let go of the mouse button while your mouse is still moving. To stop spinning just click and release the mouse once to \"catch\" the scene. VRCallback VRCallbackAny VRCallbackAnyDrawer VRCallbackDrawer VRCallbackFloat VRCallbackGameObject VRCallbackInt VRCallbackQuaternion VRCallbackString VRCallbackTDrawer VRCallbackT<T> VRCallbackVector2 VRCallbackVector3 VRCallbackVector4 VRConfig Attach to game objects you wish to act as VRConfig objects. VRConfigManager The VRConfigManager should not be created directly. Instead, use the one attached to VREngine. VRConfigManagerEditor VRConfigMask Automatically enables or disables the GameObject based on the active VRConfig when the VREngine starts. Configure which VRConfig is active on start using the VRConfigManager attached to VREngine, or by specifying command line arguments when running the application. VRConfigMaskEditor VRConvert VREngine This class is the main manager for any MinVR3 application. It's Script Priority is maxed out to make sure it is the first class that starts up when your application starts. On startup, the first thing it will do is enable the VRConfig that you have selected as the \"Startup VRConfig\" and disable all other VRConfigs it finds in the scene. You can set the Startup VRConfig via the Inspector by modifying its value under the VRConfigManager component that is attached to the VREngine GameObject. OR, you can set the Startup VRConfig using command line arguments. This is especially useful when running in a cluster mode, when you may have a run script that starts several instances of the same application but each with a different VRConfig. While your application is running, VREngine's main job is to handle VREvents. VREngine.instance.eventManager acts as the event manager for the whole application. If running in cluster mode, VREngine will make sure its eventManager is synched up each frame with the eventManagers on all of cluster nodes. In cluster mode, the VREngine also synchronizes the graphics \"SwapBuffers\" calls across all nodes so that each node displays the same frame at exactly the same time. VREngine is implmented using a Singleton that makes sure there is only ever one instance of the VREngine that exists at a time and that this instance persists across scene loads and unloads and is not destroyed until the application quits. You should access this single instance of the VREngine class via the static instance variable, like this: VREngine.instance From there, you can access the key classes that VREngine uses to manage the application. For example: VREngine.instance.eventManager VREngine.instance.configManager VREngine.instance.roomSpaceOrigin An important implementation detail is that these key classes are not themselves Singletons, but since we only ever access them through VREngine.instance, they act a bit like singletons in practice. MinVR is designed so that VREngine is the one singleton in the MinVR3 codebase, and the one VREngine.instance that it provides includes critical services like an eventManger, configManger, etc. While, technically speaking, one could add additional VREventMangers or VRConfigManagers to a scene, we can't (today) imagine a situation where that would be useful. Generally, when you want to access to a VREventManager, you will want to access the one being used by the VREngine. This design is an example of a Singleton that uses a \"Service Provider\" pattern. Singletons can be super useful, but they are like \"bringing out the big guns\". It's a really big design decision to decide a class should be a Singleton because they are difficult to work with in Unity's editor, and if the assumption that there will only ever be one instance of the class ever changes, it usually requires a major refactoring of the code to \"undo\" the original decision to make the class a Singleton. We think MinVR3's approach of using just one VREngine singleton that provides access to key services implemented in other \"regular\" classes is a good \"best of both worlds\" approach. VREngineEditor VREvent VREventAlias VREventCallback VREventCallbackAny VREventCallbackAnyDrawer VREventCallbackDrawer VREventCallbackFloat VREventCallbackGameObject VREventCallbackInt VREventCallbackQuaternion VREventCallbackString VREventCallbackTDrawer VREventCallbackT<T> VREventCallbackVector2 VREventCallbackVector3 VREventCallbackVector4 VREventConnectionReceiver MonoBehaviour that receives events sent over a VREventConnection and places them in the VR Event Manager's Queue. There are two common uses for this class: To implement a virtual input device with data sent over a network connection. This class can receive events generated by some other app, even a webpage, and insert the events received into the VREventManager's queue, just as if the events were generated from a local input device. In this case, this component will probably be the only place in your scene where such events would be \"produced\", so it is important for the class to specify a VREventPrototype for each event it expects to receive. For sharing event data between multiple MinVR applications and when the strict, frame-level synchronization of events and rendering provided by MinVR's cluster mode is not required. While cluster-mode works well for tiled dispalys powered by a cluster of identical machines, this class is useful for synchronizing event data across heterogeneous devices used together by a single user (e.g., an AR headset used together with a multi- touch tablet) or in multi-user situations (e.g., multiple users each wearning their own HMD). In these sitautions, the connection may just be responsible for sending/receiving events that are already defined with VREventPrototypes elsewhere in the scene. If that is the case, it it not necessary (but also does not hurt) to redefine the prototypes within this cass. See also VREventConnectionSender. (formerly ConnectionVREventProducer) VREventConnectionReceiverEditor VREventConnectionSender Listens for one or more VREvents and forwards them on to whomever is listening at the other end of an IVREventConnection. Depending on the type of connection, the receivers could include a web browser listening over a WebSocket connection, other MinVR3 apps listening over a Tcp connection, or somebody else over any type of connection that implements IVREventConnection. See also VREventConnectionReceiver. (formerly ConnectionVREventListener) VREventConnectionSenderEditor VREventFloat VREventGameObject VREventInt VREventManager VREventManagerEditor VREventPrototype VREventPrototypeAny VREventPrototypeAnyDrawer VREventPrototypeDrawer VREventPrototypeFloat VREventPrototypeGameObject VREventPrototypeInt VREventPrototypeQuaternion VREventPrototypeString VREventPrototypeT<T> VREventPrototypeTemplatedDrawer VREventPrototypeVector2 VREventPrototypeVector3 VREventPrototypeVector4 VREventQuaternion VREventString VREventT<T> VREventTypeRepr String representation of a VREvent Type, useful for choosing VREvent producer types with unknown origin VREventTypeReprDrawer VREventVector2 VREventVector3 VREventVector4 WindowSettings XMLUtils Interfaces IClusterNode IPolledInputDevice IVRCallback IVREventConnection Defines an interface for classes that can send and/or receive VREvents over some sort of remote network connection. Unlike the network transport provided by MinVR3's Cluster Mode, which supports frame-level synchronization of the entire event queue, this network connection is intended for sending/receiving a subset of VREvents and for situations where the clients at either end of the connection are running asynchronously. This can be used to connect a MinVR Unity app to a web browser or to connect multiple MinVR apps running on various brands of headsets -- basically all situations other than a cluster powering a tiled display. IVREventFilter IVREventListener IVREventProducer IVREventPrototype Enums BasicObjectSelector.SelectionMode CoordConversion.CoordSystem.Axis CoordConversion.CoordSystem.Handedness GridOfObjects.GridType TouchscreenState.TouchInputPhase TrackballCamera.TrackballState TrackedPoseDriver.TrackingType TrackedPoseDriver.UpdateType TrackedProjectionScreen.ProjectionType VREventAlias.AliasStrategy WindowSettings.ApplyConfigTiming Delegates OnVREventReceived.OnVREventReceivedDelegate Delagate to define the structure for OnVREventReceived callbacks."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Overview | MinVR3",
    "keywords": "API Overview This page gives an overview of the most important classes in MinVR3. VR Engine Class Purpose VREngine Main MinVR3 class responsible for starting up and shutting down the VR scene. The VREngine is a Singleton<T>, meaning there is only ONE instance of the VREngine object in the VR app at any given time and it persists through scene loads. The VREngine contains instance variables for the VREventManager and VRConfigManager. VR Events VREventManager Class Purpose VREventManager Maintains the frame-by-frame VR event queue. Scripts can add new VR events so other scripts can use them. VR Event Types Every VREvent has a name, a data type, and optionally data that gets sent along with the event. Class Purpose VREvent VREvent with no data VREventVector2 VREvent with Vector2 data VREventVector3 VREvent with Vector3 data VREventVector4 VREvent with @UnityEngine.Vector4 data VREventQuaternion VREvent with Quaternion data VREventString VREvent with string data VREventInt VREvent with int (int) data VREventFloat VREvent with float (float) data VREventGameObject VREvent with @UnityEngine.GameObject data VREventPrototypes VREventPrototypes are used when the application is expecting a particular event but the actual event hasn't been defined yet. For example, an on-screen cursor might want a VREventVector3 with a name NDH/Position. To \"expect\" these events, we would create A VREventPrototypeVector3. Class Purpose VREventPrototypeAny Event prototype that can accept ANY type of VREvent VREventPrototype Event prototype that can accept simple VREvent with no data VREventPrototypeVector2 Event prototype that can accept VREventVector2 VREventPrototypeVector3 Event prototype that can accept VREventVector3 VREventPrototypeVector4 Event prototype that can accept VREventVector4 VREventPrototypeString Event prototype that can accept VREventString VREventPrototypeInt Event prototype that can accept VREventInt VREventPrototypeFloat Event prototype that can accept VREventFloat VREventPrototypeQuaternion Event prototype that can accept VREventQuaternion VREventPrototypeGameObject Event prototype that can accept VREventGameObject Event Producers and Listeners Events can be produced and consumed by any class that uses MinVR3. Implement one (or both) of the following interfaces: Interface Purpose IVREventProducer Implement this interface to make the events your class produces available to the rest of MinVR3. IVREventListener Implement this interface to listen for VREvents produced by other classes in MinVR3. Input Devices Input devices are a special type of event producer that gets polled by the VREventManager every frame. You can implement the IPolledInputDevice interface to create a new input device for use in MinVR3. Interface Purpose IPolledInputDevice Implement this interface to create a new input device recognized by MinVR3. Advanced VREvent Queue Manipulation There are further operations that can be done with VREvents each frame to support advanced functionality such as modifying events mid-frame, or cloning and renaming them. Topic Purpose IVREventFilter Processes every event every frame and can modify and/or produce more events from an event. VREventAlias Can rename or rename-clone an event. Useful for separating out \"raw\" input devices from \"application-level\" input. GetEventQueue() Get the current event queue for this frame QueueEvent(VREvent) Insert an event in the queue InsertInQueue(VREvent) Insert a derived event in the queue VR Configs Class Purpose VRConfigManager Manages VR configs in the scene and allows the developer to choose which one is active on startup. Handles command line parameter -vrconfig to switch VRConfigs after an executable is built. VRConfig Individual VRConfig script. Attach to a GameObject that should be turned on/off with a particular VRConfig setup. VRConfigMask Enables or disables a particular GameObject if one of the selected VRConfigs are active. Remote Connections MinVR3 can also handle connections to remote Unity clients (and even other languages!). Class Purpose IVREventConnection Implement this interface for sending / receiving events across a particular connection. The connection details are up to the programmer. VREventConnectionReceiver This class translates events received by a IVREventConnection into VREvent objects and inserts them into MinVR3's Event Queue. VREventConnectionSender This sends events from MinVR3's event queue to a IVREventConnection There are other language clients available as well, see the root of this package: MinVR3.js~ MinVR3.cpp~ MinVR3.py~ Note See the Remote Connections manual page for more information on remote connections. Cluster Connections Cluster connections are a special case of remote connections that require a higher level of synchronization between devices. An example of a clustered application would be a multi-window app running in the IV/LAB CAVE, where the graphics on each wall are a separate Unity app. Clustered setups need to have tight, frame-by-frame synchronization in order to work correctly, and as such there's a \"cluster mode\" built into MinVR3. The cluster mode in MinVR3 supports ONE server and MANY clients. In general, the process for each frame in a clustered app is: Get events from input devices Synchronize all events across the cluster (generally, the cluster server will simply produce all events and send them to the clients) Wait for all other nodes to be done processing events End the frame This process ensures that frame timings across the cluster are in lock step (i.e., one app cannot run \"faster\" than another in the cluster.) Useful topics for working with clustered apps are below: Topic Purpose IClusterNode Generic node in the cluster (can be server or client) ClusterServer Cluster server (ONE) ClusterClient Cluster client (MANY) DeltaTimeEventPrototype Delta time event for the cluster server; useful for implementing frame-based animation accurately accross nodes. Extension Methods Unity's built-in methods are sometimes lackluster (especially for the Transform class, for example). We have implemented a bunch of useful methods for the following builtin classes. Check out: GameObjectExtensions TransformExtensions Matrix4x4Extensions Note that here we are taking the approach that MinVR extension methods are the \"surpreme\" extensions methods - i.e., they are at the top-level of the IVLab.MinVR3 namespace. This ensures that the extensions methods are available whenever you do using IVLab.MinVR3. Before implementing or downloading your own extension methods for these classes, check if MinVR3 has one first!"
  },
  "index.html": {
    "href": "index.html",
    "title": "MinVR3 Unity Package | MinVR3",
    "keywords": "MinVR3 Unity Package This is the 3rd incarnation of \"MinVR\", a VR (really XR) open source toolkit designed to support research in XR, spatial user interfaces, pen and touch interfaces, and 3D data visualization. MinVR3 has been developed by the University of Minnesota's Interactive Visualization Lab, building upon collaborations in past MinVRs with Brown University and Macalester College. Getting Started Follow the Installation Guide to incorporate the main MinVR3 package into your project. Optionally, install Plugin Packages to enable extra functionality. Introduction to MinVR3 Key classes organized by theme / functionality"
  },
  "manual/01-intro.html": {
    "href": "manual/01-intro.html",
    "title": "MinVR3 Unity Package | MinVR3",
    "keywords": "MinVR3 Unity Package This in the 3rd incarnation of \"MinVR\", an open source toolkit designed to support experiental and creative research in XR, spatial user interfaces, pen and touch interfaces, and 3D data visualization. MinVR3 is being created because research practice has evolved in recent years to, almost exclusively, rely upon the Unity game and C# scripting. MinVR2 included some early support for Unity via a UnityClient that could be used together with a MinVR2 server application written in C++ to deliver input events and handle synchronization for cluster rendering. In contrast, MinVR3 embraces Unity as the supported platform. It drops explicit support for C++ graphics engines and adds native Unity/C# support for running the same code on multiple VR configurations, input device drivers beyond those supported by Unity, projection-based and other less common displays, sharing events across remote connections, and synchronized cluster rendering. Several of these features have their roots in earlier versions of MinVR, but MinVR3 is not a direct port to C#. It reimagines how the useful past concepts realized in a C++ development environment will best function for programming with C# in the Unity Editor. For example, MinVR3 introduces the idea of VREventPrototypes. These are extensible in the sense that new prototypes can be added to the system, but less flexible than the event data index used in MinVR2. However, the advantage of pre-defining the type of data produced by each event is huge for programmers working within the Unity Editor. This means that MinVR3 can provide a dropdown list of valid events produced by all of the devices, filters, and event aliases in the scene whenever a programmer needs to assign an event to a listener. High-Level Goals and Design Decisions Goal 1: Take advantage of recent commercially available hardware and game engine support for XR. Design Decision: Embrace Unity. We cannot do a better job than Unity at: a) rapid development using existing assets and packages contributed by the community, b) publishing online tutorials and examples to introduce XR programming in Unity to new programmers, c) developing and maintaining a build system that can deploy interactive graphics programs to the wide range of headset and mobile devices that are coming to market and that often run their own operating systems and their own custom device drivers, and d) probably many other things. Goal 2: Support a wide variety of displays (e.g., CAVE's, PowerWalls, multi-touch stereoscopic tables, 3DTV's, head-mounted displays). The heart of our research program is exploring how we will interact with computers 20 years from now. We need to be able to imagine and prototype what those interactive visualization devices of the future might look like, not just support the commercially available devices of today. Design Decision: Since Unity's support for this is generally poor, MinVR should provide this support in the form of scripts, prefabs and/or drivers for outputting Unity graphics to a variety of displays. Design Decision: This also implies support for running in a cluster mode and/or multi-viewport mode with frame-level synchronization of input events and stereoscopic rendering. This is required for many multi-projector displays. Goal 3: Support a wide variety of input devices (e.g., optical trackers, multi-touch input devices, haptic devices, home-built devices) following the same logic as G2. Design Decision: Unity's support is great for commercially available game and XR controllers, desktop systems, and mobile devices like tablets and phones, but it is not good for what had previously been the standard in the VR community (VRPN) and almost all of the \"more interesting\" input devices we have used previously in the lab for our research. MinVR should provide input device drivers for these devices. Goal 4: Make apps configurable, so the same application can be run on multiple of these XR input/display device combinations without refactoring or rebuilding the application. An application written for a Quest or Vive should also be able to run in a desktop mode or in a VR environment where there are no controllers present, like Google Cardboard. Design Decision: Unity's XR system provides some early support for building one application that can run on multiple similar XR devices by providing a common abstraction for XRControllers and XRHMDs. Our goal requires the application to be able to not just switch between which XR device it uses but also switch between using an XR device and a completely different device, like a tablet or desktop. Technically, Unity supports all these things, what is needed to achieve the goal is more like a wrapper and programming convention on top of Unity. Like the config files for different VR platforms used in past versions of MinVR, we need some way to toggle portions of the scene hierarchy on/off and adjust configuration settings based upon the current platform. MinVR should provide this. Design Decision: Some abstraction around the input events that the various hardware devices produce is also needed. All past versions of MinVR and the even earlier toolkits we have used at Brown University and then UMN were based on a flexible system of input events and aliases that are not necessarily associated with a particular controller, making it possible to produce compatible events from multiple different controllers. Unity's New Input System is close in spirit to this. For example, it makes it possible to bind inputs from multiple specific devices to more generic actions, like \"jump\", \"fire\", or \"cancel\". However, it does not yet work for many of the devices Unity supports, and writing new device drivers seems to require treating each device like a game controller with a current state represented in memory where changes to that state trigger events. Our past approaches seem more flexible and direct. Event produces generate Events and add them to the event queue. These producers do not need to be tied to a physical device or even state in memory. They could be a menu object that produces a \"ItemSelected\" event. The beauty of our past designs is that this ItemSelected event is really no different than a \"D-Pad Down\" event, so these events can be used interchangeably in finite state machines and other user interface code. MinVR3 should continue to utilize its own VREvent system rather than pipe events through Unity's New Input System. However, we should continue to closely watch Unity's progress as they move the system out of preview and into production. If it continues to get closer and closer to what we have found useful in the past, then it may be advantageous to reimplement some or all of MinVR to use InputActions so that we can remain more compatible with Unity and leverage all their development. In the meantime, MinVR should support translating Unity InputActions into VREvents and translating VREvents into Unity InputActions so that developers can take advantage of other Unity XR packages as they come online. Goal 5: For fast-moving research that experiments with new hardware, we need to be able to quickly expand MinVR in ways that we will not be able to guarantee will work or even compile on every platform or in every situation in which MinVR is used. Design Decision: Similar to MinVR2, MinVR3 should implement some plugin-like mechanism to support optional extensions, especially when they introduce additional dependencies, like requiring developers to install an extra library or when they only work on specific operating systems or platforms. We think work toward these five goals will enable one more: Goal 6: Package, reuse, and distribute advanced spatial user interfaces developed through the lab's research. Work toward a Unity-based collection of the lab's spatial user interface research packaged up in the form of reusable widgets and interaction techniques. As useful, the library should also include implementations of techniques developed elsewhere, and eventually, we could accept contributions to the library from outside the lab. Design Decision: This goal is enabled by MinVR. It falls outside of the original \"minimal\" scope of MinVR, so this work will grow into its own project. (Tentative Title: Open Up: A Library of Spatial Interaction Techniques.) However, it is so closely tied to the way MinVR works and so useful to consider while developing MinVR, that we will begin by working on them together in the same repository. The scripts inside MinVR3's interaction folder are like the incubator for OpenUp. Getting Started The table of contents on the left lists the important concepts in this manual in the order recommended for new MinVR users. The main page for API Documentation organizes the major classes and interfaces by theme / frequency of use."
  },
  "manual/02-install.html": {
    "href": "manual/02-install.html",
    "title": "To install MinVR3 in a Unity Project | MinVR3",
    "keywords": "To install MinVR3 in a Unity Project Prereqs MinVR3 will eventually become an open source public project. For now, it is only avaialble internally within the lab. To access it, you will need to have SSH access to github.umn.edu and be a member of the IV/LAB Organization on github.umn.edu. Create a GitHub SSH key for your UMN GitHub account on your development machine. Unity has trouble sshing with passwords; just leave the password for this key blank. If you cannot see the IV/LAB Organization on github.umn.edu, then ask the Current Lab GitHub and Software Development Czar to please add you to the org. Install via the Unity Package Manager To use the package in a read-only mode, the same way you would for packages downloaded directly from Unity: In Unity, open Window -> Package Manager. Click the + button Select Add package from git URL Paste git@github.umn.edu:ivlab-cs/MinVR3-UnityPackage.git for the latest package Optionally, install any of the MinVR Plugin Packages to enable extra functionality. Development Mode Collectively, the lab now recommends a development process where you start by adding the package to your project in read-only mode, as described above. This way, your Unity project files will always maintain a link to download the latest version of the package from git whenever the project is loaded, and all users of the package will be including it the same way. If/when you have a need to edit the package, the process is then to \"temporarily\" switch into development mode by cloning a temporary copy of the package. Then, edit this source as needed, test your edits for as long as you like, etc. When you get to a good stopping point, commit and push the changes to github from within this temporary clone inside the Packages directory. Once the latest version of your package is on github, you can then \"switch out of development mode\" by deleting the cloned repo. This will cause Unity to revert to using the read-only version of the package, which it keeps in its internal package cache, and we can trigger Unity to update this version to the latest by removing the packages-lock.json file. In summary: Follow the read-only mode steps above. Navigate your terminal or Git tool into your Unity project's main folder and clone this repository into the packages folder, e.g., cd Packages; git clone git@github.umn.edu:ivlab-cs/Template-UnityPackage.git. This will create a Template folder that contains all the sourcecode in the package. Go for it. Edit the source you just checked out; add files, etc. However, BE VERY CAREFUL NOT TO ADD THE Template-UnityPackage FOLDER TO YOUR PROJECT'S GIT REPO. We are essentially cloning one git repo inside another here, but we do not want to add the package repo as a submodule or subdirectory of the project's repo, we just want to temporarily work with the source. When you are ready to commit and push changes to the package repo, go for it. JUST MAKE SURE YOU DO THIS FROM WITHIN THE Packages/Template-UnityPackage DIRECTORY! Once these changes are up on github, you can switch out of \"development mode\" by simply deleting the Template-UnityPackage directory. The presence of that directory is like a temporary override. Once it is gone, Unity will revert back to using the cached version of Template that it originally downloaded from git. The final step is to force a refresh of the package cache so that Unity will pull in the new version of the package you just saved to github. To do this, simply delete the packages-lock.json file inside your project's Packages folder."
  },
  "manual/03-plugin-packages.html": {
    "href": "manual/03-plugin-packages.html",
    "title": "MinVR3 Plugin Packages | MinVR3",
    "keywords": "MinVR3 Plugin Packages These packages integrate with the main MinVR3 package to provide additional functionality, typically to support input or display devices that require external dependencies. All of these plugins are installed via the Unity Package Manager. The installation instructions are the same as for the main MinVR3 package, only the name of the package git URL changes: 1. In Unity, open Window -> Package Manager. 2. Click the ```+``` button 3. Select ```Add package from git URL``` 4. Paste ```git@github.umn.edu:ivlab-cs/PackageName-UnityPackage.git```, where \"PackageName\" will change for each package listed below. Available Packages Package Name Functionality / Notes git repo VRPN Provides bindings for Virtual Reality Peripheral Network (VRPN) connections (Trackers, Buttons, and Analogs). This is useful for connecting with input devices across the network; for example, an external tracking system like OptiTrack or input buttons like the Wixel. git@github.umn.edu:ivlab-cs/MinVR3Plugin-VRPN TUIO11 Reads touch data sent over a network connection via the TUIO protocol. TUIO servers and simulators are available for many touch devices and platforms. git@github.umn.edu:ivlab-cs/MinVR3Plugin-TUIO11.git WebSocket Makes it possible to use the scripts in Scripts/Connection to make a MinVR Unity program talk (send/receive VREvents) with a webpage. git@github.umn.edu:ivlab-cs/MinVR3Plugin-WebSocket.git XR Interaction Toolkit Makes it possible to use Unity's XR Interaction Toolkit and New Event System side-by-side with MinVR. VREvents can be combined into a MinVRController that implements the XRController interface that the XR Interaction Toolkit expects. AND, input from any XRControllers that Unity knows about can also be converted into VREvents. git@github.umn.edu:ivlab-cs/MinVR3Plugin-XRIToolkit Sensel Reads data from a Sensel Morph pressure-sensitive multi-touch devices and translates input to VREvents. git@github.umn.edu:ivlab-cs/MinVR3Plugin-Sensel.git zCore6 Provides support for zSpace input and display devices via their zCore 6.0 API. git@github.umn.edu:ivlab-cs/MinVR3Plugin-zCore6.git NDI Enables graphics streaming via the NDI protocol (https://ndi.com) git@github.umn.edu:ivlab-cs/MinVR3Plugin-NDI DigiStar Provides a means to render Unity content into the DigiStar software used at the Bell Museum planetarium. THIS PACKAGE CONTAINS PROPRIETARY CODE, DO NOT SHARE OUTSIDE THE LAB. git@github.umn.edu:ivlab-cs/MinVR3Plugin-DigiStar Under the Hood TODO 2023-07-10: This section is out of date but still a cool feature in Unity Some key logic for making these packages \"optional\" is contained in the MinVR3/Runtime/IVLab.MinVR3.Runtime.asmdef file, which you can see/edit within the Unity editor by clicking on the filename in the Project view. Notice that each of the packages is listed as what we will call a \"soft-dependency\" of the main Runtime package. Also, notice the rules toward the bottom of the asmdef file. When Unity finds that a the package is available, it sets a #define of the form PACKAGENAME_PRESENT. If the package is not found, PACKAGENAME_PRESENT is left undefined. Code inside the main MinVR3 package can then be compiled conditionally depending upon the presence of a certain package by placing it inside an #if PACKAGENAME_PRESENT ... #endif block. In this way, the main MinVR package compiles regardless of whether any of the optional packages are present, but functionality is limited to the features supported by installed packages."
  },
  "manual/10-vr-coord-spaces.html": {
    "href": "manual/10-vr-coord-spaces.html",
    "title": "VR Coordinate Spaces | MinVR3",
    "keywords": "VR Coordinate Spaces VR Coordinate Spaces (A More Careful) Introduction to Unity's Coordinate Spaces Local vs. World vs. Parent in the Hierarchy Unity's hierarchy is a scene graph that uses Transforms as the basic node However, this can be confusing if you have worked with scene graphs before because the transform class API and even the editor API expose \"world\" coordinates/routines not routines to go from the local space to parent space \"position\" in the editor is action \"localPosition\". when you get the localToWorld, this transforms localPosition ALL THE WAY to world coordinates, not to the parent space like a typical scene graph. if you want to transform from on GameObject's space to another at some other point in the hierarchy, you need to go through world space. when you add a child to a transform, it converts its coordinates as if they were in world, unless you add the optional \"false\" parameter The API for Transform includes 40% of the functions you might expect for converting between local, parent, and world space for points and vectors. MinVR add extensions to fill in the rest. Common Confusions with Unity's Transform Class Extensions to the MinVR Transform class MinVRRoot (RoomSpace Origin) Link to VRGems article Working with Coordinate Spaces in Code Conversion Naming Variables to Help name according to how the points in a mesh that you draw in local space get transformed, e.g., Vector3 pointInLocalSpace = ... Vector3 pointInWorldSpace = localToWorld * pointInLocalSpace; Matrix4 worldToRoom = roomToWorld.inverse(); Vector3 pointInRoomSpace = worldToRoom * pointInWorldSpace;"
  },
  "manual/11-vrconfigs.html": {
    "href": "manual/11-vrconfigs.html",
    "title": "VRConfigs for Multi-Platform VR Development | MinVR3",
    "keywords": "VRConfigs for Multi-Platform VR Development VRConfigs Goal to be able to run the same app in: Cave, Google Cardboard, or Quest by simply changing a configuration setting, not refactoring the whole project. Walkthrough an Example Prefabs combine Display(s) + InputDevices Aliases"
  },
  "manual/12-vrevents.html": {
    "href": "manual/12-vrevents.html",
    "title": "VREvent System | MinVR3",
    "keywords": "VREvent System Events, Prototypes, and Aliases Types of VREvents Accessing data carried by events VREventPrototypes VREventAliases Listening for VREvents VREventCallbacks SimpleEventListener Advanced Topics Event Filters Injecting \"Derived Events\" into the Queue example VREventType_GameObject Sending VREvents (back) to Unity's Input System This should only be done for input from devices that Unity does not already support. One useful example is to combine VRPN tracking and button events (which cannot be read by Unity's input system) in a virtual, Unity-style XRController. This makes it possible to use custom VR devices, like those used in the CAVE, with Unity's XR Interaction Toolkit, including it's built-in support for interacting with 2D UIs displayed on Unity world-space Canvases. Support for this piping of VREvents (backwards) into the Unity Input System is only planned to be supported for the New Input System with the XR Interaction Toolkit. Technically it is possible with the Legacy Input Module, but it is a fair amount of work, and it may be best to upgrade applications instead of diving into that work. Add Unity's XRInteraction Toolkit package to your project. This defines the XRController base class. Create a new GameObject and add a Runtime/Scripts/Input/MinVRToUnity/MinVRController.cs MinVRController to it. Adjust its properties to drive the position, rotation, and buttons of the controller using VREvents. Use input from this controller to drive interactions (grabbing, teleporting, etc.) supported out of the box with the XR Interaction Toolkit And/or, use it to drive interaction with Unity UI (canvases, physics raycasting). For this, you need to add Unity's XRUIInputModule to a gameobject somewhere in your scene AND you need to add a TrackedDeviceRaycaster component to each Canvas that you wish to interact with. Adding a VREvent type that carries a new type of Data"
  },
  "manual/13-input-devices.html": {
    "href": "manual/13-input-devices.html",
    "title": "Input Devices | MinVR3",
    "keywords": "Input Devices Classes that connect to hardware input devices or their software drivers to capture user input should implement the IVREventProducer interface in order to send @IVLab.MinVR3.VREvent\\s to MinVR's VREventManager. For devices already supported by Unity, we recommend simply creating a virtual input device that converts input from Unity to VREvents. As you see in the list below, these have already been developed for most of the devices handled by Unity, and it is extend these existing scripts or add new ones. For devices not supported by Unity, new support can be added by writing a class that reads data from the device and implements the IVREventProducer interface in order to send @IVLab.MinVR3.VREvent\\s to MinVR's VREventManager. If the device requires an external library or code that will only compile on some platforms, then implement the driver as a MinVR plugin package so that it does not add a required external dependency to the main MinVR package. Devices to Support Various Types of Input Misc @IVLab.MinVR3.InputActionsToVREvents [Requires: New Input System] - This class converts Unity InputActions to VREvents. It should work with any input devices that Unity can convert to InputActions, which will eventually be everything Unity supports. Right now, there are a lot of devices that are not yet supported, like the Quest and mobile phones and tablets. 6-DOF Trackers, XR Controllers @IVLab.MinVR3.UnityXR - Converts tracking, button, and axis data from devices supported by Unity's XRInputSubsystem into VREvents. VRPN Requires VRPN Plugin Package - Connect to Virtual Reality Peripheral Network (VRPN) devices -- trackers, buttons, and analogs. @IVLab.MinVR3.zSpace [Requires zSpace Plugin Package, which runs on Unity2019 only] - Support for the zSpace Device. Converts tracking data for the head and tracking and button data for the 3D pen to VREvents. Touch Input TouchBuiltin - Coverts touch data from devices supported by UnityEngine.Input into VREvents. @IVLab.MinVR3.TouchTuio [Requires TUIO11 Plugin Package] - Coverts touch data received over the network from a TUIO server into VREvents. @IVLab.MinVR3.TouchTuio [Requires Sensel Plugin Package] - Coverts touch data from a Sensel Morph device into VREvents. Phone and Tablet Sensors: MobileSensors - Converts gyro rotation, heading, and acceleration data from devices supported by UnityEngine.Input into VREvents. Mouse and Keyboard MouseAndKeyboard - Converts mouse and keyboard input to VREvents. Automatically switches between accessing the data via the New Input System or the Legacy InputModule based on what is enabled in the current project."
  },
  "manual/14-display-devices.html": {
    "href": "manual/14-display-devices.html",
    "title": "Display Devices | MinVR3",
    "keywords": "Display Devices Supported Displays TrackedProjectionScreen and its many uses. Fisheye rendering for CAVEs. WarpedProjection rendering for AR/MR art installations (copy over from Augmented Paafu Mat project) Calibration Techniques"
  },
  "manual/15-remote-connections.html": {
    "href": "manual/15-remote-connections.html",
    "title": "Remote Connections | MinVR3",
    "keywords": "Remote Connections MinVR apps can communicate with remote applications or services by sending VREvents across the network. This can be done in two different modes. Remote Connections (described on this page) are for situations where the goal is to pass messages or data. VREvents are also shared across the network when running MinVR in a cluster mode, but this is for strict frame-level synchronization on multiple machines that are connected on a fast, local network to render on tiled displays. Supported connections MinVR3 supports networked interoperability between Unity applications, and even other languages. The following connection types are supported: Unity  Unity Unity  C++ (via MinVR3.cpp~) Unity  JavaScript (via MinVR3.js~) Unity  Python (via MinVR3.py~) Getting started with remote connections In general, you need up to three components in your Unity scene to make remote connections work: A VR Event Connection that actually transmits data over the network (generally different for each language client, some of the available ones are listed below) TcpJsonVREventConnection - transmits VREvents as JSON strings over a TCP socket (this is a good default for Unity  Unity communication, and other languages like Python and C++) TcpVREventConnection - transmits VREvents as binary over a TCP socket (this is good for Unity  Unity communication if you need it to be faster than JSON [has not actually been proven to be faster]) HttpWebSocketVREventConnection (via the MinVR3 WebSocket plugin) - transmits VREvents by WebSocket (best for communicating with browsers where the webpage itself is served from Unity) A VREventConnectionReceiver component (receives specified events from the remote connection and adds them to MinVR3's event queue) A VREventConnectionSender component (sends specified events from MinVR3's event queue to the remote connection) For example, if you want to have two Unity apps communicate with one another, use a setup like this (this just sends a \"Shutdown\" event when the server is done running): App 1 (Server): Under a GameObject named \"VREventConnection - Server\": TcpJsonVREventConnection act as server, listen for connections listen for connections on port 9000 VREventConnectionReceiver optional in server - server doesn't need to listen for anything in this test app VREventConnectionSender use send list send the MinVR3/Shutdown event App 2 (Client): Under a GameObject named \"VREventConnection - Client\": TcpJsonVREventConnection act as client, connect to server connect to server 127.0.0.1 (localhost) connect to server port 9000 VREventConnectionReceiver Add a new event MinVR3/Shutdown VREventConnectionSender optional in client - client doesn't need to send anything in this app"
  },
  "manual/16-cluster.html": {
    "href": "manual/16-cluster.html",
    "title": "Synchronized Cluster Rendering for Interactive Tiled Displays | MinVR3",
    "keywords": "Synchronized Cluster Rendering for Interactive Tiled Displays Cluster mode provides support for tiled displays powered by a cluster of graphics computers. Key features are: Frame-level dual or quad-buffered rendering synchronization (i.e., swap lock) Frame-level event synchronization (i.e., VREvents are synchronized across all nodes each frame, and any node can act as the original event generator)."
  },
  "manual/20-interaction.html": {
    "href": "manual/20-interaction.html",
    "title": "Interaction Techniques | MinVR3",
    "keywords": "Interaction Techniques This work will grow into its own project. (Tentative Title: Open Up: The Spatial Interaction Technique Library.) However, it is so closely tied to the way MinVR works and so useful to consider while developing MinVR, that we will begin by working on them together in the same repository. The scripts inside MinVR3's interaction folder are like the incubator for OpenUp. \"OpenUp\" - The Spatial Interaction Technique Library BuildingBlocks FSM SharedToken SimpleEventListener TrackedPoseDriver Cursors Desktop TrackballCamera ObjectManip CraftCam (reimplement from MinGfx) UniCam (reimplement from MinGfx) Widgets Menus Basic Floating CavePainting-style Marking Menus Invisible Palete Spatial Sliders, Knobs ColorPicker (reimplement from CavePainting) Painting/Sketching CavePainting / Drawing on Air Lift-Off Object Manipulation PRISM Constraint-Based Widgets Visualization SliceWIM Bento Box Worlds in Wedges"
  },
  "manual/changelog.html": {
    "href": "manual/changelog.html",
    "title": "| MinVR3",
    "keywords": ""
  },
  "manual/license.html": {
    "href": "manual/license.html",
    "title": "| MinVR3",
    "keywords": "Copyright 2020,2021,2022 Regents of the University of Minnesota, All Rights Reserved"
  },
  "manual/tutorial-basic-bimanual-manipulation.html": {
    "href": "manual/tutorial-basic-bimanual-manipulation.html",
    "title": "MinVR3 Tutorial: Basic Bimanual Manipulation | MinVR3",
    "keywords": "MinVR3 Tutorial: Basic Bimanual Manipulation In this page, we'll go over a brief tutorial for using MinVR3 to create a portable app that enables a user to translate, rotate, and scale an object using MinVR3 events across multiple devices and build targets. In the course of this tutorial, we will cover basic terminology of MinVR3 (VREvents, VRConfigs, and more), as well as how to use the building blocks provided in this library. 0. Prerequisites This tutorial assumes a working knowledge of the Unity game engine, C# scripting, and git version control. It also assumes you have installed the MinVR3 Package. 1. Setting up a MinVR3 Scene The two key \"root\" gameobjects for any MinVR3 scene are the VREngine and the Room Space. The VREngine is the main \"guts\" of MinVR3 that makes it all tick; this GameObject is a singleton and persists when new scenes are loaded. The Room Space gameobject represents the \"Room Space\" relative to the app's user(s). Read more about coordinate spaces in the Coordinate Spaces chapter of the manual. Let's start by creating a blank scene in Unity: create a new scene and delete any objects (cameras, lights, etc) that show up by default. Then open the MinVR3 Menu and create the Room Space Origin and VREngine (GameObject > MinVR > Getting Started > Create \"VREngine\" and \"Room Space Origin\" GameObjects). After adding these GameObjects, the scene looks like this: Now, let's make the scene a little more exciting! Add a few 3D objects to the scene and scale them / rotate them however you wish; add these objects in the Room Space. Just make sure you have at least one cube with a box collider attached and one light in the scene. Our tutorial scene looks like this: 2. Adding your first VRConfig Now, that's obviously not very exciting since there are no input or output devices in the scene yet. Let's fix that by adding our first VRConfig: a configuration of input and output devices for specific hardware setup. Peruse the already-existing VRConfigs at GameObject > MinVR > VRConfig - you'll notice there are lots of them! In the scene, generally VRConfigs should be a child of the \"Room Space\" gameobject - after all, the user is providing input and receiving output in this space. As a general rule of thumb, we can create a GameObject named \"VRConfigs\" underneath the Room Space gameobject and add all of the VRConfigs as children. Now, let's create the first VRConfig: a basic VR simulator! This simulator enables us to develop applications without having any specialized hardware present - it uses the keyboard and mouse to emulate spatial interactions like head tracking, and bimanual (two-handed) input devices. Click on the VRConfigs GameObject you created underneath Room Space, then go to GameObject > MinVR > VRConfigs > VRConfig_BasicVRSimulator. Select the VREngine GameObject and set the \"Startup VRConfig\" under the VR Config Manager to the BasicVRSimulator you just created. At the end of this section your scene should look like this: 3. Adding some interactivity with VREvents The core of MinVR3 interactivity is based on the concept of VREvents. With the VR simulator VRConfig we just added to the scene, a number of new VREvent types have been made available in the scene. Select the VREngine GameObject and twirl down the \"VR Event prototypes in this scene\" section, and twirl down any of the GameObjects listed to see what VREvents it can produce. For example, the Event Aliases GameObject produces Head/Position and Head/Rotation, which represent the head tracking position and rotation, respectively. Notice also under the Input Devices GameObject that FakeTrackers/Head/Position and FakeTrackers/Head/Rotation are listed here. What's up with this multiple Heads thing? In general, it's best to provide a layer of separation between the raw input (in this case, FakeTrackers/Head) and the application level meaning (Head). This makes it possible to handle different input devices and have them control the same part of the application under different VRConfigs. For example, under the VR Simulator, head tracking data is supplied by mouse and keyboard, whereas on the Oculus Quest the head tracking is supplied by UnityXR. So, long story short: create a series of VREvent Aliases to rename (or rename + clone) your events so they have a canonical, application-level meaning and maintain this separately from the incoming, raw input device data. With this in mind, let's add some interactivity to the scene now with VREvents! MinVR has several powerful tools that can be used to create spatial interactions, this tutorial just shows one of the many possibilities. The key building blocks for adding a simple bimanual interaction (e.g., grabbing with a button press) are as follows: Defining the VREvents for both hands (already done above - see VREvents DH/* and NDH/*: these are the position and rotation events for the Dominant and Non-Dominant hands). Adding cursors to the scene to show each hand Adding required scripts Bimanual object selector Bounds highlighter Bimanual object manipulator Adding Cursors MinVR3 has a couple handy cursors that already exist. You can add them to the scene under Room Space by going to GameObject > MinVR Interaction > Cursors. Add one for the Dominant and Non-Dominant hands. Here we've added a CavePainting brush and a Small Cube Cursor. We rescaled the Brush Model in the CavePainting to be smaller (0.1). Adding required scripts The Bimanual Object Selector enables us to select objects with one or both hands. Create a new GameObject (in Room Space) named \"Bimanual Interactions\" Add a new Bimanual Object Selector component to the GameObject Drag and drop / select the cursors you added in the previous section to the \"Cursor Transform\" and \"Cursor Transform 2\" of the Bimanual Object Selector script. Now, VREvents \"Select\" and \"Deselect\" will be fired every time either cursor comes close to an object with a collider (any collider). To visualize selections, we can add a Basic Highlighter component to the Bimanual Interactions GameObject. In your project, create a new Material and make it a memorable color, then drag and drop this material into the \"Highlight Material\" slot for the Basic Highlighter. Choose the Select and Deselect events too. When you press play, your scene should now behave something like this: (use 1 and 2 keys to switch between DH and NDH tracker) Lastly, after you've verified selection and highlighting are working correctly, add a \"Bimanual Object Manipulator\" component to the Bimanual Interactions GameObject. Set the event slots as follows (this enables the script to react to VREvents when the DH and NDH move, rotate, or have buttons pressed, or an object is selected): Now, when you press play, you should be able to move the objects in the scene around, rotate them, and scale them: Okay, that's it for the basics! Now, it's time to make our app portable between devices. 4. Adding a MinVR3 Plugin So far, we've only used input from the keyboard and mouse. But, what if we wanted to use a spatial tracker, touch screen, or other custom input device? MinVR has us covered for this. In this section, we will add a MinVR3 Plugin to connect to Virtual Reality Peripheral Network (VRPN) devices - this will enable us to interface with the lab's high-resolution optical tracking system (OptiTrack Tracking Tools / Motive). TODO 5. Adding more VRConfigs The real power of MinVR3 is that it enables your app to support multiple target platforms without changing the core structure of your app. This is achieved through VRConfigs. We've already added one VRConfig to the scene: the Basic VR Simulator. Now, let's say we want to deploy our app to the CAVE. TODO"
  }
}